
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model company
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type company = $Result.DefaultSelection<Prisma.$companyPayload>
/**
 * Model company_image
 * 
 */
export type company_image = $Result.DefaultSelection<Prisma.$company_imagePayload>
/**
 * Model company_industry
 * 
 */
export type company_industry = $Result.DefaultSelection<Prisma.$company_industryPayload>
/**
 * Model industry_category
 * 
 */
export type industry_category = $Result.DefaultSelection<Prisma.$industry_categoryPayload>
/**
 * Model job
 * 
 */
export type job = $Result.DefaultSelection<Prisma.$jobPayload>
/**
 * Model job_category
 * 
 */
export type job_category = $Result.DefaultSelection<Prisma.$job_categoryPayload>
/**
 * Model job_category_map
 * 
 */
export type job_category_map = $Result.DefaultSelection<Prisma.$job_category_mapPayload>
/**
 * Model job_salary
 * 
 */
export type job_salary = $Result.DefaultSelection<Prisma.$job_salaryPayload>
/**
 * Model job_salary_map
 * 
 */
export type job_salary_map = $Result.DefaultSelection<Prisma.$job_salary_mapPayload>
/**
 * Model job_schedule
 * 
 */
export type job_schedule = $Result.DefaultSelection<Prisma.$job_schedulePayload>
/**
 * Model job_schedule_map
 * 
 */
export type job_schedule_map = $Result.DefaultSelection<Prisma.$job_schedule_mapPayload>
/**
 * Model job_skill
 * 
 */
export type job_skill = $Result.DefaultSelection<Prisma.$job_skillPayload>
/**
 * Model job_skill_map
 * 
 */
export type job_skill_map = $Result.DefaultSelection<Prisma.$job_skill_mapPayload>
/**
 * Model job_source
 * 
 */
export type job_source = $Result.DefaultSelection<Prisma.$job_sourcePayload>
/**
 * Model job_source_map
 * 
 */
export type job_source_map = $Result.DefaultSelection<Prisma.$job_source_mapPayload>
/**
 * Model job_type
 * 
 */
export type job_type = $Result.DefaultSelection<Prisma.$job_typePayload>
/**
 * Model job_type_map
 * 
 */
export type job_type_map = $Result.DefaultSelection<Prisma.$job_type_mapPayload>
/**
 * Model city
 * 
 */
export type city = $Result.DefaultSelection<Prisma.$cityPayload>
/**
 * Model country
 * 
 */
export type country = $Result.DefaultSelection<Prisma.$countryPayload>
/**
 * Model state
 * 
 */
export type state = $Result.DefaultSelection<Prisma.$statePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const companySizes: {
  SMALL: 'SMALL',
  MEDIUM: 'MEDIUM',
  LARGE: 'LARGE',
  ENTERPRISE: 'ENTERPRISE'
};

export type companySizes = (typeof companySizes)[keyof typeof companySizes]


export const salaryFrequency: {
  MONTHLY: 'MONTHLY',
  YEARLY: 'YEARLY',
  PROGRESSIVE: 'PROGRESSIVE'
};

export type salaryFrequency = (typeof salaryFrequency)[keyof typeof salaryFrequency]

}

export type companySizes = $Enums.companySizes

export const companySizes: typeof $Enums.companySizes

export type salaryFrequency = $Enums.salaryFrequency

export const salaryFrequency: typeof $Enums.salaryFrequency

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Companies
 * const companies = await prisma.company.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Companies
   * const companies = await prisma.company.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.company`: Exposes CRUD operations for the **company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.companyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company_image`: Exposes CRUD operations for the **company_image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_images
    * const company_images = await prisma.company_image.findMany()
    * ```
    */
  get company_image(): Prisma.company_imageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company_industry`: Exposes CRUD operations for the **company_industry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_industries
    * const company_industries = await prisma.company_industry.findMany()
    * ```
    */
  get company_industry(): Prisma.company_industryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.industry_category`: Exposes CRUD operations for the **industry_category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Industry_categories
    * const industry_categories = await prisma.industry_category.findMany()
    * ```
    */
  get industry_category(): Prisma.industry_categoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job`: Exposes CRUD operations for the **job** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.job.findMany()
    * ```
    */
  get job(): Prisma.jobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_category`: Exposes CRUD operations for the **job_category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_categories
    * const job_categories = await prisma.job_category.findMany()
    * ```
    */
  get job_category(): Prisma.job_categoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_category_map`: Exposes CRUD operations for the **job_category_map** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_category_maps
    * const job_category_maps = await prisma.job_category_map.findMany()
    * ```
    */
  get job_category_map(): Prisma.job_category_mapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_salary`: Exposes CRUD operations for the **job_salary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_salaries
    * const job_salaries = await prisma.job_salary.findMany()
    * ```
    */
  get job_salary(): Prisma.job_salaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_salary_map`: Exposes CRUD operations for the **job_salary_map** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_salary_maps
    * const job_salary_maps = await prisma.job_salary_map.findMany()
    * ```
    */
  get job_salary_map(): Prisma.job_salary_mapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_schedule`: Exposes CRUD operations for the **job_schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_schedules
    * const job_schedules = await prisma.job_schedule.findMany()
    * ```
    */
  get job_schedule(): Prisma.job_scheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_schedule_map`: Exposes CRUD operations for the **job_schedule_map** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_schedule_maps
    * const job_schedule_maps = await prisma.job_schedule_map.findMany()
    * ```
    */
  get job_schedule_map(): Prisma.job_schedule_mapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_skill`: Exposes CRUD operations for the **job_skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_skills
    * const job_skills = await prisma.job_skill.findMany()
    * ```
    */
  get job_skill(): Prisma.job_skillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_skill_map`: Exposes CRUD operations for the **job_skill_map** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_skill_maps
    * const job_skill_maps = await prisma.job_skill_map.findMany()
    * ```
    */
  get job_skill_map(): Prisma.job_skill_mapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_source`: Exposes CRUD operations for the **job_source** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_sources
    * const job_sources = await prisma.job_source.findMany()
    * ```
    */
  get job_source(): Prisma.job_sourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_source_map`: Exposes CRUD operations for the **job_source_map** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_source_maps
    * const job_source_maps = await prisma.job_source_map.findMany()
    * ```
    */
  get job_source_map(): Prisma.job_source_mapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_type`: Exposes CRUD operations for the **job_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_types
    * const job_types = await prisma.job_type.findMany()
    * ```
    */
  get job_type(): Prisma.job_typeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_type_map`: Exposes CRUD operations for the **job_type_map** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_type_maps
    * const job_type_maps = await prisma.job_type_map.findMany()
    * ```
    */
  get job_type_map(): Prisma.job_type_mapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **city** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.cityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.countryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.state`: Exposes CRUD operations for the **state** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more States
    * const states = await prisma.state.findMany()
    * ```
    */
  get state(): Prisma.stateDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    company: 'company',
    company_image: 'company_image',
    company_industry: 'company_industry',
    industry_category: 'industry_category',
    job: 'job',
    job_category: 'job_category',
    job_category_map: 'job_category_map',
    job_salary: 'job_salary',
    job_salary_map: 'job_salary_map',
    job_schedule: 'job_schedule',
    job_schedule_map: 'job_schedule_map',
    job_skill: 'job_skill',
    job_skill_map: 'job_skill_map',
    job_source: 'job_source',
    job_source_map: 'job_source_map',
    job_type: 'job_type',
    job_type_map: 'job_type_map',
    city: 'city',
    country: 'country',
    state: 'state'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "company" | "company_image" | "company_industry" | "industry_category" | "job" | "job_category" | "job_category_map" | "job_salary" | "job_salary_map" | "job_schedule" | "job_schedule_map" | "job_skill" | "job_skill_map" | "job_source" | "job_source_map" | "job_type" | "job_type_map" | "city" | "country" | "state"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      company: {
        payload: Prisma.$companyPayload<ExtArgs>
        fields: Prisma.companyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyPayload>
          }
          findFirst: {
            args: Prisma.companyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyPayload>
          }
          findMany: {
            args: Prisma.companyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyPayload>[]
          }
          create: {
            args: Prisma.companyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyPayload>
          }
          createMany: {
            args: Prisma.companyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.companyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyPayload>[]
          }
          delete: {
            args: Prisma.companyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyPayload>
          }
          update: {
            args: Prisma.companyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyPayload>
          }
          deleteMany: {
            args: Prisma.companyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.companyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyPayload>[]
          }
          upsert: {
            args: Prisma.companyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.companyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.companyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      company_image: {
        payload: Prisma.$company_imagePayload<ExtArgs>
        fields: Prisma.company_imageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.company_imageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_imagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.company_imageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_imagePayload>
          }
          findFirst: {
            args: Prisma.company_imageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_imagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.company_imageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_imagePayload>
          }
          findMany: {
            args: Prisma.company_imageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_imagePayload>[]
          }
          create: {
            args: Prisma.company_imageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_imagePayload>
          }
          createMany: {
            args: Prisma.company_imageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.company_imageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_imagePayload>[]
          }
          delete: {
            args: Prisma.company_imageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_imagePayload>
          }
          update: {
            args: Prisma.company_imageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_imagePayload>
          }
          deleteMany: {
            args: Prisma.company_imageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.company_imageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.company_imageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_imagePayload>[]
          }
          upsert: {
            args: Prisma.company_imageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_imagePayload>
          }
          aggregate: {
            args: Prisma.Company_imageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany_image>
          }
          groupBy: {
            args: Prisma.company_imageGroupByArgs<ExtArgs>
            result: $Utils.Optional<Company_imageGroupByOutputType>[]
          }
          count: {
            args: Prisma.company_imageCountArgs<ExtArgs>
            result: $Utils.Optional<Company_imageCountAggregateOutputType> | number
          }
        }
      }
      company_industry: {
        payload: Prisma.$company_industryPayload<ExtArgs>
        fields: Prisma.company_industryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.company_industryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_industryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.company_industryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_industryPayload>
          }
          findFirst: {
            args: Prisma.company_industryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_industryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.company_industryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_industryPayload>
          }
          findMany: {
            args: Prisma.company_industryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_industryPayload>[]
          }
          create: {
            args: Prisma.company_industryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_industryPayload>
          }
          createMany: {
            args: Prisma.company_industryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.company_industryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_industryPayload>[]
          }
          delete: {
            args: Prisma.company_industryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_industryPayload>
          }
          update: {
            args: Prisma.company_industryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_industryPayload>
          }
          deleteMany: {
            args: Prisma.company_industryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.company_industryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.company_industryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_industryPayload>[]
          }
          upsert: {
            args: Prisma.company_industryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_industryPayload>
          }
          aggregate: {
            args: Prisma.Company_industryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany_industry>
          }
          groupBy: {
            args: Prisma.company_industryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Company_industryGroupByOutputType>[]
          }
          count: {
            args: Prisma.company_industryCountArgs<ExtArgs>
            result: $Utils.Optional<Company_industryCountAggregateOutputType> | number
          }
        }
      }
      industry_category: {
        payload: Prisma.$industry_categoryPayload<ExtArgs>
        fields: Prisma.industry_categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.industry_categoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$industry_categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.industry_categoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$industry_categoryPayload>
          }
          findFirst: {
            args: Prisma.industry_categoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$industry_categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.industry_categoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$industry_categoryPayload>
          }
          findMany: {
            args: Prisma.industry_categoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$industry_categoryPayload>[]
          }
          create: {
            args: Prisma.industry_categoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$industry_categoryPayload>
          }
          createMany: {
            args: Prisma.industry_categoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.industry_categoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$industry_categoryPayload>[]
          }
          delete: {
            args: Prisma.industry_categoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$industry_categoryPayload>
          }
          update: {
            args: Prisma.industry_categoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$industry_categoryPayload>
          }
          deleteMany: {
            args: Prisma.industry_categoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.industry_categoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.industry_categoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$industry_categoryPayload>[]
          }
          upsert: {
            args: Prisma.industry_categoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$industry_categoryPayload>
          }
          aggregate: {
            args: Prisma.Industry_categoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndustry_category>
          }
          groupBy: {
            args: Prisma.industry_categoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Industry_categoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.industry_categoryCountArgs<ExtArgs>
            result: $Utils.Optional<Industry_categoryCountAggregateOutputType> | number
          }
        }
      }
      job: {
        payload: Prisma.$jobPayload<ExtArgs>
        fields: Prisma.jobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.jobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.jobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          findFirst: {
            args: Prisma.jobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.jobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          findMany: {
            args: Prisma.jobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>[]
          }
          create: {
            args: Prisma.jobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          createMany: {
            args: Prisma.jobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.jobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>[]
          }
          delete: {
            args: Prisma.jobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          update: {
            args: Prisma.jobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          deleteMany: {
            args: Prisma.jobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.jobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.jobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>[]
          }
          upsert: {
            args: Prisma.jobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          aggregate: {
            args: Prisma.JobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob>
          }
          groupBy: {
            args: Prisma.jobGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobGroupByOutputType>[]
          }
          count: {
            args: Prisma.jobCountArgs<ExtArgs>
            result: $Utils.Optional<JobCountAggregateOutputType> | number
          }
        }
      }
      job_category: {
        payload: Prisma.$job_categoryPayload<ExtArgs>
        fields: Prisma.job_categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_categoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_categoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_categoryPayload>
          }
          findFirst: {
            args: Prisma.job_categoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_categoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_categoryPayload>
          }
          findMany: {
            args: Prisma.job_categoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_categoryPayload>[]
          }
          create: {
            args: Prisma.job_categoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_categoryPayload>
          }
          createMany: {
            args: Prisma.job_categoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.job_categoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_categoryPayload>[]
          }
          delete: {
            args: Prisma.job_categoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_categoryPayload>
          }
          update: {
            args: Prisma.job_categoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_categoryPayload>
          }
          deleteMany: {
            args: Prisma.job_categoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_categoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.job_categoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_categoryPayload>[]
          }
          upsert: {
            args: Prisma.job_categoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_categoryPayload>
          }
          aggregate: {
            args: Prisma.Job_categoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_category>
          }
          groupBy: {
            args: Prisma.job_categoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_categoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_categoryCountArgs<ExtArgs>
            result: $Utils.Optional<Job_categoryCountAggregateOutputType> | number
          }
        }
      }
      job_category_map: {
        payload: Prisma.$job_category_mapPayload<ExtArgs>
        fields: Prisma.job_category_mapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_category_mapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_category_mapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_category_mapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_category_mapPayload>
          }
          findFirst: {
            args: Prisma.job_category_mapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_category_mapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_category_mapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_category_mapPayload>
          }
          findMany: {
            args: Prisma.job_category_mapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_category_mapPayload>[]
          }
          create: {
            args: Prisma.job_category_mapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_category_mapPayload>
          }
          createMany: {
            args: Prisma.job_category_mapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.job_category_mapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_category_mapPayload>[]
          }
          delete: {
            args: Prisma.job_category_mapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_category_mapPayload>
          }
          update: {
            args: Prisma.job_category_mapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_category_mapPayload>
          }
          deleteMany: {
            args: Prisma.job_category_mapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_category_mapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.job_category_mapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_category_mapPayload>[]
          }
          upsert: {
            args: Prisma.job_category_mapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_category_mapPayload>
          }
          aggregate: {
            args: Prisma.Job_category_mapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_category_map>
          }
          groupBy: {
            args: Prisma.job_category_mapGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_category_mapGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_category_mapCountArgs<ExtArgs>
            result: $Utils.Optional<Job_category_mapCountAggregateOutputType> | number
          }
        }
      }
      job_salary: {
        payload: Prisma.$job_salaryPayload<ExtArgs>
        fields: Prisma.job_salaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_salaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_salaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salaryPayload>
          }
          findFirst: {
            args: Prisma.job_salaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_salaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salaryPayload>
          }
          findMany: {
            args: Prisma.job_salaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salaryPayload>[]
          }
          create: {
            args: Prisma.job_salaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salaryPayload>
          }
          createMany: {
            args: Prisma.job_salaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.job_salaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salaryPayload>[]
          }
          delete: {
            args: Prisma.job_salaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salaryPayload>
          }
          update: {
            args: Prisma.job_salaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salaryPayload>
          }
          deleteMany: {
            args: Prisma.job_salaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_salaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.job_salaryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salaryPayload>[]
          }
          upsert: {
            args: Prisma.job_salaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salaryPayload>
          }
          aggregate: {
            args: Prisma.Job_salaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_salary>
          }
          groupBy: {
            args: Prisma.job_salaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_salaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_salaryCountArgs<ExtArgs>
            result: $Utils.Optional<Job_salaryCountAggregateOutputType> | number
          }
        }
      }
      job_salary_map: {
        payload: Prisma.$job_salary_mapPayload<ExtArgs>
        fields: Prisma.job_salary_mapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_salary_mapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salary_mapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_salary_mapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salary_mapPayload>
          }
          findFirst: {
            args: Prisma.job_salary_mapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salary_mapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_salary_mapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salary_mapPayload>
          }
          findMany: {
            args: Prisma.job_salary_mapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salary_mapPayload>[]
          }
          create: {
            args: Prisma.job_salary_mapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salary_mapPayload>
          }
          createMany: {
            args: Prisma.job_salary_mapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.job_salary_mapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salary_mapPayload>[]
          }
          delete: {
            args: Prisma.job_salary_mapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salary_mapPayload>
          }
          update: {
            args: Prisma.job_salary_mapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salary_mapPayload>
          }
          deleteMany: {
            args: Prisma.job_salary_mapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_salary_mapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.job_salary_mapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salary_mapPayload>[]
          }
          upsert: {
            args: Prisma.job_salary_mapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_salary_mapPayload>
          }
          aggregate: {
            args: Prisma.Job_salary_mapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_salary_map>
          }
          groupBy: {
            args: Prisma.job_salary_mapGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_salary_mapGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_salary_mapCountArgs<ExtArgs>
            result: $Utils.Optional<Job_salary_mapCountAggregateOutputType> | number
          }
        }
      }
      job_schedule: {
        payload: Prisma.$job_schedulePayload<ExtArgs>
        fields: Prisma.job_scheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_scheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_scheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedulePayload>
          }
          findFirst: {
            args: Prisma.job_scheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_scheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedulePayload>
          }
          findMany: {
            args: Prisma.job_scheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedulePayload>[]
          }
          create: {
            args: Prisma.job_scheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedulePayload>
          }
          createMany: {
            args: Prisma.job_scheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.job_scheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedulePayload>[]
          }
          delete: {
            args: Prisma.job_scheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedulePayload>
          }
          update: {
            args: Prisma.job_scheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedulePayload>
          }
          deleteMany: {
            args: Prisma.job_scheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_scheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.job_scheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedulePayload>[]
          }
          upsert: {
            args: Prisma.job_scheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedulePayload>
          }
          aggregate: {
            args: Prisma.Job_scheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_schedule>
          }
          groupBy: {
            args: Prisma.job_scheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_scheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_scheduleCountArgs<ExtArgs>
            result: $Utils.Optional<Job_scheduleCountAggregateOutputType> | number
          }
        }
      }
      job_schedule_map: {
        payload: Prisma.$job_schedule_mapPayload<ExtArgs>
        fields: Prisma.job_schedule_mapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_schedule_mapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedule_mapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_schedule_mapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedule_mapPayload>
          }
          findFirst: {
            args: Prisma.job_schedule_mapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedule_mapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_schedule_mapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedule_mapPayload>
          }
          findMany: {
            args: Prisma.job_schedule_mapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedule_mapPayload>[]
          }
          create: {
            args: Prisma.job_schedule_mapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedule_mapPayload>
          }
          createMany: {
            args: Prisma.job_schedule_mapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.job_schedule_mapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedule_mapPayload>[]
          }
          delete: {
            args: Prisma.job_schedule_mapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedule_mapPayload>
          }
          update: {
            args: Prisma.job_schedule_mapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedule_mapPayload>
          }
          deleteMany: {
            args: Prisma.job_schedule_mapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_schedule_mapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.job_schedule_mapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedule_mapPayload>[]
          }
          upsert: {
            args: Prisma.job_schedule_mapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_schedule_mapPayload>
          }
          aggregate: {
            args: Prisma.Job_schedule_mapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_schedule_map>
          }
          groupBy: {
            args: Prisma.job_schedule_mapGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_schedule_mapGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_schedule_mapCountArgs<ExtArgs>
            result: $Utils.Optional<Job_schedule_mapCountAggregateOutputType> | number
          }
        }
      }
      job_skill: {
        payload: Prisma.$job_skillPayload<ExtArgs>
        fields: Prisma.job_skillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_skillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_skillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skillPayload>
          }
          findFirst: {
            args: Prisma.job_skillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_skillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skillPayload>
          }
          findMany: {
            args: Prisma.job_skillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skillPayload>[]
          }
          create: {
            args: Prisma.job_skillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skillPayload>
          }
          createMany: {
            args: Prisma.job_skillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.job_skillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skillPayload>[]
          }
          delete: {
            args: Prisma.job_skillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skillPayload>
          }
          update: {
            args: Prisma.job_skillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skillPayload>
          }
          deleteMany: {
            args: Prisma.job_skillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_skillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.job_skillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skillPayload>[]
          }
          upsert: {
            args: Prisma.job_skillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skillPayload>
          }
          aggregate: {
            args: Prisma.Job_skillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_skill>
          }
          groupBy: {
            args: Prisma.job_skillGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_skillGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_skillCountArgs<ExtArgs>
            result: $Utils.Optional<Job_skillCountAggregateOutputType> | number
          }
        }
      }
      job_skill_map: {
        payload: Prisma.$job_skill_mapPayload<ExtArgs>
        fields: Prisma.job_skill_mapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_skill_mapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skill_mapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_skill_mapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skill_mapPayload>
          }
          findFirst: {
            args: Prisma.job_skill_mapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skill_mapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_skill_mapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skill_mapPayload>
          }
          findMany: {
            args: Prisma.job_skill_mapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skill_mapPayload>[]
          }
          create: {
            args: Prisma.job_skill_mapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skill_mapPayload>
          }
          createMany: {
            args: Prisma.job_skill_mapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.job_skill_mapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skill_mapPayload>[]
          }
          delete: {
            args: Prisma.job_skill_mapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skill_mapPayload>
          }
          update: {
            args: Prisma.job_skill_mapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skill_mapPayload>
          }
          deleteMany: {
            args: Prisma.job_skill_mapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_skill_mapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.job_skill_mapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skill_mapPayload>[]
          }
          upsert: {
            args: Prisma.job_skill_mapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_skill_mapPayload>
          }
          aggregate: {
            args: Prisma.Job_skill_mapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_skill_map>
          }
          groupBy: {
            args: Prisma.job_skill_mapGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_skill_mapGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_skill_mapCountArgs<ExtArgs>
            result: $Utils.Optional<Job_skill_mapCountAggregateOutputType> | number
          }
        }
      }
      job_source: {
        payload: Prisma.$job_sourcePayload<ExtArgs>
        fields: Prisma.job_sourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_sourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_sourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_sourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_sourcePayload>
          }
          findFirst: {
            args: Prisma.job_sourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_sourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_sourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_sourcePayload>
          }
          findMany: {
            args: Prisma.job_sourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_sourcePayload>[]
          }
          create: {
            args: Prisma.job_sourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_sourcePayload>
          }
          createMany: {
            args: Prisma.job_sourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.job_sourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_sourcePayload>[]
          }
          delete: {
            args: Prisma.job_sourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_sourcePayload>
          }
          update: {
            args: Prisma.job_sourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_sourcePayload>
          }
          deleteMany: {
            args: Prisma.job_sourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_sourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.job_sourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_sourcePayload>[]
          }
          upsert: {
            args: Prisma.job_sourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_sourcePayload>
          }
          aggregate: {
            args: Prisma.Job_sourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_source>
          }
          groupBy: {
            args: Prisma.job_sourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_sourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_sourceCountArgs<ExtArgs>
            result: $Utils.Optional<Job_sourceCountAggregateOutputType> | number
          }
        }
      }
      job_source_map: {
        payload: Prisma.$job_source_mapPayload<ExtArgs>
        fields: Prisma.job_source_mapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_source_mapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_source_mapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_source_mapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_source_mapPayload>
          }
          findFirst: {
            args: Prisma.job_source_mapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_source_mapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_source_mapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_source_mapPayload>
          }
          findMany: {
            args: Prisma.job_source_mapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_source_mapPayload>[]
          }
          create: {
            args: Prisma.job_source_mapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_source_mapPayload>
          }
          createMany: {
            args: Prisma.job_source_mapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.job_source_mapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_source_mapPayload>[]
          }
          delete: {
            args: Prisma.job_source_mapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_source_mapPayload>
          }
          update: {
            args: Prisma.job_source_mapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_source_mapPayload>
          }
          deleteMany: {
            args: Prisma.job_source_mapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_source_mapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.job_source_mapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_source_mapPayload>[]
          }
          upsert: {
            args: Prisma.job_source_mapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_source_mapPayload>
          }
          aggregate: {
            args: Prisma.Job_source_mapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_source_map>
          }
          groupBy: {
            args: Prisma.job_source_mapGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_source_mapGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_source_mapCountArgs<ExtArgs>
            result: $Utils.Optional<Job_source_mapCountAggregateOutputType> | number
          }
        }
      }
      job_type: {
        payload: Prisma.$job_typePayload<ExtArgs>
        fields: Prisma.job_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_typePayload>
          }
          findFirst: {
            args: Prisma.job_typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_typePayload>
          }
          findMany: {
            args: Prisma.job_typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_typePayload>[]
          }
          create: {
            args: Prisma.job_typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_typePayload>
          }
          createMany: {
            args: Prisma.job_typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.job_typeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_typePayload>[]
          }
          delete: {
            args: Prisma.job_typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_typePayload>
          }
          update: {
            args: Prisma.job_typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_typePayload>
          }
          deleteMany: {
            args: Prisma.job_typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.job_typeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_typePayload>[]
          }
          upsert: {
            args: Prisma.job_typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_typePayload>
          }
          aggregate: {
            args: Prisma.Job_typeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_type>
          }
          groupBy: {
            args: Prisma.job_typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_typeCountArgs<ExtArgs>
            result: $Utils.Optional<Job_typeCountAggregateOutputType> | number
          }
        }
      }
      job_type_map: {
        payload: Prisma.$job_type_mapPayload<ExtArgs>
        fields: Prisma.job_type_mapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_type_mapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_type_mapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_type_mapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_type_mapPayload>
          }
          findFirst: {
            args: Prisma.job_type_mapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_type_mapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_type_mapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_type_mapPayload>
          }
          findMany: {
            args: Prisma.job_type_mapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_type_mapPayload>[]
          }
          create: {
            args: Prisma.job_type_mapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_type_mapPayload>
          }
          createMany: {
            args: Prisma.job_type_mapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.job_type_mapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_type_mapPayload>[]
          }
          delete: {
            args: Prisma.job_type_mapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_type_mapPayload>
          }
          update: {
            args: Prisma.job_type_mapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_type_mapPayload>
          }
          deleteMany: {
            args: Prisma.job_type_mapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_type_mapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.job_type_mapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_type_mapPayload>[]
          }
          upsert: {
            args: Prisma.job_type_mapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_type_mapPayload>
          }
          aggregate: {
            args: Prisma.Job_type_mapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_type_map>
          }
          groupBy: {
            args: Prisma.job_type_mapGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_type_mapGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_type_mapCountArgs<ExtArgs>
            result: $Utils.Optional<Job_type_mapCountAggregateOutputType> | number
          }
        }
      }
      city: {
        payload: Prisma.$cityPayload<ExtArgs>
        fields: Prisma.cityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload>
          }
          findFirst: {
            args: Prisma.cityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload>
          }
          findMany: {
            args: Prisma.cityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload>[]
          }
          create: {
            args: Prisma.cityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload>
          }
          createMany: {
            args: Prisma.cityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload>[]
          }
          delete: {
            args: Prisma.cityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload>
          }
          update: {
            args: Prisma.cityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload>
          }
          deleteMany: {
            args: Prisma.cityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload>[]
          }
          upsert: {
            args: Prisma.cityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.cityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.cityCountArgs<ExtArgs>
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      country: {
        payload: Prisma.$countryPayload<ExtArgs>
        fields: Prisma.countryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.countryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.countryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload>
          }
          findFirst: {
            args: Prisma.countryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.countryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload>
          }
          findMany: {
            args: Prisma.countryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload>[]
          }
          create: {
            args: Prisma.countryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload>
          }
          createMany: {
            args: Prisma.countryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.countryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload>[]
          }
          delete: {
            args: Prisma.countryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload>
          }
          update: {
            args: Prisma.countryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload>
          }
          deleteMany: {
            args: Prisma.countryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.countryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.countryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload>[]
          }
          upsert: {
            args: Prisma.countryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$countryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.countryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.countryCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      state: {
        payload: Prisma.$statePayload<ExtArgs>
        fields: Prisma.stateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.stateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.stateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload>
          }
          findFirst: {
            args: Prisma.stateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.stateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload>
          }
          findMany: {
            args: Prisma.stateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload>[]
          }
          create: {
            args: Prisma.stateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload>
          }
          createMany: {
            args: Prisma.stateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.stateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload>[]
          }
          delete: {
            args: Prisma.stateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload>
          }
          update: {
            args: Prisma.stateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload>
          }
          deleteMany: {
            args: Prisma.stateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.stateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.stateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload>[]
          }
          upsert: {
            args: Prisma.stateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statePayload>
          }
          aggregate: {
            args: Prisma.StateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateState>
          }
          groupBy: {
            args: Prisma.stateGroupByArgs<ExtArgs>
            result: $Utils.Optional<StateGroupByOutputType>[]
          }
          count: {
            args: Prisma.stateCountArgs<ExtArgs>
            result: $Utils.Optional<StateCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    company?: companyOmit
    company_image?: company_imageOmit
    company_industry?: company_industryOmit
    industry_category?: industry_categoryOmit
    job?: jobOmit
    job_category?: job_categoryOmit
    job_category_map?: job_category_mapOmit
    job_salary?: job_salaryOmit
    job_salary_map?: job_salary_mapOmit
    job_schedule?: job_scheduleOmit
    job_schedule_map?: job_schedule_mapOmit
    job_skill?: job_skillOmit
    job_skill_map?: job_skill_mapOmit
    job_source?: job_sourceOmit
    job_source_map?: job_source_mapOmit
    job_type?: job_typeOmit
    job_type_map?: job_type_mapOmit
    city?: cityOmit
    country?: countryOmit
    state?: stateOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    company_image: number
    company_industry: number
    job: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company_image?: boolean | CompanyCountOutputTypeCountCompany_imageArgs
    company_industry?: boolean | CompanyCountOutputTypeCountCompany_industryArgs
    job?: boolean | CompanyCountOutputTypeCountJobArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCompany_imageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_imageWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCompany_industryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_industryWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobWhereInput
  }


  /**
   * Count Type Industry_categoryCountOutputType
   */

  export type Industry_categoryCountOutputType = {
    company_industry: number
  }

  export type Industry_categoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company_industry?: boolean | Industry_categoryCountOutputTypeCountCompany_industryArgs
  }

  // Custom InputTypes
  /**
   * Industry_categoryCountOutputType without action
   */
  export type Industry_categoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry_categoryCountOutputType
     */
    select?: Industry_categoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Industry_categoryCountOutputType without action
   */
  export type Industry_categoryCountOutputTypeCountCompany_industryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_industryWhereInput
  }


  /**
   * Count Type JobCountOutputType
   */

  export type JobCountOutputType = {
    job_category_map: number
    job_salary_map: number
    job_schedule_map: number
    job_skill_map: number
    job_source_map: number
    job_type_map: number
  }

  export type JobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_category_map?: boolean | JobCountOutputTypeCountJob_category_mapArgs
    job_salary_map?: boolean | JobCountOutputTypeCountJob_salary_mapArgs
    job_schedule_map?: boolean | JobCountOutputTypeCountJob_schedule_mapArgs
    job_skill_map?: boolean | JobCountOutputTypeCountJob_skill_mapArgs
    job_source_map?: boolean | JobCountOutputTypeCountJob_source_mapArgs
    job_type_map?: boolean | JobCountOutputTypeCountJob_type_mapArgs
  }

  // Custom InputTypes
  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCountOutputType
     */
    select?: JobCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountJob_category_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_category_mapWhereInput
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountJob_salary_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_salary_mapWhereInput
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountJob_schedule_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_schedule_mapWhereInput
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountJob_skill_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_skill_mapWhereInput
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountJob_source_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_source_mapWhereInput
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountJob_type_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_type_mapWhereInput
  }


  /**
   * Count Type Job_categoryCountOutputType
   */

  export type Job_categoryCountOutputType = {
    job_category_map: number
  }

  export type Job_categoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_category_map?: boolean | Job_categoryCountOutputTypeCountJob_category_mapArgs
  }

  // Custom InputTypes
  /**
   * Job_categoryCountOutputType without action
   */
  export type Job_categoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job_categoryCountOutputType
     */
    select?: Job_categoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Job_categoryCountOutputType without action
   */
  export type Job_categoryCountOutputTypeCountJob_category_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_category_mapWhereInput
  }


  /**
   * Count Type Job_salaryCountOutputType
   */

  export type Job_salaryCountOutputType = {
    job_salary_map: number
  }

  export type Job_salaryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_salary_map?: boolean | Job_salaryCountOutputTypeCountJob_salary_mapArgs
  }

  // Custom InputTypes
  /**
   * Job_salaryCountOutputType without action
   */
  export type Job_salaryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job_salaryCountOutputType
     */
    select?: Job_salaryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Job_salaryCountOutputType without action
   */
  export type Job_salaryCountOutputTypeCountJob_salary_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_salary_mapWhereInput
  }


  /**
   * Count Type Job_scheduleCountOutputType
   */

  export type Job_scheduleCountOutputType = {
    job_schedule_map: number
  }

  export type Job_scheduleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_schedule_map?: boolean | Job_scheduleCountOutputTypeCountJob_schedule_mapArgs
  }

  // Custom InputTypes
  /**
   * Job_scheduleCountOutputType without action
   */
  export type Job_scheduleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job_scheduleCountOutputType
     */
    select?: Job_scheduleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Job_scheduleCountOutputType without action
   */
  export type Job_scheduleCountOutputTypeCountJob_schedule_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_schedule_mapWhereInput
  }


  /**
   * Count Type Job_skillCountOutputType
   */

  export type Job_skillCountOutputType = {
    job_skill_map: number
  }

  export type Job_skillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_skill_map?: boolean | Job_skillCountOutputTypeCountJob_skill_mapArgs
  }

  // Custom InputTypes
  /**
   * Job_skillCountOutputType without action
   */
  export type Job_skillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job_skillCountOutputType
     */
    select?: Job_skillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Job_skillCountOutputType without action
   */
  export type Job_skillCountOutputTypeCountJob_skill_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_skill_mapWhereInput
  }


  /**
   * Count Type Job_sourceCountOutputType
   */

  export type Job_sourceCountOutputType = {
    job_source_map: number
  }

  export type Job_sourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_source_map?: boolean | Job_sourceCountOutputTypeCountJob_source_mapArgs
  }

  // Custom InputTypes
  /**
   * Job_sourceCountOutputType without action
   */
  export type Job_sourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job_sourceCountOutputType
     */
    select?: Job_sourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Job_sourceCountOutputType without action
   */
  export type Job_sourceCountOutputTypeCountJob_source_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_source_mapWhereInput
  }


  /**
   * Count Type Job_typeCountOutputType
   */

  export type Job_typeCountOutputType = {
    job_type_map: number
  }

  export type Job_typeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_type_map?: boolean | Job_typeCountOutputTypeCountJob_type_mapArgs
  }

  // Custom InputTypes
  /**
   * Job_typeCountOutputType without action
   */
  export type Job_typeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job_typeCountOutputType
     */
    select?: Job_typeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Job_typeCountOutputType without action
   */
  export type Job_typeCountOutputTypeCountJob_type_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_type_mapWhereInput
  }


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    company: number
    job: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CityCountOutputTypeCountCompanyArgs
    job?: boolean | CityCountOutputTypeCountJobArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobWhereInput
  }


  /**
   * Count Type CountryCountOutputType
   */

  export type CountryCountOutputType = {
    company: number
    job: number
    state: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CountryCountOutputTypeCountCompanyArgs
    job?: boolean | CountryCountOutputTypeCountJobArgs
    state?: boolean | CountryCountOutputTypeCountStateArgs
  }

  // Custom InputTypes
  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountStateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: stateWhereInput
  }


  /**
   * Count Type StateCountOutputType
   */

  export type StateCountOutputType = {
    company: number
    job: number
    city: number
  }

  export type StateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | StateCountOutputTypeCountCompanyArgs
    job?: boolean | StateCountOutputTypeCountJobArgs
    city?: boolean | StateCountOutputTypeCountCityArgs
  }

  // Custom InputTypes
  /**
   * StateCountOutputType without action
   */
  export type StateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateCountOutputType
     */
    select?: StateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StateCountOutputType without action
   */
  export type StateCountOutputTypeCountCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyWhereInput
  }

  /**
   * StateCountOutputType without action
   */
  export type StateCountOutputTypeCountJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobWhereInput
  }

  /**
   * StateCountOutputType without action
   */
  export type StateCountOutputTypeCountCityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cityWhereInput
  }


  /**
   * Models
   */

  /**
   * Model company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    company_id: number | null
    company_country_id: number | null
    company_state_id: number | null
    company_city_id: number | null
  }

  export type CompanySumAggregateOutputType = {
    company_id: number | null
    company_country_id: number | null
    company_state_id: number | null
    company_city_id: number | null
  }

  export type CompanyMinAggregateOutputType = {
    company_id: number | null
    company_uuid: string | null
    company_name: string | null
    company_description: string | null
    company_website: string | null
    establishment_date: Date | null
    company_size: $Enums.companySizes | null
    is_active: boolean | null
    company_email: string | null
    phone_number: string | null
    company_country_id: number | null
    company_state_id: number | null
    company_city_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    company_id: number | null
    company_uuid: string | null
    company_name: string | null
    company_description: string | null
    company_website: string | null
    establishment_date: Date | null
    company_size: $Enums.companySizes | null
    is_active: boolean | null
    company_email: string | null
    phone_number: string | null
    company_country_id: number | null
    company_state_id: number | null
    company_city_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    company_id: number
    company_uuid: number
    company_name: number
    company_description: number
    company_website: number
    establishment_date: number
    company_size: number
    is_active: number
    company_email: number
    phone_number: number
    company_country_id: number
    company_state_id: number
    company_city_id: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    company_id?: true
    company_country_id?: true
    company_state_id?: true
    company_city_id?: true
  }

  export type CompanySumAggregateInputType = {
    company_id?: true
    company_country_id?: true
    company_state_id?: true
    company_city_id?: true
  }

  export type CompanyMinAggregateInputType = {
    company_id?: true
    company_uuid?: true
    company_name?: true
    company_description?: true
    company_website?: true
    establishment_date?: true
    company_size?: true
    is_active?: true
    company_email?: true
    phone_number?: true
    company_country_id?: true
    company_state_id?: true
    company_city_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type CompanyMaxAggregateInputType = {
    company_id?: true
    company_uuid?: true
    company_name?: true
    company_description?: true
    company_website?: true
    establishment_date?: true
    company_size?: true
    is_active?: true
    company_email?: true
    phone_number?: true
    company_country_id?: true
    company_state_id?: true
    company_city_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type CompanyCountAggregateInputType = {
    company_id?: true
    company_uuid?: true
    company_name?: true
    company_description?: true
    company_website?: true
    establishment_date?: true
    company_size?: true
    is_active?: true
    company_email?: true
    phone_number?: true
    company_country_id?: true
    company_state_id?: true
    company_city_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company to aggregate.
     */
    where?: companyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companyOrderByWithRelationInput | companyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type companyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyWhereInput
    orderBy?: companyOrderByWithAggregationInput | companyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: companyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    company_id: number
    company_uuid: string
    company_name: string
    company_description: string | null
    company_website: string | null
    establishment_date: Date | null
    company_size: $Enums.companySizes | null
    is_active: boolean
    company_email: string | null
    phone_number: string | null
    company_country_id: number
    company_state_id: number
    company_city_id: number
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends companyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type companySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    company_id?: boolean
    company_uuid?: boolean
    company_name?: boolean
    company_description?: boolean
    company_website?: boolean
    establishment_date?: boolean
    company_size?: boolean
    is_active?: boolean
    company_email?: boolean
    phone_number?: boolean
    company_country_id?: boolean
    company_state_id?: boolean
    company_city_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    city?: boolean | cityDefaultArgs<ExtArgs>
    country?: boolean | countryDefaultArgs<ExtArgs>
    state?: boolean | stateDefaultArgs<ExtArgs>
    company_image?: boolean | company$company_imageArgs<ExtArgs>
    company_industry?: boolean | company$company_industryArgs<ExtArgs>
    job?: boolean | company$jobArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type companySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    company_id?: boolean
    company_uuid?: boolean
    company_name?: boolean
    company_description?: boolean
    company_website?: boolean
    establishment_date?: boolean
    company_size?: boolean
    is_active?: boolean
    company_email?: boolean
    phone_number?: boolean
    company_country_id?: boolean
    company_state_id?: boolean
    company_city_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    city?: boolean | cityDefaultArgs<ExtArgs>
    country?: boolean | countryDefaultArgs<ExtArgs>
    state?: boolean | stateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type companySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    company_id?: boolean
    company_uuid?: boolean
    company_name?: boolean
    company_description?: boolean
    company_website?: boolean
    establishment_date?: boolean
    company_size?: boolean
    is_active?: boolean
    company_email?: boolean
    phone_number?: boolean
    company_country_id?: boolean
    company_state_id?: boolean
    company_city_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    city?: boolean | cityDefaultArgs<ExtArgs>
    country?: boolean | countryDefaultArgs<ExtArgs>
    state?: boolean | stateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type companySelectScalar = {
    company_id?: boolean
    company_uuid?: boolean
    company_name?: boolean
    company_description?: boolean
    company_website?: boolean
    establishment_date?: boolean
    company_size?: boolean
    is_active?: boolean
    company_email?: boolean
    phone_number?: boolean
    company_country_id?: boolean
    company_state_id?: boolean
    company_city_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type companyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"company_id" | "company_uuid" | "company_name" | "company_description" | "company_website" | "establishment_date" | "company_size" | "is_active" | "company_email" | "phone_number" | "company_country_id" | "company_state_id" | "company_city_id" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["company"]>
  export type companyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | cityDefaultArgs<ExtArgs>
    country?: boolean | countryDefaultArgs<ExtArgs>
    state?: boolean | stateDefaultArgs<ExtArgs>
    company_image?: boolean | company$company_imageArgs<ExtArgs>
    company_industry?: boolean | company$company_industryArgs<ExtArgs>
    job?: boolean | company$jobArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type companyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | cityDefaultArgs<ExtArgs>
    country?: boolean | countryDefaultArgs<ExtArgs>
    state?: boolean | stateDefaultArgs<ExtArgs>
  }
  export type companyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | cityDefaultArgs<ExtArgs>
    country?: boolean | countryDefaultArgs<ExtArgs>
    state?: boolean | stateDefaultArgs<ExtArgs>
  }

  export type $companyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company"
    objects: {
      city: Prisma.$cityPayload<ExtArgs>
      country: Prisma.$countryPayload<ExtArgs>
      state: Prisma.$statePayload<ExtArgs>
      company_image: Prisma.$company_imagePayload<ExtArgs>[]
      company_industry: Prisma.$company_industryPayload<ExtArgs>[]
      job: Prisma.$jobPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      company_id: number
      company_uuid: string
      company_name: string
      company_description: string | null
      company_website: string | null
      establishment_date: Date | null
      company_size: $Enums.companySizes | null
      is_active: boolean
      company_email: string | null
      phone_number: string | null
      company_country_id: number
      company_state_id: number
      company_city_id: number
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type companyGetPayload<S extends boolean | null | undefined | companyDefaultArgs> = $Result.GetResult<Prisma.$companyPayload, S>

  type companyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface companyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company'], meta: { name: 'company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {companyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companyFindUniqueArgs>(args: SelectSubset<T, companyFindUniqueArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companyFindUniqueOrThrowArgs>(args: SelectSubset<T, companyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companyFindFirstArgs>(args?: SelectSubset<T, companyFindFirstArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companyFindFirstOrThrowArgs>(args?: SelectSubset<T, companyFindFirstOrThrowArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `company_id`
     * const companyWithCompany_idOnly = await prisma.company.findMany({ select: { company_id: true } })
     * 
     */
    findMany<T extends companyFindManyArgs>(args?: SelectSubset<T, companyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {companyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends companyCreateArgs>(args: SelectSubset<T, companyCreateArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {companyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companyCreateManyArgs>(args?: SelectSubset<T, companyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {companyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `company_id`
     * const companyWithCompany_idOnly = await prisma.company.createManyAndReturn({
     *   select: { company_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends companyCreateManyAndReturnArgs>(args?: SelectSubset<T, companyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {companyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends companyDeleteArgs>(args: SelectSubset<T, companyDeleteArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {companyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companyUpdateArgs>(args: SelectSubset<T, companyUpdateArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {companyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companyDeleteManyArgs>(args?: SelectSubset<T, companyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companyUpdateManyArgs>(args: SelectSubset<T, companyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {companyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `company_id`
     * const companyWithCompany_idOnly = await prisma.company.updateManyAndReturn({
     *   select: { company_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends companyUpdateManyAndReturnArgs>(args: SelectSubset<T, companyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {companyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends companyUpsertArgs>(args: SelectSubset<T, companyUpsertArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends companyCountArgs>(
      args?: Subset<T, companyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companyGroupByArgs['orderBy'] }
        : { orderBy?: companyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company model
   */
  readonly fields: companyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends cityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cityDefaultArgs<ExtArgs>>): Prisma__cityClient<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    country<T extends countryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, countryDefaultArgs<ExtArgs>>): Prisma__countryClient<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    state<T extends stateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, stateDefaultArgs<ExtArgs>>): Prisma__stateClient<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company_image<T extends company$company_imageArgs<ExtArgs> = {}>(args?: Subset<T, company$company_imageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_imagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company_industry<T extends company$company_industryArgs<ExtArgs> = {}>(args?: Subset<T, company$company_industryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_industryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    job<T extends company$jobArgs<ExtArgs> = {}>(args?: Subset<T, company$jobArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the company model
   */
  interface companyFieldRefs {
    readonly company_id: FieldRef<"company", 'Int'>
    readonly company_uuid: FieldRef<"company", 'String'>
    readonly company_name: FieldRef<"company", 'String'>
    readonly company_description: FieldRef<"company", 'String'>
    readonly company_website: FieldRef<"company", 'String'>
    readonly establishment_date: FieldRef<"company", 'DateTime'>
    readonly company_size: FieldRef<"company", 'companySizes'>
    readonly is_active: FieldRef<"company", 'Boolean'>
    readonly company_email: FieldRef<"company", 'String'>
    readonly phone_number: FieldRef<"company", 'String'>
    readonly company_country_id: FieldRef<"company", 'Int'>
    readonly company_state_id: FieldRef<"company", 'Int'>
    readonly company_city_id: FieldRef<"company", 'Int'>
    readonly created_at: FieldRef<"company", 'DateTime'>
    readonly updated_at: FieldRef<"company", 'DateTime'>
    readonly deleted_at: FieldRef<"company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * company findUnique
   */
  export type companyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company
     */
    omit?: companyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * Filter, which company to fetch.
     */
    where: companyWhereUniqueInput
  }

  /**
   * company findUniqueOrThrow
   */
  export type companyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company
     */
    omit?: companyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * Filter, which company to fetch.
     */
    where: companyWhereUniqueInput
  }

  /**
   * company findFirst
   */
  export type companyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company
     */
    omit?: companyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * Filter, which company to fetch.
     */
    where?: companyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companyOrderByWithRelationInput | companyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * company findFirstOrThrow
   */
  export type companyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company
     */
    omit?: companyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * Filter, which company to fetch.
     */
    where?: companyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companyOrderByWithRelationInput | companyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * company findMany
   */
  export type companyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company
     */
    omit?: companyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companyOrderByWithRelationInput | companyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companies.
     */
    cursor?: companyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * company create
   */
  export type companyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company
     */
    omit?: companyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * The data needed to create a company.
     */
    data: XOR<companyCreateInput, companyUncheckedCreateInput>
  }

  /**
   * company createMany
   */
  export type companyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companies.
     */
    data: companyCreateManyInput | companyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company createManyAndReturn
   */
  export type companyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company
     */
    omit?: companyOmit<ExtArgs> | null
    /**
     * The data used to create many companies.
     */
    data: companyCreateManyInput | companyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * company update
   */
  export type companyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company
     */
    omit?: companyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * The data needed to update a company.
     */
    data: XOR<companyUpdateInput, companyUncheckedUpdateInput>
    /**
     * Choose, which company to update.
     */
    where: companyWhereUniqueInput
  }

  /**
   * company updateMany
   */
  export type companyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companies.
     */
    data: XOR<companyUpdateManyMutationInput, companyUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companyWhereInput
    /**
     * Limit how many companies to update.
     */
    limit?: number
  }

  /**
   * company updateManyAndReturn
   */
  export type companyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company
     */
    omit?: companyOmit<ExtArgs> | null
    /**
     * The data used to update companies.
     */
    data: XOR<companyUpdateManyMutationInput, companyUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companyWhereInput
    /**
     * Limit how many companies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * company upsert
   */
  export type companyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company
     */
    omit?: companyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * The filter to search for the company to update in case it exists.
     */
    where: companyWhereUniqueInput
    /**
     * In case the company found by the `where` argument doesn't exist, create a new company with this data.
     */
    create: XOR<companyCreateInput, companyUncheckedCreateInput>
    /**
     * In case the company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companyUpdateInput, companyUncheckedUpdateInput>
  }

  /**
   * company delete
   */
  export type companyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company
     */
    omit?: companyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * Filter which company to delete.
     */
    where: companyWhereUniqueInput
  }

  /**
   * company deleteMany
   */
  export type companyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to delete
     */
    where?: companyWhereInput
    /**
     * Limit how many companies to delete.
     */
    limit?: number
  }

  /**
   * company.company_image
   */
  export type company$company_imageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_image
     */
    select?: company_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_image
     */
    omit?: company_imageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_imageInclude<ExtArgs> | null
    where?: company_imageWhereInput
    orderBy?: company_imageOrderByWithRelationInput | company_imageOrderByWithRelationInput[]
    cursor?: company_imageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Company_imageScalarFieldEnum | Company_imageScalarFieldEnum[]
  }

  /**
   * company.company_industry
   */
  export type company$company_industryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_industry
     */
    select?: company_industrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_industry
     */
    omit?: company_industryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_industryInclude<ExtArgs> | null
    where?: company_industryWhereInput
    orderBy?: company_industryOrderByWithRelationInput | company_industryOrderByWithRelationInput[]
    cursor?: company_industryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Company_industryScalarFieldEnum | Company_industryScalarFieldEnum[]
  }

  /**
   * company.job
   */
  export type company$jobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    where?: jobWhereInput
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    cursor?: jobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * company without action
   */
  export type companyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company
     */
    omit?: companyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyInclude<ExtArgs> | null
  }


  /**
   * Model company_image
   */

  export type AggregateCompany_image = {
    _count: Company_imageCountAggregateOutputType | null
    _avg: Company_imageAvgAggregateOutputType | null
    _sum: Company_imageSumAggregateOutputType | null
    _min: Company_imageMinAggregateOutputType | null
    _max: Company_imageMaxAggregateOutputType | null
  }

  export type Company_imageAvgAggregateOutputType = {
    company_image_id: number | null
    company_id: number | null
  }

  export type Company_imageSumAggregateOutputType = {
    company_image_id: number | null
    company_id: number | null
  }

  export type Company_imageMinAggregateOutputType = {
    company_image_id: number | null
    company_id: number | null
    company_image: string | null
    is_primary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_imageMaxAggregateOutputType = {
    company_image_id: number | null
    company_id: number | null
    company_image: string | null
    is_primary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_imageCountAggregateOutputType = {
    company_image_id: number
    company_id: number
    company_image: number
    is_primary: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Company_imageAvgAggregateInputType = {
    company_image_id?: true
    company_id?: true
  }

  export type Company_imageSumAggregateInputType = {
    company_image_id?: true
    company_id?: true
  }

  export type Company_imageMinAggregateInputType = {
    company_image_id?: true
    company_id?: true
    company_image?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_imageMaxAggregateInputType = {
    company_image_id?: true
    company_id?: true
    company_image?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_imageCountAggregateInputType = {
    company_image_id?: true
    company_id?: true
    company_image?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Company_imageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_image to aggregate.
     */
    where?: company_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_images to fetch.
     */
    orderBy?: company_imageOrderByWithRelationInput | company_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: company_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_images
    **/
    _count?: true | Company_imageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Company_imageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Company_imageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Company_imageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Company_imageMaxAggregateInputType
  }

  export type GetCompany_imageAggregateType<T extends Company_imageAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany_image]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_image[P]>
      : GetScalarType<T[P], AggregateCompany_image[P]>
  }




  export type company_imageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_imageWhereInput
    orderBy?: company_imageOrderByWithAggregationInput | company_imageOrderByWithAggregationInput[]
    by: Company_imageScalarFieldEnum[] | Company_imageScalarFieldEnum
    having?: company_imageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Company_imageCountAggregateInputType | true
    _avg?: Company_imageAvgAggregateInputType
    _sum?: Company_imageSumAggregateInputType
    _min?: Company_imageMinAggregateInputType
    _max?: Company_imageMaxAggregateInputType
  }

  export type Company_imageGroupByOutputType = {
    company_image_id: number
    company_id: number
    company_image: string | null
    is_primary: boolean
    created_at: Date
    updated_at: Date
    _count: Company_imageCountAggregateOutputType | null
    _avg: Company_imageAvgAggregateOutputType | null
    _sum: Company_imageSumAggregateOutputType | null
    _min: Company_imageMinAggregateOutputType | null
    _max: Company_imageMaxAggregateOutputType | null
  }

  type GetCompany_imageGroupByPayload<T extends company_imageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Company_imageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Company_imageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Company_imageGroupByOutputType[P]>
            : GetScalarType<T[P], Company_imageGroupByOutputType[P]>
        }
      >
    >


  export type company_imageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    company_image_id?: boolean
    company_id?: boolean
    company_image?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
    company?: boolean | companyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_image"]>

  export type company_imageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    company_image_id?: boolean
    company_id?: boolean
    company_image?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
    company?: boolean | companyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_image"]>

  export type company_imageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    company_image_id?: boolean
    company_id?: boolean
    company_image?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
    company?: boolean | companyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_image"]>

  export type company_imageSelectScalar = {
    company_image_id?: boolean
    company_id?: boolean
    company_image?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type company_imageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"company_image_id" | "company_id" | "company_image" | "is_primary" | "created_at" | "updated_at", ExtArgs["result"]["company_image"]>
  export type company_imageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | companyDefaultArgs<ExtArgs>
  }
  export type company_imageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | companyDefaultArgs<ExtArgs>
  }
  export type company_imageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | companyDefaultArgs<ExtArgs>
  }

  export type $company_imagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company_image"
    objects: {
      company: Prisma.$companyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      company_image_id: number
      company_id: number
      company_image: string | null
      is_primary: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["company_image"]>
    composites: {}
  }

  type company_imageGetPayload<S extends boolean | null | undefined | company_imageDefaultArgs> = $Result.GetResult<Prisma.$company_imagePayload, S>

  type company_imageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<company_imageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Company_imageCountAggregateInputType | true
    }

  export interface company_imageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company_image'], meta: { name: 'company_image' } }
    /**
     * Find zero or one Company_image that matches the filter.
     * @param {company_imageFindUniqueArgs} args - Arguments to find a Company_image
     * @example
     * // Get one Company_image
     * const company_image = await prisma.company_image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends company_imageFindUniqueArgs>(args: SelectSubset<T, company_imageFindUniqueArgs<ExtArgs>>): Prisma__company_imageClient<$Result.GetResult<Prisma.$company_imagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company_image that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {company_imageFindUniqueOrThrowArgs} args - Arguments to find a Company_image
     * @example
     * // Get one Company_image
     * const company_image = await prisma.company_image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends company_imageFindUniqueOrThrowArgs>(args: SelectSubset<T, company_imageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__company_imageClient<$Result.GetResult<Prisma.$company_imagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_imageFindFirstArgs} args - Arguments to find a Company_image
     * @example
     * // Get one Company_image
     * const company_image = await prisma.company_image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends company_imageFindFirstArgs>(args?: SelectSubset<T, company_imageFindFirstArgs<ExtArgs>>): Prisma__company_imageClient<$Result.GetResult<Prisma.$company_imagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_imageFindFirstOrThrowArgs} args - Arguments to find a Company_image
     * @example
     * // Get one Company_image
     * const company_image = await prisma.company_image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends company_imageFindFirstOrThrowArgs>(args?: SelectSubset<T, company_imageFindFirstOrThrowArgs<ExtArgs>>): Prisma__company_imageClient<$Result.GetResult<Prisma.$company_imagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Company_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_imageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_images
     * const company_images = await prisma.company_image.findMany()
     * 
     * // Get first 10 Company_images
     * const company_images = await prisma.company_image.findMany({ take: 10 })
     * 
     * // Only select the `company_image_id`
     * const company_imageWithCompany_image_idOnly = await prisma.company_image.findMany({ select: { company_image_id: true } })
     * 
     */
    findMany<T extends company_imageFindManyArgs>(args?: SelectSubset<T, company_imageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_imagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company_image.
     * @param {company_imageCreateArgs} args - Arguments to create a Company_image.
     * @example
     * // Create one Company_image
     * const Company_image = await prisma.company_image.create({
     *   data: {
     *     // ... data to create a Company_image
     *   }
     * })
     * 
     */
    create<T extends company_imageCreateArgs>(args: SelectSubset<T, company_imageCreateArgs<ExtArgs>>): Prisma__company_imageClient<$Result.GetResult<Prisma.$company_imagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Company_images.
     * @param {company_imageCreateManyArgs} args - Arguments to create many Company_images.
     * @example
     * // Create many Company_images
     * const company_image = await prisma.company_image.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends company_imageCreateManyArgs>(args?: SelectSubset<T, company_imageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Company_images and returns the data saved in the database.
     * @param {company_imageCreateManyAndReturnArgs} args - Arguments to create many Company_images.
     * @example
     * // Create many Company_images
     * const company_image = await prisma.company_image.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Company_images and only return the `company_image_id`
     * const company_imageWithCompany_image_idOnly = await prisma.company_image.createManyAndReturn({
     *   select: { company_image_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends company_imageCreateManyAndReturnArgs>(args?: SelectSubset<T, company_imageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_imagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company_image.
     * @param {company_imageDeleteArgs} args - Arguments to delete one Company_image.
     * @example
     * // Delete one Company_image
     * const Company_image = await prisma.company_image.delete({
     *   where: {
     *     // ... filter to delete one Company_image
     *   }
     * })
     * 
     */
    delete<T extends company_imageDeleteArgs>(args: SelectSubset<T, company_imageDeleteArgs<ExtArgs>>): Prisma__company_imageClient<$Result.GetResult<Prisma.$company_imagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company_image.
     * @param {company_imageUpdateArgs} args - Arguments to update one Company_image.
     * @example
     * // Update one Company_image
     * const company_image = await prisma.company_image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends company_imageUpdateArgs>(args: SelectSubset<T, company_imageUpdateArgs<ExtArgs>>): Prisma__company_imageClient<$Result.GetResult<Prisma.$company_imagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Company_images.
     * @param {company_imageDeleteManyArgs} args - Arguments to filter Company_images to delete.
     * @example
     * // Delete a few Company_images
     * const { count } = await prisma.company_image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends company_imageDeleteManyArgs>(args?: SelectSubset<T, company_imageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_imageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_images
     * const company_image = await prisma.company_image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends company_imageUpdateManyArgs>(args: SelectSubset<T, company_imageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_images and returns the data updated in the database.
     * @param {company_imageUpdateManyAndReturnArgs} args - Arguments to update many Company_images.
     * @example
     * // Update many Company_images
     * const company_image = await prisma.company_image.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Company_images and only return the `company_image_id`
     * const company_imageWithCompany_image_idOnly = await prisma.company_image.updateManyAndReturn({
     *   select: { company_image_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends company_imageUpdateManyAndReturnArgs>(args: SelectSubset<T, company_imageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_imagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company_image.
     * @param {company_imageUpsertArgs} args - Arguments to update or create a Company_image.
     * @example
     * // Update or create a Company_image
     * const company_image = await prisma.company_image.upsert({
     *   create: {
     *     // ... data to create a Company_image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_image we want to update
     *   }
     * })
     */
    upsert<T extends company_imageUpsertArgs>(args: SelectSubset<T, company_imageUpsertArgs<ExtArgs>>): Prisma__company_imageClient<$Result.GetResult<Prisma.$company_imagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Company_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_imageCountArgs} args - Arguments to filter Company_images to count.
     * @example
     * // Count the number of Company_images
     * const count = await prisma.company_image.count({
     *   where: {
     *     // ... the filter for the Company_images we want to count
     *   }
     * })
    **/
    count<T extends company_imageCountArgs>(
      args?: Subset<T, company_imageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_imageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Company_imageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_imageAggregateArgs>(args: Subset<T, Company_imageAggregateArgs>): Prisma.PrismaPromise<GetCompany_imageAggregateType<T>>

    /**
     * Group by Company_image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_imageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends company_imageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: company_imageGroupByArgs['orderBy'] }
        : { orderBy?: company_imageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, company_imageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompany_imageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company_image model
   */
  readonly fields: company_imageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company_image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__company_imageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends companyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companyDefaultArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the company_image model
   */
  interface company_imageFieldRefs {
    readonly company_image_id: FieldRef<"company_image", 'Int'>
    readonly company_id: FieldRef<"company_image", 'Int'>
    readonly company_image: FieldRef<"company_image", 'String'>
    readonly is_primary: FieldRef<"company_image", 'Boolean'>
    readonly created_at: FieldRef<"company_image", 'DateTime'>
    readonly updated_at: FieldRef<"company_image", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * company_image findUnique
   */
  export type company_imageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_image
     */
    select?: company_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_image
     */
    omit?: company_imageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_imageInclude<ExtArgs> | null
    /**
     * Filter, which company_image to fetch.
     */
    where: company_imageWhereUniqueInput
  }

  /**
   * company_image findUniqueOrThrow
   */
  export type company_imageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_image
     */
    select?: company_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_image
     */
    omit?: company_imageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_imageInclude<ExtArgs> | null
    /**
     * Filter, which company_image to fetch.
     */
    where: company_imageWhereUniqueInput
  }

  /**
   * company_image findFirst
   */
  export type company_imageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_image
     */
    select?: company_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_image
     */
    omit?: company_imageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_imageInclude<ExtArgs> | null
    /**
     * Filter, which company_image to fetch.
     */
    where?: company_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_images to fetch.
     */
    orderBy?: company_imageOrderByWithRelationInput | company_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_images.
     */
    cursor?: company_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_images.
     */
    distinct?: Company_imageScalarFieldEnum | Company_imageScalarFieldEnum[]
  }

  /**
   * company_image findFirstOrThrow
   */
  export type company_imageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_image
     */
    select?: company_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_image
     */
    omit?: company_imageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_imageInclude<ExtArgs> | null
    /**
     * Filter, which company_image to fetch.
     */
    where?: company_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_images to fetch.
     */
    orderBy?: company_imageOrderByWithRelationInput | company_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_images.
     */
    cursor?: company_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_images.
     */
    distinct?: Company_imageScalarFieldEnum | Company_imageScalarFieldEnum[]
  }

  /**
   * company_image findMany
   */
  export type company_imageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_image
     */
    select?: company_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_image
     */
    omit?: company_imageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_imageInclude<ExtArgs> | null
    /**
     * Filter, which company_images to fetch.
     */
    where?: company_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_images to fetch.
     */
    orderBy?: company_imageOrderByWithRelationInput | company_imageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_images.
     */
    cursor?: company_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_images.
     */
    skip?: number
    distinct?: Company_imageScalarFieldEnum | Company_imageScalarFieldEnum[]
  }

  /**
   * company_image create
   */
  export type company_imageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_image
     */
    select?: company_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_image
     */
    omit?: company_imageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_imageInclude<ExtArgs> | null
    /**
     * The data needed to create a company_image.
     */
    data: XOR<company_imageCreateInput, company_imageUncheckedCreateInput>
  }

  /**
   * company_image createMany
   */
  export type company_imageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many company_images.
     */
    data: company_imageCreateManyInput | company_imageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company_image createManyAndReturn
   */
  export type company_imageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_image
     */
    select?: company_imageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_image
     */
    omit?: company_imageOmit<ExtArgs> | null
    /**
     * The data used to create many company_images.
     */
    data: company_imageCreateManyInput | company_imageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_imageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * company_image update
   */
  export type company_imageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_image
     */
    select?: company_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_image
     */
    omit?: company_imageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_imageInclude<ExtArgs> | null
    /**
     * The data needed to update a company_image.
     */
    data: XOR<company_imageUpdateInput, company_imageUncheckedUpdateInput>
    /**
     * Choose, which company_image to update.
     */
    where: company_imageWhereUniqueInput
  }

  /**
   * company_image updateMany
   */
  export type company_imageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update company_images.
     */
    data: XOR<company_imageUpdateManyMutationInput, company_imageUncheckedUpdateManyInput>
    /**
     * Filter which company_images to update
     */
    where?: company_imageWhereInput
    /**
     * Limit how many company_images to update.
     */
    limit?: number
  }

  /**
   * company_image updateManyAndReturn
   */
  export type company_imageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_image
     */
    select?: company_imageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_image
     */
    omit?: company_imageOmit<ExtArgs> | null
    /**
     * The data used to update company_images.
     */
    data: XOR<company_imageUpdateManyMutationInput, company_imageUncheckedUpdateManyInput>
    /**
     * Filter which company_images to update
     */
    where?: company_imageWhereInput
    /**
     * Limit how many company_images to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_imageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * company_image upsert
   */
  export type company_imageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_image
     */
    select?: company_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_image
     */
    omit?: company_imageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_imageInclude<ExtArgs> | null
    /**
     * The filter to search for the company_image to update in case it exists.
     */
    where: company_imageWhereUniqueInput
    /**
     * In case the company_image found by the `where` argument doesn't exist, create a new company_image with this data.
     */
    create: XOR<company_imageCreateInput, company_imageUncheckedCreateInput>
    /**
     * In case the company_image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<company_imageUpdateInput, company_imageUncheckedUpdateInput>
  }

  /**
   * company_image delete
   */
  export type company_imageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_image
     */
    select?: company_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_image
     */
    omit?: company_imageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_imageInclude<ExtArgs> | null
    /**
     * Filter which company_image to delete.
     */
    where: company_imageWhereUniqueInput
  }

  /**
   * company_image deleteMany
   */
  export type company_imageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_images to delete
     */
    where?: company_imageWhereInput
    /**
     * Limit how many company_images to delete.
     */
    limit?: number
  }

  /**
   * company_image without action
   */
  export type company_imageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_image
     */
    select?: company_imageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_image
     */
    omit?: company_imageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_imageInclude<ExtArgs> | null
  }


  /**
   * Model company_industry
   */

  export type AggregateCompany_industry = {
    _count: Company_industryCountAggregateOutputType | null
    _avg: Company_industryAvgAggregateOutputType | null
    _sum: Company_industrySumAggregateOutputType | null
    _min: Company_industryMinAggregateOutputType | null
    _max: Company_industryMaxAggregateOutputType | null
  }

  export type Company_industryAvgAggregateOutputType = {
    company_industry_id: number | null
    company_id: number | null
    industry_category_id: number | null
  }

  export type Company_industrySumAggregateOutputType = {
    company_industry_id: number | null
    company_id: number | null
    industry_category_id: number | null
  }

  export type Company_industryMinAggregateOutputType = {
    company_industry_id: number | null
    company_industry_uuid: string | null
    company_id: number | null
    industry_category_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_industryMaxAggregateOutputType = {
    company_industry_id: number | null
    company_industry_uuid: string | null
    company_id: number | null
    industry_category_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_industryCountAggregateOutputType = {
    company_industry_id: number
    company_industry_uuid: number
    company_id: number
    industry_category_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Company_industryAvgAggregateInputType = {
    company_industry_id?: true
    company_id?: true
    industry_category_id?: true
  }

  export type Company_industrySumAggregateInputType = {
    company_industry_id?: true
    company_id?: true
    industry_category_id?: true
  }

  export type Company_industryMinAggregateInputType = {
    company_industry_id?: true
    company_industry_uuid?: true
    company_id?: true
    industry_category_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_industryMaxAggregateInputType = {
    company_industry_id?: true
    company_industry_uuid?: true
    company_id?: true
    industry_category_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_industryCountAggregateInputType = {
    company_industry_id?: true
    company_industry_uuid?: true
    company_id?: true
    industry_category_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Company_industryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_industry to aggregate.
     */
    where?: company_industryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_industries to fetch.
     */
    orderBy?: company_industryOrderByWithRelationInput | company_industryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: company_industryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_industries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_industries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_industries
    **/
    _count?: true | Company_industryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Company_industryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Company_industrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Company_industryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Company_industryMaxAggregateInputType
  }

  export type GetCompany_industryAggregateType<T extends Company_industryAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany_industry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_industry[P]>
      : GetScalarType<T[P], AggregateCompany_industry[P]>
  }




  export type company_industryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_industryWhereInput
    orderBy?: company_industryOrderByWithAggregationInput | company_industryOrderByWithAggregationInput[]
    by: Company_industryScalarFieldEnum[] | Company_industryScalarFieldEnum
    having?: company_industryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Company_industryCountAggregateInputType | true
    _avg?: Company_industryAvgAggregateInputType
    _sum?: Company_industrySumAggregateInputType
    _min?: Company_industryMinAggregateInputType
    _max?: Company_industryMaxAggregateInputType
  }

  export type Company_industryGroupByOutputType = {
    company_industry_id: number
    company_industry_uuid: string
    company_id: number
    industry_category_id: number
    created_at: Date
    updated_at: Date
    _count: Company_industryCountAggregateOutputType | null
    _avg: Company_industryAvgAggregateOutputType | null
    _sum: Company_industrySumAggregateOutputType | null
    _min: Company_industryMinAggregateOutputType | null
    _max: Company_industryMaxAggregateOutputType | null
  }

  type GetCompany_industryGroupByPayload<T extends company_industryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Company_industryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Company_industryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Company_industryGroupByOutputType[P]>
            : GetScalarType<T[P], Company_industryGroupByOutputType[P]>
        }
      >
    >


  export type company_industrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    company_industry_id?: boolean
    company_industry_uuid?: boolean
    company_id?: boolean
    industry_category_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    company?: boolean | companyDefaultArgs<ExtArgs>
    industry_category?: boolean | industry_categoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_industry"]>

  export type company_industrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    company_industry_id?: boolean
    company_industry_uuid?: boolean
    company_id?: boolean
    industry_category_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    company?: boolean | companyDefaultArgs<ExtArgs>
    industry_category?: boolean | industry_categoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_industry"]>

  export type company_industrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    company_industry_id?: boolean
    company_industry_uuid?: boolean
    company_id?: boolean
    industry_category_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    company?: boolean | companyDefaultArgs<ExtArgs>
    industry_category?: boolean | industry_categoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_industry"]>

  export type company_industrySelectScalar = {
    company_industry_id?: boolean
    company_industry_uuid?: boolean
    company_id?: boolean
    industry_category_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type company_industryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"company_industry_id" | "company_industry_uuid" | "company_id" | "industry_category_id" | "created_at" | "updated_at", ExtArgs["result"]["company_industry"]>
  export type company_industryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | companyDefaultArgs<ExtArgs>
    industry_category?: boolean | industry_categoryDefaultArgs<ExtArgs>
  }
  export type company_industryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | companyDefaultArgs<ExtArgs>
    industry_category?: boolean | industry_categoryDefaultArgs<ExtArgs>
  }
  export type company_industryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | companyDefaultArgs<ExtArgs>
    industry_category?: boolean | industry_categoryDefaultArgs<ExtArgs>
  }

  export type $company_industryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company_industry"
    objects: {
      company: Prisma.$companyPayload<ExtArgs>
      industry_category: Prisma.$industry_categoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      company_industry_id: number
      company_industry_uuid: string
      company_id: number
      industry_category_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["company_industry"]>
    composites: {}
  }

  type company_industryGetPayload<S extends boolean | null | undefined | company_industryDefaultArgs> = $Result.GetResult<Prisma.$company_industryPayload, S>

  type company_industryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<company_industryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Company_industryCountAggregateInputType | true
    }

  export interface company_industryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company_industry'], meta: { name: 'company_industry' } }
    /**
     * Find zero or one Company_industry that matches the filter.
     * @param {company_industryFindUniqueArgs} args - Arguments to find a Company_industry
     * @example
     * // Get one Company_industry
     * const company_industry = await prisma.company_industry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends company_industryFindUniqueArgs>(args: SelectSubset<T, company_industryFindUniqueArgs<ExtArgs>>): Prisma__company_industryClient<$Result.GetResult<Prisma.$company_industryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company_industry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {company_industryFindUniqueOrThrowArgs} args - Arguments to find a Company_industry
     * @example
     * // Get one Company_industry
     * const company_industry = await prisma.company_industry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends company_industryFindUniqueOrThrowArgs>(args: SelectSubset<T, company_industryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__company_industryClient<$Result.GetResult<Prisma.$company_industryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_industry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_industryFindFirstArgs} args - Arguments to find a Company_industry
     * @example
     * // Get one Company_industry
     * const company_industry = await prisma.company_industry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends company_industryFindFirstArgs>(args?: SelectSubset<T, company_industryFindFirstArgs<ExtArgs>>): Prisma__company_industryClient<$Result.GetResult<Prisma.$company_industryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_industry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_industryFindFirstOrThrowArgs} args - Arguments to find a Company_industry
     * @example
     * // Get one Company_industry
     * const company_industry = await prisma.company_industry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends company_industryFindFirstOrThrowArgs>(args?: SelectSubset<T, company_industryFindFirstOrThrowArgs<ExtArgs>>): Prisma__company_industryClient<$Result.GetResult<Prisma.$company_industryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Company_industries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_industryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_industries
     * const company_industries = await prisma.company_industry.findMany()
     * 
     * // Get first 10 Company_industries
     * const company_industries = await prisma.company_industry.findMany({ take: 10 })
     * 
     * // Only select the `company_industry_id`
     * const company_industryWithCompany_industry_idOnly = await prisma.company_industry.findMany({ select: { company_industry_id: true } })
     * 
     */
    findMany<T extends company_industryFindManyArgs>(args?: SelectSubset<T, company_industryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_industryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company_industry.
     * @param {company_industryCreateArgs} args - Arguments to create a Company_industry.
     * @example
     * // Create one Company_industry
     * const Company_industry = await prisma.company_industry.create({
     *   data: {
     *     // ... data to create a Company_industry
     *   }
     * })
     * 
     */
    create<T extends company_industryCreateArgs>(args: SelectSubset<T, company_industryCreateArgs<ExtArgs>>): Prisma__company_industryClient<$Result.GetResult<Prisma.$company_industryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Company_industries.
     * @param {company_industryCreateManyArgs} args - Arguments to create many Company_industries.
     * @example
     * // Create many Company_industries
     * const company_industry = await prisma.company_industry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends company_industryCreateManyArgs>(args?: SelectSubset<T, company_industryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Company_industries and returns the data saved in the database.
     * @param {company_industryCreateManyAndReturnArgs} args - Arguments to create many Company_industries.
     * @example
     * // Create many Company_industries
     * const company_industry = await prisma.company_industry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Company_industries and only return the `company_industry_id`
     * const company_industryWithCompany_industry_idOnly = await prisma.company_industry.createManyAndReturn({
     *   select: { company_industry_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends company_industryCreateManyAndReturnArgs>(args?: SelectSubset<T, company_industryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_industryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company_industry.
     * @param {company_industryDeleteArgs} args - Arguments to delete one Company_industry.
     * @example
     * // Delete one Company_industry
     * const Company_industry = await prisma.company_industry.delete({
     *   where: {
     *     // ... filter to delete one Company_industry
     *   }
     * })
     * 
     */
    delete<T extends company_industryDeleteArgs>(args: SelectSubset<T, company_industryDeleteArgs<ExtArgs>>): Prisma__company_industryClient<$Result.GetResult<Prisma.$company_industryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company_industry.
     * @param {company_industryUpdateArgs} args - Arguments to update one Company_industry.
     * @example
     * // Update one Company_industry
     * const company_industry = await prisma.company_industry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends company_industryUpdateArgs>(args: SelectSubset<T, company_industryUpdateArgs<ExtArgs>>): Prisma__company_industryClient<$Result.GetResult<Prisma.$company_industryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Company_industries.
     * @param {company_industryDeleteManyArgs} args - Arguments to filter Company_industries to delete.
     * @example
     * // Delete a few Company_industries
     * const { count } = await prisma.company_industry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends company_industryDeleteManyArgs>(args?: SelectSubset<T, company_industryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_industries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_industryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_industries
     * const company_industry = await prisma.company_industry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends company_industryUpdateManyArgs>(args: SelectSubset<T, company_industryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_industries and returns the data updated in the database.
     * @param {company_industryUpdateManyAndReturnArgs} args - Arguments to update many Company_industries.
     * @example
     * // Update many Company_industries
     * const company_industry = await prisma.company_industry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Company_industries and only return the `company_industry_id`
     * const company_industryWithCompany_industry_idOnly = await prisma.company_industry.updateManyAndReturn({
     *   select: { company_industry_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends company_industryUpdateManyAndReturnArgs>(args: SelectSubset<T, company_industryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_industryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company_industry.
     * @param {company_industryUpsertArgs} args - Arguments to update or create a Company_industry.
     * @example
     * // Update or create a Company_industry
     * const company_industry = await prisma.company_industry.upsert({
     *   create: {
     *     // ... data to create a Company_industry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_industry we want to update
     *   }
     * })
     */
    upsert<T extends company_industryUpsertArgs>(args: SelectSubset<T, company_industryUpsertArgs<ExtArgs>>): Prisma__company_industryClient<$Result.GetResult<Prisma.$company_industryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Company_industries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_industryCountArgs} args - Arguments to filter Company_industries to count.
     * @example
     * // Count the number of Company_industries
     * const count = await prisma.company_industry.count({
     *   where: {
     *     // ... the filter for the Company_industries we want to count
     *   }
     * })
    **/
    count<T extends company_industryCountArgs>(
      args?: Subset<T, company_industryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_industryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_industry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Company_industryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_industryAggregateArgs>(args: Subset<T, Company_industryAggregateArgs>): Prisma.PrismaPromise<GetCompany_industryAggregateType<T>>

    /**
     * Group by Company_industry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_industryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends company_industryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: company_industryGroupByArgs['orderBy'] }
        : { orderBy?: company_industryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, company_industryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompany_industryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company_industry model
   */
  readonly fields: company_industryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company_industry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__company_industryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends companyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companyDefaultArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    industry_category<T extends industry_categoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, industry_categoryDefaultArgs<ExtArgs>>): Prisma__industry_categoryClient<$Result.GetResult<Prisma.$industry_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the company_industry model
   */
  interface company_industryFieldRefs {
    readonly company_industry_id: FieldRef<"company_industry", 'Int'>
    readonly company_industry_uuid: FieldRef<"company_industry", 'String'>
    readonly company_id: FieldRef<"company_industry", 'Int'>
    readonly industry_category_id: FieldRef<"company_industry", 'Int'>
    readonly created_at: FieldRef<"company_industry", 'DateTime'>
    readonly updated_at: FieldRef<"company_industry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * company_industry findUnique
   */
  export type company_industryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_industry
     */
    select?: company_industrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_industry
     */
    omit?: company_industryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_industryInclude<ExtArgs> | null
    /**
     * Filter, which company_industry to fetch.
     */
    where: company_industryWhereUniqueInput
  }

  /**
   * company_industry findUniqueOrThrow
   */
  export type company_industryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_industry
     */
    select?: company_industrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_industry
     */
    omit?: company_industryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_industryInclude<ExtArgs> | null
    /**
     * Filter, which company_industry to fetch.
     */
    where: company_industryWhereUniqueInput
  }

  /**
   * company_industry findFirst
   */
  export type company_industryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_industry
     */
    select?: company_industrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_industry
     */
    omit?: company_industryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_industryInclude<ExtArgs> | null
    /**
     * Filter, which company_industry to fetch.
     */
    where?: company_industryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_industries to fetch.
     */
    orderBy?: company_industryOrderByWithRelationInput | company_industryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_industries.
     */
    cursor?: company_industryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_industries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_industries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_industries.
     */
    distinct?: Company_industryScalarFieldEnum | Company_industryScalarFieldEnum[]
  }

  /**
   * company_industry findFirstOrThrow
   */
  export type company_industryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_industry
     */
    select?: company_industrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_industry
     */
    omit?: company_industryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_industryInclude<ExtArgs> | null
    /**
     * Filter, which company_industry to fetch.
     */
    where?: company_industryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_industries to fetch.
     */
    orderBy?: company_industryOrderByWithRelationInput | company_industryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_industries.
     */
    cursor?: company_industryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_industries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_industries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_industries.
     */
    distinct?: Company_industryScalarFieldEnum | Company_industryScalarFieldEnum[]
  }

  /**
   * company_industry findMany
   */
  export type company_industryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_industry
     */
    select?: company_industrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_industry
     */
    omit?: company_industryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_industryInclude<ExtArgs> | null
    /**
     * Filter, which company_industries to fetch.
     */
    where?: company_industryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_industries to fetch.
     */
    orderBy?: company_industryOrderByWithRelationInput | company_industryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_industries.
     */
    cursor?: company_industryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_industries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_industries.
     */
    skip?: number
    distinct?: Company_industryScalarFieldEnum | Company_industryScalarFieldEnum[]
  }

  /**
   * company_industry create
   */
  export type company_industryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_industry
     */
    select?: company_industrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_industry
     */
    omit?: company_industryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_industryInclude<ExtArgs> | null
    /**
     * The data needed to create a company_industry.
     */
    data: XOR<company_industryCreateInput, company_industryUncheckedCreateInput>
  }

  /**
   * company_industry createMany
   */
  export type company_industryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many company_industries.
     */
    data: company_industryCreateManyInput | company_industryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company_industry createManyAndReturn
   */
  export type company_industryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_industry
     */
    select?: company_industrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_industry
     */
    omit?: company_industryOmit<ExtArgs> | null
    /**
     * The data used to create many company_industries.
     */
    data: company_industryCreateManyInput | company_industryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_industryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * company_industry update
   */
  export type company_industryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_industry
     */
    select?: company_industrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_industry
     */
    omit?: company_industryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_industryInclude<ExtArgs> | null
    /**
     * The data needed to update a company_industry.
     */
    data: XOR<company_industryUpdateInput, company_industryUncheckedUpdateInput>
    /**
     * Choose, which company_industry to update.
     */
    where: company_industryWhereUniqueInput
  }

  /**
   * company_industry updateMany
   */
  export type company_industryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update company_industries.
     */
    data: XOR<company_industryUpdateManyMutationInput, company_industryUncheckedUpdateManyInput>
    /**
     * Filter which company_industries to update
     */
    where?: company_industryWhereInput
    /**
     * Limit how many company_industries to update.
     */
    limit?: number
  }

  /**
   * company_industry updateManyAndReturn
   */
  export type company_industryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_industry
     */
    select?: company_industrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the company_industry
     */
    omit?: company_industryOmit<ExtArgs> | null
    /**
     * The data used to update company_industries.
     */
    data: XOR<company_industryUpdateManyMutationInput, company_industryUncheckedUpdateManyInput>
    /**
     * Filter which company_industries to update
     */
    where?: company_industryWhereInput
    /**
     * Limit how many company_industries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_industryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * company_industry upsert
   */
  export type company_industryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_industry
     */
    select?: company_industrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_industry
     */
    omit?: company_industryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_industryInclude<ExtArgs> | null
    /**
     * The filter to search for the company_industry to update in case it exists.
     */
    where: company_industryWhereUniqueInput
    /**
     * In case the company_industry found by the `where` argument doesn't exist, create a new company_industry with this data.
     */
    create: XOR<company_industryCreateInput, company_industryUncheckedCreateInput>
    /**
     * In case the company_industry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<company_industryUpdateInput, company_industryUncheckedUpdateInput>
  }

  /**
   * company_industry delete
   */
  export type company_industryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_industry
     */
    select?: company_industrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_industry
     */
    omit?: company_industryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_industryInclude<ExtArgs> | null
    /**
     * Filter which company_industry to delete.
     */
    where: company_industryWhereUniqueInput
  }

  /**
   * company_industry deleteMany
   */
  export type company_industryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_industries to delete
     */
    where?: company_industryWhereInput
    /**
     * Limit how many company_industries to delete.
     */
    limit?: number
  }

  /**
   * company_industry without action
   */
  export type company_industryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_industry
     */
    select?: company_industrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_industry
     */
    omit?: company_industryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_industryInclude<ExtArgs> | null
  }


  /**
   * Model industry_category
   */

  export type AggregateIndustry_category = {
    _count: Industry_categoryCountAggregateOutputType | null
    _avg: Industry_categoryAvgAggregateOutputType | null
    _sum: Industry_categorySumAggregateOutputType | null
    _min: Industry_categoryMinAggregateOutputType | null
    _max: Industry_categoryMaxAggregateOutputType | null
  }

  export type Industry_categoryAvgAggregateOutputType = {
    industry_category_id: number | null
  }

  export type Industry_categorySumAggregateOutputType = {
    industry_category_id: number | null
  }

  export type Industry_categoryMinAggregateOutputType = {
    industry_category_id: number | null
    industry_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Industry_categoryMaxAggregateOutputType = {
    industry_category_id: number | null
    industry_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Industry_categoryCountAggregateOutputType = {
    industry_category_id: number
    industry_name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Industry_categoryAvgAggregateInputType = {
    industry_category_id?: true
  }

  export type Industry_categorySumAggregateInputType = {
    industry_category_id?: true
  }

  export type Industry_categoryMinAggregateInputType = {
    industry_category_id?: true
    industry_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Industry_categoryMaxAggregateInputType = {
    industry_category_id?: true
    industry_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Industry_categoryCountAggregateInputType = {
    industry_category_id?: true
    industry_name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Industry_categoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which industry_category to aggregate.
     */
    where?: industry_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of industry_categories to fetch.
     */
    orderBy?: industry_categoryOrderByWithRelationInput | industry_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: industry_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` industry_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` industry_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned industry_categories
    **/
    _count?: true | Industry_categoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Industry_categoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Industry_categorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Industry_categoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Industry_categoryMaxAggregateInputType
  }

  export type GetIndustry_categoryAggregateType<T extends Industry_categoryAggregateArgs> = {
        [P in keyof T & keyof AggregateIndustry_category]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndustry_category[P]>
      : GetScalarType<T[P], AggregateIndustry_category[P]>
  }




  export type industry_categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: industry_categoryWhereInput
    orderBy?: industry_categoryOrderByWithAggregationInput | industry_categoryOrderByWithAggregationInput[]
    by: Industry_categoryScalarFieldEnum[] | Industry_categoryScalarFieldEnum
    having?: industry_categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Industry_categoryCountAggregateInputType | true
    _avg?: Industry_categoryAvgAggregateInputType
    _sum?: Industry_categorySumAggregateInputType
    _min?: Industry_categoryMinAggregateInputType
    _max?: Industry_categoryMaxAggregateInputType
  }

  export type Industry_categoryGroupByOutputType = {
    industry_category_id: number
    industry_name: string
    created_at: Date
    updated_at: Date
    _count: Industry_categoryCountAggregateOutputType | null
    _avg: Industry_categoryAvgAggregateOutputType | null
    _sum: Industry_categorySumAggregateOutputType | null
    _min: Industry_categoryMinAggregateOutputType | null
    _max: Industry_categoryMaxAggregateOutputType | null
  }

  type GetIndustry_categoryGroupByPayload<T extends industry_categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Industry_categoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Industry_categoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Industry_categoryGroupByOutputType[P]>
            : GetScalarType<T[P], Industry_categoryGroupByOutputType[P]>
        }
      >
    >


  export type industry_categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    industry_category_id?: boolean
    industry_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    company_industry?: boolean | industry_category$company_industryArgs<ExtArgs>
    _count?: boolean | Industry_categoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["industry_category"]>

  export type industry_categorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    industry_category_id?: boolean
    industry_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["industry_category"]>

  export type industry_categorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    industry_category_id?: boolean
    industry_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["industry_category"]>

  export type industry_categorySelectScalar = {
    industry_category_id?: boolean
    industry_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type industry_categoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"industry_category_id" | "industry_name" | "created_at" | "updated_at", ExtArgs["result"]["industry_category"]>
  export type industry_categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company_industry?: boolean | industry_category$company_industryArgs<ExtArgs>
    _count?: boolean | Industry_categoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type industry_categoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type industry_categoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $industry_categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "industry_category"
    objects: {
      company_industry: Prisma.$company_industryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      industry_category_id: number
      industry_name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["industry_category"]>
    composites: {}
  }

  type industry_categoryGetPayload<S extends boolean | null | undefined | industry_categoryDefaultArgs> = $Result.GetResult<Prisma.$industry_categoryPayload, S>

  type industry_categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<industry_categoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Industry_categoryCountAggregateInputType | true
    }

  export interface industry_categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['industry_category'], meta: { name: 'industry_category' } }
    /**
     * Find zero or one Industry_category that matches the filter.
     * @param {industry_categoryFindUniqueArgs} args - Arguments to find a Industry_category
     * @example
     * // Get one Industry_category
     * const industry_category = await prisma.industry_category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends industry_categoryFindUniqueArgs>(args: SelectSubset<T, industry_categoryFindUniqueArgs<ExtArgs>>): Prisma__industry_categoryClient<$Result.GetResult<Prisma.$industry_categoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Industry_category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {industry_categoryFindUniqueOrThrowArgs} args - Arguments to find a Industry_category
     * @example
     * // Get one Industry_category
     * const industry_category = await prisma.industry_category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends industry_categoryFindUniqueOrThrowArgs>(args: SelectSubset<T, industry_categoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__industry_categoryClient<$Result.GetResult<Prisma.$industry_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Industry_category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industry_categoryFindFirstArgs} args - Arguments to find a Industry_category
     * @example
     * // Get one Industry_category
     * const industry_category = await prisma.industry_category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends industry_categoryFindFirstArgs>(args?: SelectSubset<T, industry_categoryFindFirstArgs<ExtArgs>>): Prisma__industry_categoryClient<$Result.GetResult<Prisma.$industry_categoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Industry_category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industry_categoryFindFirstOrThrowArgs} args - Arguments to find a Industry_category
     * @example
     * // Get one Industry_category
     * const industry_category = await prisma.industry_category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends industry_categoryFindFirstOrThrowArgs>(args?: SelectSubset<T, industry_categoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__industry_categoryClient<$Result.GetResult<Prisma.$industry_categoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Industry_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industry_categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Industry_categories
     * const industry_categories = await prisma.industry_category.findMany()
     * 
     * // Get first 10 Industry_categories
     * const industry_categories = await prisma.industry_category.findMany({ take: 10 })
     * 
     * // Only select the `industry_category_id`
     * const industry_categoryWithIndustry_category_idOnly = await prisma.industry_category.findMany({ select: { industry_category_id: true } })
     * 
     */
    findMany<T extends industry_categoryFindManyArgs>(args?: SelectSubset<T, industry_categoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$industry_categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Industry_category.
     * @param {industry_categoryCreateArgs} args - Arguments to create a Industry_category.
     * @example
     * // Create one Industry_category
     * const Industry_category = await prisma.industry_category.create({
     *   data: {
     *     // ... data to create a Industry_category
     *   }
     * })
     * 
     */
    create<T extends industry_categoryCreateArgs>(args: SelectSubset<T, industry_categoryCreateArgs<ExtArgs>>): Prisma__industry_categoryClient<$Result.GetResult<Prisma.$industry_categoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Industry_categories.
     * @param {industry_categoryCreateManyArgs} args - Arguments to create many Industry_categories.
     * @example
     * // Create many Industry_categories
     * const industry_category = await prisma.industry_category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends industry_categoryCreateManyArgs>(args?: SelectSubset<T, industry_categoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Industry_categories and returns the data saved in the database.
     * @param {industry_categoryCreateManyAndReturnArgs} args - Arguments to create many Industry_categories.
     * @example
     * // Create many Industry_categories
     * const industry_category = await prisma.industry_category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Industry_categories and only return the `industry_category_id`
     * const industry_categoryWithIndustry_category_idOnly = await prisma.industry_category.createManyAndReturn({
     *   select: { industry_category_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends industry_categoryCreateManyAndReturnArgs>(args?: SelectSubset<T, industry_categoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$industry_categoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Industry_category.
     * @param {industry_categoryDeleteArgs} args - Arguments to delete one Industry_category.
     * @example
     * // Delete one Industry_category
     * const Industry_category = await prisma.industry_category.delete({
     *   where: {
     *     // ... filter to delete one Industry_category
     *   }
     * })
     * 
     */
    delete<T extends industry_categoryDeleteArgs>(args: SelectSubset<T, industry_categoryDeleteArgs<ExtArgs>>): Prisma__industry_categoryClient<$Result.GetResult<Prisma.$industry_categoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Industry_category.
     * @param {industry_categoryUpdateArgs} args - Arguments to update one Industry_category.
     * @example
     * // Update one Industry_category
     * const industry_category = await prisma.industry_category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends industry_categoryUpdateArgs>(args: SelectSubset<T, industry_categoryUpdateArgs<ExtArgs>>): Prisma__industry_categoryClient<$Result.GetResult<Prisma.$industry_categoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Industry_categories.
     * @param {industry_categoryDeleteManyArgs} args - Arguments to filter Industry_categories to delete.
     * @example
     * // Delete a few Industry_categories
     * const { count } = await prisma.industry_category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends industry_categoryDeleteManyArgs>(args?: SelectSubset<T, industry_categoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Industry_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industry_categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Industry_categories
     * const industry_category = await prisma.industry_category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends industry_categoryUpdateManyArgs>(args: SelectSubset<T, industry_categoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Industry_categories and returns the data updated in the database.
     * @param {industry_categoryUpdateManyAndReturnArgs} args - Arguments to update many Industry_categories.
     * @example
     * // Update many Industry_categories
     * const industry_category = await prisma.industry_category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Industry_categories and only return the `industry_category_id`
     * const industry_categoryWithIndustry_category_idOnly = await prisma.industry_category.updateManyAndReturn({
     *   select: { industry_category_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends industry_categoryUpdateManyAndReturnArgs>(args: SelectSubset<T, industry_categoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$industry_categoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Industry_category.
     * @param {industry_categoryUpsertArgs} args - Arguments to update or create a Industry_category.
     * @example
     * // Update or create a Industry_category
     * const industry_category = await prisma.industry_category.upsert({
     *   create: {
     *     // ... data to create a Industry_category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Industry_category we want to update
     *   }
     * })
     */
    upsert<T extends industry_categoryUpsertArgs>(args: SelectSubset<T, industry_categoryUpsertArgs<ExtArgs>>): Prisma__industry_categoryClient<$Result.GetResult<Prisma.$industry_categoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Industry_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industry_categoryCountArgs} args - Arguments to filter Industry_categories to count.
     * @example
     * // Count the number of Industry_categories
     * const count = await prisma.industry_category.count({
     *   where: {
     *     // ... the filter for the Industry_categories we want to count
     *   }
     * })
    **/
    count<T extends industry_categoryCountArgs>(
      args?: Subset<T, industry_categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Industry_categoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Industry_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Industry_categoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Industry_categoryAggregateArgs>(args: Subset<T, Industry_categoryAggregateArgs>): Prisma.PrismaPromise<GetIndustry_categoryAggregateType<T>>

    /**
     * Group by Industry_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {industry_categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends industry_categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: industry_categoryGroupByArgs['orderBy'] }
        : { orderBy?: industry_categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, industry_categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndustry_categoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the industry_category model
   */
  readonly fields: industry_categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for industry_category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__industry_categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company_industry<T extends industry_category$company_industryArgs<ExtArgs> = {}>(args?: Subset<T, industry_category$company_industryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_industryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the industry_category model
   */
  interface industry_categoryFieldRefs {
    readonly industry_category_id: FieldRef<"industry_category", 'Int'>
    readonly industry_name: FieldRef<"industry_category", 'String'>
    readonly created_at: FieldRef<"industry_category", 'DateTime'>
    readonly updated_at: FieldRef<"industry_category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * industry_category findUnique
   */
  export type industry_categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industry_category
     */
    select?: industry_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the industry_category
     */
    omit?: industry_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: industry_categoryInclude<ExtArgs> | null
    /**
     * Filter, which industry_category to fetch.
     */
    where: industry_categoryWhereUniqueInput
  }

  /**
   * industry_category findUniqueOrThrow
   */
  export type industry_categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industry_category
     */
    select?: industry_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the industry_category
     */
    omit?: industry_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: industry_categoryInclude<ExtArgs> | null
    /**
     * Filter, which industry_category to fetch.
     */
    where: industry_categoryWhereUniqueInput
  }

  /**
   * industry_category findFirst
   */
  export type industry_categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industry_category
     */
    select?: industry_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the industry_category
     */
    omit?: industry_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: industry_categoryInclude<ExtArgs> | null
    /**
     * Filter, which industry_category to fetch.
     */
    where?: industry_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of industry_categories to fetch.
     */
    orderBy?: industry_categoryOrderByWithRelationInput | industry_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for industry_categories.
     */
    cursor?: industry_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` industry_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` industry_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of industry_categories.
     */
    distinct?: Industry_categoryScalarFieldEnum | Industry_categoryScalarFieldEnum[]
  }

  /**
   * industry_category findFirstOrThrow
   */
  export type industry_categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industry_category
     */
    select?: industry_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the industry_category
     */
    omit?: industry_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: industry_categoryInclude<ExtArgs> | null
    /**
     * Filter, which industry_category to fetch.
     */
    where?: industry_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of industry_categories to fetch.
     */
    orderBy?: industry_categoryOrderByWithRelationInput | industry_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for industry_categories.
     */
    cursor?: industry_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` industry_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` industry_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of industry_categories.
     */
    distinct?: Industry_categoryScalarFieldEnum | Industry_categoryScalarFieldEnum[]
  }

  /**
   * industry_category findMany
   */
  export type industry_categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industry_category
     */
    select?: industry_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the industry_category
     */
    omit?: industry_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: industry_categoryInclude<ExtArgs> | null
    /**
     * Filter, which industry_categories to fetch.
     */
    where?: industry_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of industry_categories to fetch.
     */
    orderBy?: industry_categoryOrderByWithRelationInput | industry_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing industry_categories.
     */
    cursor?: industry_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` industry_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` industry_categories.
     */
    skip?: number
    distinct?: Industry_categoryScalarFieldEnum | Industry_categoryScalarFieldEnum[]
  }

  /**
   * industry_category create
   */
  export type industry_categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industry_category
     */
    select?: industry_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the industry_category
     */
    omit?: industry_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: industry_categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a industry_category.
     */
    data: XOR<industry_categoryCreateInput, industry_categoryUncheckedCreateInput>
  }

  /**
   * industry_category createMany
   */
  export type industry_categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many industry_categories.
     */
    data: industry_categoryCreateManyInput | industry_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * industry_category createManyAndReturn
   */
  export type industry_categoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industry_category
     */
    select?: industry_categorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the industry_category
     */
    omit?: industry_categoryOmit<ExtArgs> | null
    /**
     * The data used to create many industry_categories.
     */
    data: industry_categoryCreateManyInput | industry_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * industry_category update
   */
  export type industry_categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industry_category
     */
    select?: industry_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the industry_category
     */
    omit?: industry_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: industry_categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a industry_category.
     */
    data: XOR<industry_categoryUpdateInput, industry_categoryUncheckedUpdateInput>
    /**
     * Choose, which industry_category to update.
     */
    where: industry_categoryWhereUniqueInput
  }

  /**
   * industry_category updateMany
   */
  export type industry_categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update industry_categories.
     */
    data: XOR<industry_categoryUpdateManyMutationInput, industry_categoryUncheckedUpdateManyInput>
    /**
     * Filter which industry_categories to update
     */
    where?: industry_categoryWhereInput
    /**
     * Limit how many industry_categories to update.
     */
    limit?: number
  }

  /**
   * industry_category updateManyAndReturn
   */
  export type industry_categoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industry_category
     */
    select?: industry_categorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the industry_category
     */
    omit?: industry_categoryOmit<ExtArgs> | null
    /**
     * The data used to update industry_categories.
     */
    data: XOR<industry_categoryUpdateManyMutationInput, industry_categoryUncheckedUpdateManyInput>
    /**
     * Filter which industry_categories to update
     */
    where?: industry_categoryWhereInput
    /**
     * Limit how many industry_categories to update.
     */
    limit?: number
  }

  /**
   * industry_category upsert
   */
  export type industry_categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industry_category
     */
    select?: industry_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the industry_category
     */
    omit?: industry_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: industry_categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the industry_category to update in case it exists.
     */
    where: industry_categoryWhereUniqueInput
    /**
     * In case the industry_category found by the `where` argument doesn't exist, create a new industry_category with this data.
     */
    create: XOR<industry_categoryCreateInput, industry_categoryUncheckedCreateInput>
    /**
     * In case the industry_category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<industry_categoryUpdateInput, industry_categoryUncheckedUpdateInput>
  }

  /**
   * industry_category delete
   */
  export type industry_categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industry_category
     */
    select?: industry_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the industry_category
     */
    omit?: industry_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: industry_categoryInclude<ExtArgs> | null
    /**
     * Filter which industry_category to delete.
     */
    where: industry_categoryWhereUniqueInput
  }

  /**
   * industry_category deleteMany
   */
  export type industry_categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which industry_categories to delete
     */
    where?: industry_categoryWhereInput
    /**
     * Limit how many industry_categories to delete.
     */
    limit?: number
  }

  /**
   * industry_category.company_industry
   */
  export type industry_category$company_industryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_industry
     */
    select?: company_industrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_industry
     */
    omit?: company_industryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_industryInclude<ExtArgs> | null
    where?: company_industryWhereInput
    orderBy?: company_industryOrderByWithRelationInput | company_industryOrderByWithRelationInput[]
    cursor?: company_industryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Company_industryScalarFieldEnum | Company_industryScalarFieldEnum[]
  }

  /**
   * industry_category without action
   */
  export type industry_categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the industry_category
     */
    select?: industry_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the industry_category
     */
    omit?: industry_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: industry_categoryInclude<ExtArgs> | null
  }


  /**
   * Model job
   */

  export type AggregateJob = {
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  export type JobAvgAggregateOutputType = {
    job_id: number | null
    job_company: number | null
    salary_min: Decimal | null
    salary_max: Decimal | null
    job_country_id: number | null
    job_state_id: number | null
    job_city_id: number | null
  }

  export type JobSumAggregateOutputType = {
    job_id: number | null
    job_company: number | null
    salary_min: Decimal | null
    salary_max: Decimal | null
    job_country_id: number | null
    job_state_id: number | null
    job_city_id: number | null
  }

  export type JobMinAggregateOutputType = {
    job_id: number | null
    job_uuid: string | null
    job_company: number | null
    job_description: string | null
    job_name: string | null
    job_posted_date: Date | null
    apply_link: string | null
    salary_min: Decimal | null
    salary_max: Decimal | null
    salary_currency: string | null
    salary_frequency: $Enums.salaryFrequency | null
    job_status: boolean | null
    is_remote: boolean | null
    job_country_id: number | null
    job_state_id: number | null
    job_city_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type JobMaxAggregateOutputType = {
    job_id: number | null
    job_uuid: string | null
    job_company: number | null
    job_description: string | null
    job_name: string | null
    job_posted_date: Date | null
    apply_link: string | null
    salary_min: Decimal | null
    salary_max: Decimal | null
    salary_currency: string | null
    salary_frequency: $Enums.salaryFrequency | null
    job_status: boolean | null
    is_remote: boolean | null
    job_country_id: number | null
    job_state_id: number | null
    job_city_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type JobCountAggregateOutputType = {
    job_id: number
    job_uuid: number
    job_company: number
    job_description: number
    job_name: number
    job_posted_date: number
    apply_link: number
    salary_min: number
    salary_max: number
    salary_currency: number
    salary_frequency: number
    job_status: number
    is_remote: number
    job_country_id: number
    job_state_id: number
    job_city_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type JobAvgAggregateInputType = {
    job_id?: true
    job_company?: true
    salary_min?: true
    salary_max?: true
    job_country_id?: true
    job_state_id?: true
    job_city_id?: true
  }

  export type JobSumAggregateInputType = {
    job_id?: true
    job_company?: true
    salary_min?: true
    salary_max?: true
    job_country_id?: true
    job_state_id?: true
    job_city_id?: true
  }

  export type JobMinAggregateInputType = {
    job_id?: true
    job_uuid?: true
    job_company?: true
    job_description?: true
    job_name?: true
    job_posted_date?: true
    apply_link?: true
    salary_min?: true
    salary_max?: true
    salary_currency?: true
    salary_frequency?: true
    job_status?: true
    is_remote?: true
    job_country_id?: true
    job_state_id?: true
    job_city_id?: true
    created_at?: true
    updated_at?: true
  }

  export type JobMaxAggregateInputType = {
    job_id?: true
    job_uuid?: true
    job_company?: true
    job_description?: true
    job_name?: true
    job_posted_date?: true
    apply_link?: true
    salary_min?: true
    salary_max?: true
    salary_currency?: true
    salary_frequency?: true
    job_status?: true
    is_remote?: true
    job_country_id?: true
    job_state_id?: true
    job_city_id?: true
    created_at?: true
    updated_at?: true
  }

  export type JobCountAggregateInputType = {
    job_id?: true
    job_uuid?: true
    job_company?: true
    job_description?: true
    job_name?: true
    job_posted_date?: true
    apply_link?: true
    salary_min?: true
    salary_max?: true
    salary_currency?: true
    salary_frequency?: true
    job_status?: true
    is_remote?: true
    job_country_id?: true
    job_state_id?: true
    job_city_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type JobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job to aggregate.
     */
    where?: jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jobs
    **/
    _count?: true | JobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobMaxAggregateInputType
  }

  export type GetJobAggregateType<T extends JobAggregateArgs> = {
        [P in keyof T & keyof AggregateJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob[P]>
      : GetScalarType<T[P], AggregateJob[P]>
  }




  export type jobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobWhereInput
    orderBy?: jobOrderByWithAggregationInput | jobOrderByWithAggregationInput[]
    by: JobScalarFieldEnum[] | JobScalarFieldEnum
    having?: jobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCountAggregateInputType | true
    _avg?: JobAvgAggregateInputType
    _sum?: JobSumAggregateInputType
    _min?: JobMinAggregateInputType
    _max?: JobMaxAggregateInputType
  }

  export type JobGroupByOutputType = {
    job_id: number
    job_uuid: string
    job_company: number
    job_description: string | null
    job_name: string
    job_posted_date: Date
    apply_link: string
    salary_min: Decimal | null
    salary_max: Decimal | null
    salary_currency: string | null
    salary_frequency: $Enums.salaryFrequency | null
    job_status: boolean
    is_remote: boolean
    job_country_id: number
    job_state_id: number
    job_city_id: number
    created_at: Date
    updated_at: Date
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  type GetJobGroupByPayload<T extends jobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobGroupByOutputType[P]>
            : GetScalarType<T[P], JobGroupByOutputType[P]>
        }
      >
    >


  export type jobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_id?: boolean
    job_uuid?: boolean
    job_company?: boolean
    job_description?: boolean
    job_name?: boolean
    job_posted_date?: boolean
    apply_link?: boolean
    salary_min?: boolean
    salary_max?: boolean
    salary_currency?: boolean
    salary_frequency?: boolean
    job_status?: boolean
    is_remote?: boolean
    job_country_id?: boolean
    job_state_id?: boolean
    job_city_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    city?: boolean | cityDefaultArgs<ExtArgs>
    company?: boolean | companyDefaultArgs<ExtArgs>
    country?: boolean | countryDefaultArgs<ExtArgs>
    state?: boolean | stateDefaultArgs<ExtArgs>
    job_category_map?: boolean | job$job_category_mapArgs<ExtArgs>
    job_salary_map?: boolean | job$job_salary_mapArgs<ExtArgs>
    job_schedule_map?: boolean | job$job_schedule_mapArgs<ExtArgs>
    job_skill_map?: boolean | job$job_skill_mapArgs<ExtArgs>
    job_source_map?: boolean | job$job_source_mapArgs<ExtArgs>
    job_type_map?: boolean | job$job_type_mapArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type jobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_id?: boolean
    job_uuid?: boolean
    job_company?: boolean
    job_description?: boolean
    job_name?: boolean
    job_posted_date?: boolean
    apply_link?: boolean
    salary_min?: boolean
    salary_max?: boolean
    salary_currency?: boolean
    salary_frequency?: boolean
    job_status?: boolean
    is_remote?: boolean
    job_country_id?: boolean
    job_state_id?: boolean
    job_city_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    city?: boolean | cityDefaultArgs<ExtArgs>
    company?: boolean | companyDefaultArgs<ExtArgs>
    country?: boolean | countryDefaultArgs<ExtArgs>
    state?: boolean | stateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type jobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_id?: boolean
    job_uuid?: boolean
    job_company?: boolean
    job_description?: boolean
    job_name?: boolean
    job_posted_date?: boolean
    apply_link?: boolean
    salary_min?: boolean
    salary_max?: boolean
    salary_currency?: boolean
    salary_frequency?: boolean
    job_status?: boolean
    is_remote?: boolean
    job_country_id?: boolean
    job_state_id?: boolean
    job_city_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    city?: boolean | cityDefaultArgs<ExtArgs>
    company?: boolean | companyDefaultArgs<ExtArgs>
    country?: boolean | countryDefaultArgs<ExtArgs>
    state?: boolean | stateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type jobSelectScalar = {
    job_id?: boolean
    job_uuid?: boolean
    job_company?: boolean
    job_description?: boolean
    job_name?: boolean
    job_posted_date?: boolean
    apply_link?: boolean
    salary_min?: boolean
    salary_max?: boolean
    salary_currency?: boolean
    salary_frequency?: boolean
    job_status?: boolean
    is_remote?: boolean
    job_country_id?: boolean
    job_state_id?: boolean
    job_city_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type jobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"job_id" | "job_uuid" | "job_company" | "job_description" | "job_name" | "job_posted_date" | "apply_link" | "salary_min" | "salary_max" | "salary_currency" | "salary_frequency" | "job_status" | "is_remote" | "job_country_id" | "job_state_id" | "job_city_id" | "created_at" | "updated_at", ExtArgs["result"]["job"]>
  export type jobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | cityDefaultArgs<ExtArgs>
    company?: boolean | companyDefaultArgs<ExtArgs>
    country?: boolean | countryDefaultArgs<ExtArgs>
    state?: boolean | stateDefaultArgs<ExtArgs>
    job_category_map?: boolean | job$job_category_mapArgs<ExtArgs>
    job_salary_map?: boolean | job$job_salary_mapArgs<ExtArgs>
    job_schedule_map?: boolean | job$job_schedule_mapArgs<ExtArgs>
    job_skill_map?: boolean | job$job_skill_mapArgs<ExtArgs>
    job_source_map?: boolean | job$job_source_mapArgs<ExtArgs>
    job_type_map?: boolean | job$job_type_mapArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type jobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | cityDefaultArgs<ExtArgs>
    company?: boolean | companyDefaultArgs<ExtArgs>
    country?: boolean | countryDefaultArgs<ExtArgs>
    state?: boolean | stateDefaultArgs<ExtArgs>
  }
  export type jobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | cityDefaultArgs<ExtArgs>
    company?: boolean | companyDefaultArgs<ExtArgs>
    country?: boolean | countryDefaultArgs<ExtArgs>
    state?: boolean | stateDefaultArgs<ExtArgs>
  }

  export type $jobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job"
    objects: {
      city: Prisma.$cityPayload<ExtArgs>
      company: Prisma.$companyPayload<ExtArgs>
      country: Prisma.$countryPayload<ExtArgs>
      state: Prisma.$statePayload<ExtArgs>
      job_category_map: Prisma.$job_category_mapPayload<ExtArgs>[]
      job_salary_map: Prisma.$job_salary_mapPayload<ExtArgs>[]
      job_schedule_map: Prisma.$job_schedule_mapPayload<ExtArgs>[]
      job_skill_map: Prisma.$job_skill_mapPayload<ExtArgs>[]
      job_source_map: Prisma.$job_source_mapPayload<ExtArgs>[]
      job_type_map: Prisma.$job_type_mapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      job_id: number
      job_uuid: string
      job_company: number
      job_description: string | null
      job_name: string
      job_posted_date: Date
      apply_link: string
      salary_min: Prisma.Decimal | null
      salary_max: Prisma.Decimal | null
      salary_currency: string | null
      salary_frequency: $Enums.salaryFrequency | null
      job_status: boolean
      is_remote: boolean
      job_country_id: number
      job_state_id: number
      job_city_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["job"]>
    composites: {}
  }

  type jobGetPayload<S extends boolean | null | undefined | jobDefaultArgs> = $Result.GetResult<Prisma.$jobPayload, S>

  type jobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<jobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobCountAggregateInputType | true
    }

  export interface jobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job'], meta: { name: 'job' } }
    /**
     * Find zero or one Job that matches the filter.
     * @param {jobFindUniqueArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends jobFindUniqueArgs>(args: SelectSubset<T, jobFindUniqueArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {jobFindUniqueOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends jobFindUniqueOrThrowArgs>(args: SelectSubset<T, jobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobFindFirstArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends jobFindFirstArgs>(args?: SelectSubset<T, jobFindFirstArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobFindFirstOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends jobFindFirstOrThrowArgs>(args?: SelectSubset<T, jobFindFirstOrThrowArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.job.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.job.findMany({ take: 10 })
     * 
     * // Only select the `job_id`
     * const jobWithJob_idOnly = await prisma.job.findMany({ select: { job_id: true } })
     * 
     */
    findMany<T extends jobFindManyArgs>(args?: SelectSubset<T, jobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job.
     * @param {jobCreateArgs} args - Arguments to create a Job.
     * @example
     * // Create one Job
     * const Job = await prisma.job.create({
     *   data: {
     *     // ... data to create a Job
     *   }
     * })
     * 
     */
    create<T extends jobCreateArgs>(args: SelectSubset<T, jobCreateArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobs.
     * @param {jobCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends jobCreateManyArgs>(args?: SelectSubset<T, jobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jobs and returns the data saved in the database.
     * @param {jobCreateManyAndReturnArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jobs and only return the `job_id`
     * const jobWithJob_idOnly = await prisma.job.createManyAndReturn({
     *   select: { job_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends jobCreateManyAndReturnArgs>(args?: SelectSubset<T, jobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job.
     * @param {jobDeleteArgs} args - Arguments to delete one Job.
     * @example
     * // Delete one Job
     * const Job = await prisma.job.delete({
     *   where: {
     *     // ... filter to delete one Job
     *   }
     * })
     * 
     */
    delete<T extends jobDeleteArgs>(args: SelectSubset<T, jobDeleteArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job.
     * @param {jobUpdateArgs} args - Arguments to update one Job.
     * @example
     * // Update one Job
     * const job = await prisma.job.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends jobUpdateArgs>(args: SelectSubset<T, jobUpdateArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobs.
     * @param {jobDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.job.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends jobDeleteManyArgs>(args?: SelectSubset<T, jobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends jobUpdateManyArgs>(args: SelectSubset<T, jobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs and returns the data updated in the database.
     * @param {jobUpdateManyAndReturnArgs} args - Arguments to update many Jobs.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Jobs and only return the `job_id`
     * const jobWithJob_idOnly = await prisma.job.updateManyAndReturn({
     *   select: { job_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends jobUpdateManyAndReturnArgs>(args: SelectSubset<T, jobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job.
     * @param {jobUpsertArgs} args - Arguments to update or create a Job.
     * @example
     * // Update or create a Job
     * const job = await prisma.job.upsert({
     *   create: {
     *     // ... data to create a Job
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job we want to update
     *   }
     * })
     */
    upsert<T extends jobUpsertArgs>(args: SelectSubset<T, jobUpsertArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.job.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends jobCountArgs>(
      args?: Subset<T, jobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobAggregateArgs>(args: Subset<T, JobAggregateArgs>): Prisma.PrismaPromise<GetJobAggregateType<T>>

    /**
     * Group by Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends jobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: jobGroupByArgs['orderBy'] }
        : { orderBy?: jobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, jobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job model
   */
  readonly fields: jobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__jobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends cityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cityDefaultArgs<ExtArgs>>): Prisma__cityClient<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends companyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companyDefaultArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    country<T extends countryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, countryDefaultArgs<ExtArgs>>): Prisma__countryClient<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    state<T extends stateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, stateDefaultArgs<ExtArgs>>): Prisma__stateClient<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    job_category_map<T extends job$job_category_mapArgs<ExtArgs> = {}>(args?: Subset<T, job$job_category_mapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_category_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    job_salary_map<T extends job$job_salary_mapArgs<ExtArgs> = {}>(args?: Subset<T, job$job_salary_mapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_salary_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    job_schedule_map<T extends job$job_schedule_mapArgs<ExtArgs> = {}>(args?: Subset<T, job$job_schedule_mapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_schedule_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    job_skill_map<T extends job$job_skill_mapArgs<ExtArgs> = {}>(args?: Subset<T, job$job_skill_mapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_skill_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    job_source_map<T extends job$job_source_mapArgs<ExtArgs> = {}>(args?: Subset<T, job$job_source_mapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_source_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    job_type_map<T extends job$job_type_mapArgs<ExtArgs> = {}>(args?: Subset<T, job$job_type_mapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_type_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job model
   */
  interface jobFieldRefs {
    readonly job_id: FieldRef<"job", 'Int'>
    readonly job_uuid: FieldRef<"job", 'String'>
    readonly job_company: FieldRef<"job", 'Int'>
    readonly job_description: FieldRef<"job", 'String'>
    readonly job_name: FieldRef<"job", 'String'>
    readonly job_posted_date: FieldRef<"job", 'DateTime'>
    readonly apply_link: FieldRef<"job", 'String'>
    readonly salary_min: FieldRef<"job", 'Decimal'>
    readonly salary_max: FieldRef<"job", 'Decimal'>
    readonly salary_currency: FieldRef<"job", 'String'>
    readonly salary_frequency: FieldRef<"job", 'salaryFrequency'>
    readonly job_status: FieldRef<"job", 'Boolean'>
    readonly is_remote: FieldRef<"job", 'Boolean'>
    readonly job_country_id: FieldRef<"job", 'Int'>
    readonly job_state_id: FieldRef<"job", 'Int'>
    readonly job_city_id: FieldRef<"job", 'Int'>
    readonly created_at: FieldRef<"job", 'DateTime'>
    readonly updated_at: FieldRef<"job", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * job findUnique
   */
  export type jobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which job to fetch.
     */
    where: jobWhereUniqueInput
  }

  /**
   * job findUniqueOrThrow
   */
  export type jobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which job to fetch.
     */
    where: jobWhereUniqueInput
  }

  /**
   * job findFirst
   */
  export type jobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which job to fetch.
     */
    where?: jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobs.
     */
    cursor?: jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * job findFirstOrThrow
   */
  export type jobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which job to fetch.
     */
    where?: jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobs.
     */
    cursor?: jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * job findMany
   */
  export type jobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where?: jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jobs.
     */
    cursor?: jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * job create
   */
  export type jobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * The data needed to create a job.
     */
    data: XOR<jobCreateInput, jobUncheckedCreateInput>
  }

  /**
   * job createMany
   */
  export type jobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many jobs.
     */
    data: jobCreateManyInput | jobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job createManyAndReturn
   */
  export type jobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * The data used to create many jobs.
     */
    data: jobCreateManyInput | jobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * job update
   */
  export type jobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * The data needed to update a job.
     */
    data: XOR<jobUpdateInput, jobUncheckedUpdateInput>
    /**
     * Choose, which job to update.
     */
    where: jobWhereUniqueInput
  }

  /**
   * job updateMany
   */
  export type jobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update jobs.
     */
    data: XOR<jobUpdateManyMutationInput, jobUncheckedUpdateManyInput>
    /**
     * Filter which jobs to update
     */
    where?: jobWhereInput
    /**
     * Limit how many jobs to update.
     */
    limit?: number
  }

  /**
   * job updateManyAndReturn
   */
  export type jobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * The data used to update jobs.
     */
    data: XOR<jobUpdateManyMutationInput, jobUncheckedUpdateManyInput>
    /**
     * Filter which jobs to update
     */
    where?: jobWhereInput
    /**
     * Limit how many jobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * job upsert
   */
  export type jobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * The filter to search for the job to update in case it exists.
     */
    where: jobWhereUniqueInput
    /**
     * In case the job found by the `where` argument doesn't exist, create a new job with this data.
     */
    create: XOR<jobCreateInput, jobUncheckedCreateInput>
    /**
     * In case the job was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jobUpdateInput, jobUncheckedUpdateInput>
  }

  /**
   * job delete
   */
  export type jobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter which job to delete.
     */
    where: jobWhereUniqueInput
  }

  /**
   * job deleteMany
   */
  export type jobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobs to delete
     */
    where?: jobWhereInput
    /**
     * Limit how many jobs to delete.
     */
    limit?: number
  }

  /**
   * job.job_category_map
   */
  export type job$job_category_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category_map
     */
    select?: job_category_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category_map
     */
    omit?: job_category_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_category_mapInclude<ExtArgs> | null
    where?: job_category_mapWhereInput
    orderBy?: job_category_mapOrderByWithRelationInput | job_category_mapOrderByWithRelationInput[]
    cursor?: job_category_mapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_category_mapScalarFieldEnum | Job_category_mapScalarFieldEnum[]
  }

  /**
   * job.job_salary_map
   */
  export type job$job_salary_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary_map
     */
    select?: job_salary_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary_map
     */
    omit?: job_salary_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salary_mapInclude<ExtArgs> | null
    where?: job_salary_mapWhereInput
    orderBy?: job_salary_mapOrderByWithRelationInput | job_salary_mapOrderByWithRelationInput[]
    cursor?: job_salary_mapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_salary_mapScalarFieldEnum | Job_salary_mapScalarFieldEnum[]
  }

  /**
   * job.job_schedule_map
   */
  export type job$job_schedule_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule_map
     */
    select?: job_schedule_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule_map
     */
    omit?: job_schedule_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_schedule_mapInclude<ExtArgs> | null
    where?: job_schedule_mapWhereInput
    orderBy?: job_schedule_mapOrderByWithRelationInput | job_schedule_mapOrderByWithRelationInput[]
    cursor?: job_schedule_mapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_schedule_mapScalarFieldEnum | Job_schedule_mapScalarFieldEnum[]
  }

  /**
   * job.job_skill_map
   */
  export type job$job_skill_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill_map
     */
    select?: job_skill_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill_map
     */
    omit?: job_skill_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skill_mapInclude<ExtArgs> | null
    where?: job_skill_mapWhereInput
    orderBy?: job_skill_mapOrderByWithRelationInput | job_skill_mapOrderByWithRelationInput[]
    cursor?: job_skill_mapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_skill_mapScalarFieldEnum | Job_skill_mapScalarFieldEnum[]
  }

  /**
   * job.job_source_map
   */
  export type job$job_source_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source_map
     */
    select?: job_source_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source_map
     */
    omit?: job_source_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_source_mapInclude<ExtArgs> | null
    where?: job_source_mapWhereInput
    orderBy?: job_source_mapOrderByWithRelationInput | job_source_mapOrderByWithRelationInput[]
    cursor?: job_source_mapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_source_mapScalarFieldEnum | Job_source_mapScalarFieldEnum[]
  }

  /**
   * job.job_type_map
   */
  export type job$job_type_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type_map
     */
    select?: job_type_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type_map
     */
    omit?: job_type_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_type_mapInclude<ExtArgs> | null
    where?: job_type_mapWhereInput
    orderBy?: job_type_mapOrderByWithRelationInput | job_type_mapOrderByWithRelationInput[]
    cursor?: job_type_mapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_type_mapScalarFieldEnum | Job_type_mapScalarFieldEnum[]
  }

  /**
   * job without action
   */
  export type jobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
  }


  /**
   * Model job_category
   */

  export type AggregateJob_category = {
    _count: Job_categoryCountAggregateOutputType | null
    _avg: Job_categoryAvgAggregateOutputType | null
    _sum: Job_categorySumAggregateOutputType | null
    _min: Job_categoryMinAggregateOutputType | null
    _max: Job_categoryMaxAggregateOutputType | null
  }

  export type Job_categoryAvgAggregateOutputType = {
    job_category_id: number | null
  }

  export type Job_categorySumAggregateOutputType = {
    job_category_id: number | null
  }

  export type Job_categoryMinAggregateOutputType = {
    job_category_id: number | null
    job_category_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_categoryMaxAggregateOutputType = {
    job_category_id: number | null
    job_category_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_categoryCountAggregateOutputType = {
    job_category_id: number
    job_category_name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Job_categoryAvgAggregateInputType = {
    job_category_id?: true
  }

  export type Job_categorySumAggregateInputType = {
    job_category_id?: true
  }

  export type Job_categoryMinAggregateInputType = {
    job_category_id?: true
    job_category_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_categoryMaxAggregateInputType = {
    job_category_id?: true
    job_category_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_categoryCountAggregateInputType = {
    job_category_id?: true
    job_category_name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Job_categoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_category to aggregate.
     */
    where?: job_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_categories to fetch.
     */
    orderBy?: job_categoryOrderByWithRelationInput | job_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_categories
    **/
    _count?: true | Job_categoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Job_categoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Job_categorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_categoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_categoryMaxAggregateInputType
  }

  export type GetJob_categoryAggregateType<T extends Job_categoryAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_category]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_category[P]>
      : GetScalarType<T[P], AggregateJob_category[P]>
  }




  export type job_categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_categoryWhereInput
    orderBy?: job_categoryOrderByWithAggregationInput | job_categoryOrderByWithAggregationInput[]
    by: Job_categoryScalarFieldEnum[] | Job_categoryScalarFieldEnum
    having?: job_categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_categoryCountAggregateInputType | true
    _avg?: Job_categoryAvgAggregateInputType
    _sum?: Job_categorySumAggregateInputType
    _min?: Job_categoryMinAggregateInputType
    _max?: Job_categoryMaxAggregateInputType
  }

  export type Job_categoryGroupByOutputType = {
    job_category_id: number
    job_category_name: string
    created_at: Date
    updated_at: Date
    _count: Job_categoryCountAggregateOutputType | null
    _avg: Job_categoryAvgAggregateOutputType | null
    _sum: Job_categorySumAggregateOutputType | null
    _min: Job_categoryMinAggregateOutputType | null
    _max: Job_categoryMaxAggregateOutputType | null
  }

  type GetJob_categoryGroupByPayload<T extends job_categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_categoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_categoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_categoryGroupByOutputType[P]>
            : GetScalarType<T[P], Job_categoryGroupByOutputType[P]>
        }
      >
    >


  export type job_categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_category_id?: boolean
    job_category_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    job_category_map?: boolean | job_category$job_category_mapArgs<ExtArgs>
    _count?: boolean | Job_categoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_category"]>

  export type job_categorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_category_id?: boolean
    job_category_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["job_category"]>

  export type job_categorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_category_id?: boolean
    job_category_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["job_category"]>

  export type job_categorySelectScalar = {
    job_category_id?: boolean
    job_category_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type job_categoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"job_category_id" | "job_category_name" | "created_at" | "updated_at", ExtArgs["result"]["job_category"]>
  export type job_categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_category_map?: boolean | job_category$job_category_mapArgs<ExtArgs>
    _count?: boolean | Job_categoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type job_categoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type job_categoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $job_categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_category"
    objects: {
      job_category_map: Prisma.$job_category_mapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      job_category_id: number
      job_category_name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["job_category"]>
    composites: {}
  }

  type job_categoryGetPayload<S extends boolean | null | undefined | job_categoryDefaultArgs> = $Result.GetResult<Prisma.$job_categoryPayload, S>

  type job_categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_categoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_categoryCountAggregateInputType | true
    }

  export interface job_categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_category'], meta: { name: 'job_category' } }
    /**
     * Find zero or one Job_category that matches the filter.
     * @param {job_categoryFindUniqueArgs} args - Arguments to find a Job_category
     * @example
     * // Get one Job_category
     * const job_category = await prisma.job_category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_categoryFindUniqueArgs>(args: SelectSubset<T, job_categoryFindUniqueArgs<ExtArgs>>): Prisma__job_categoryClient<$Result.GetResult<Prisma.$job_categoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_categoryFindUniqueOrThrowArgs} args - Arguments to find a Job_category
     * @example
     * // Get one Job_category
     * const job_category = await prisma.job_category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_categoryFindUniqueOrThrowArgs>(args: SelectSubset<T, job_categoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_categoryClient<$Result.GetResult<Prisma.$job_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_categoryFindFirstArgs} args - Arguments to find a Job_category
     * @example
     * // Get one Job_category
     * const job_category = await prisma.job_category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_categoryFindFirstArgs>(args?: SelectSubset<T, job_categoryFindFirstArgs<ExtArgs>>): Prisma__job_categoryClient<$Result.GetResult<Prisma.$job_categoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_categoryFindFirstOrThrowArgs} args - Arguments to find a Job_category
     * @example
     * // Get one Job_category
     * const job_category = await prisma.job_category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_categoryFindFirstOrThrowArgs>(args?: SelectSubset<T, job_categoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_categoryClient<$Result.GetResult<Prisma.$job_categoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_categories
     * const job_categories = await prisma.job_category.findMany()
     * 
     * // Get first 10 Job_categories
     * const job_categories = await prisma.job_category.findMany({ take: 10 })
     * 
     * // Only select the `job_category_id`
     * const job_categoryWithJob_category_idOnly = await prisma.job_category.findMany({ select: { job_category_id: true } })
     * 
     */
    findMany<T extends job_categoryFindManyArgs>(args?: SelectSubset<T, job_categoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_category.
     * @param {job_categoryCreateArgs} args - Arguments to create a Job_category.
     * @example
     * // Create one Job_category
     * const Job_category = await prisma.job_category.create({
     *   data: {
     *     // ... data to create a Job_category
     *   }
     * })
     * 
     */
    create<T extends job_categoryCreateArgs>(args: SelectSubset<T, job_categoryCreateArgs<ExtArgs>>): Prisma__job_categoryClient<$Result.GetResult<Prisma.$job_categoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_categories.
     * @param {job_categoryCreateManyArgs} args - Arguments to create many Job_categories.
     * @example
     * // Create many Job_categories
     * const job_category = await prisma.job_category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_categoryCreateManyArgs>(args?: SelectSubset<T, job_categoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Job_categories and returns the data saved in the database.
     * @param {job_categoryCreateManyAndReturnArgs} args - Arguments to create many Job_categories.
     * @example
     * // Create many Job_categories
     * const job_category = await prisma.job_category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Job_categories and only return the `job_category_id`
     * const job_categoryWithJob_category_idOnly = await prisma.job_category.createManyAndReturn({
     *   select: { job_category_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends job_categoryCreateManyAndReturnArgs>(args?: SelectSubset<T, job_categoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_categoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job_category.
     * @param {job_categoryDeleteArgs} args - Arguments to delete one Job_category.
     * @example
     * // Delete one Job_category
     * const Job_category = await prisma.job_category.delete({
     *   where: {
     *     // ... filter to delete one Job_category
     *   }
     * })
     * 
     */
    delete<T extends job_categoryDeleteArgs>(args: SelectSubset<T, job_categoryDeleteArgs<ExtArgs>>): Prisma__job_categoryClient<$Result.GetResult<Prisma.$job_categoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_category.
     * @param {job_categoryUpdateArgs} args - Arguments to update one Job_category.
     * @example
     * // Update one Job_category
     * const job_category = await prisma.job_category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_categoryUpdateArgs>(args: SelectSubset<T, job_categoryUpdateArgs<ExtArgs>>): Prisma__job_categoryClient<$Result.GetResult<Prisma.$job_categoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_categories.
     * @param {job_categoryDeleteManyArgs} args - Arguments to filter Job_categories to delete.
     * @example
     * // Delete a few Job_categories
     * const { count } = await prisma.job_category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_categoryDeleteManyArgs>(args?: SelectSubset<T, job_categoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_categories
     * const job_category = await prisma.job_category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_categoryUpdateManyArgs>(args: SelectSubset<T, job_categoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_categories and returns the data updated in the database.
     * @param {job_categoryUpdateManyAndReturnArgs} args - Arguments to update many Job_categories.
     * @example
     * // Update many Job_categories
     * const job_category = await prisma.job_category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Job_categories and only return the `job_category_id`
     * const job_categoryWithJob_category_idOnly = await prisma.job_category.updateManyAndReturn({
     *   select: { job_category_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends job_categoryUpdateManyAndReturnArgs>(args: SelectSubset<T, job_categoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_categoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job_category.
     * @param {job_categoryUpsertArgs} args - Arguments to update or create a Job_category.
     * @example
     * // Update or create a Job_category
     * const job_category = await prisma.job_category.upsert({
     *   create: {
     *     // ... data to create a Job_category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_category we want to update
     *   }
     * })
     */
    upsert<T extends job_categoryUpsertArgs>(args: SelectSubset<T, job_categoryUpsertArgs<ExtArgs>>): Prisma__job_categoryClient<$Result.GetResult<Prisma.$job_categoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_categoryCountArgs} args - Arguments to filter Job_categories to count.
     * @example
     * // Count the number of Job_categories
     * const count = await prisma.job_category.count({
     *   where: {
     *     // ... the filter for the Job_categories we want to count
     *   }
     * })
    **/
    count<T extends job_categoryCountArgs>(
      args?: Subset<T, job_categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_categoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_categoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_categoryAggregateArgs>(args: Subset<T, Job_categoryAggregateArgs>): Prisma.PrismaPromise<GetJob_categoryAggregateType<T>>

    /**
     * Group by Job_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_categoryGroupByArgs['orderBy'] }
        : { orderBy?: job_categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_categoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_category model
   */
  readonly fields: job_categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job_category_map<T extends job_category$job_category_mapArgs<ExtArgs> = {}>(args?: Subset<T, job_category$job_category_mapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_category_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_category model
   */
  interface job_categoryFieldRefs {
    readonly job_category_id: FieldRef<"job_category", 'Int'>
    readonly job_category_name: FieldRef<"job_category", 'String'>
    readonly created_at: FieldRef<"job_category", 'DateTime'>
    readonly updated_at: FieldRef<"job_category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * job_category findUnique
   */
  export type job_categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category
     */
    select?: job_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category
     */
    omit?: job_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_categoryInclude<ExtArgs> | null
    /**
     * Filter, which job_category to fetch.
     */
    where: job_categoryWhereUniqueInput
  }

  /**
   * job_category findUniqueOrThrow
   */
  export type job_categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category
     */
    select?: job_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category
     */
    omit?: job_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_categoryInclude<ExtArgs> | null
    /**
     * Filter, which job_category to fetch.
     */
    where: job_categoryWhereUniqueInput
  }

  /**
   * job_category findFirst
   */
  export type job_categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category
     */
    select?: job_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category
     */
    omit?: job_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_categoryInclude<ExtArgs> | null
    /**
     * Filter, which job_category to fetch.
     */
    where?: job_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_categories to fetch.
     */
    orderBy?: job_categoryOrderByWithRelationInput | job_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_categories.
     */
    cursor?: job_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_categories.
     */
    distinct?: Job_categoryScalarFieldEnum | Job_categoryScalarFieldEnum[]
  }

  /**
   * job_category findFirstOrThrow
   */
  export type job_categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category
     */
    select?: job_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category
     */
    omit?: job_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_categoryInclude<ExtArgs> | null
    /**
     * Filter, which job_category to fetch.
     */
    where?: job_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_categories to fetch.
     */
    orderBy?: job_categoryOrderByWithRelationInput | job_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_categories.
     */
    cursor?: job_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_categories.
     */
    distinct?: Job_categoryScalarFieldEnum | Job_categoryScalarFieldEnum[]
  }

  /**
   * job_category findMany
   */
  export type job_categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category
     */
    select?: job_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category
     */
    omit?: job_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_categoryInclude<ExtArgs> | null
    /**
     * Filter, which job_categories to fetch.
     */
    where?: job_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_categories to fetch.
     */
    orderBy?: job_categoryOrderByWithRelationInput | job_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_categories.
     */
    cursor?: job_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_categories.
     */
    skip?: number
    distinct?: Job_categoryScalarFieldEnum | Job_categoryScalarFieldEnum[]
  }

  /**
   * job_category create
   */
  export type job_categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category
     */
    select?: job_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category
     */
    omit?: job_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a job_category.
     */
    data: XOR<job_categoryCreateInput, job_categoryUncheckedCreateInput>
  }

  /**
   * job_category createMany
   */
  export type job_categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_categories.
     */
    data: job_categoryCreateManyInput | job_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_category createManyAndReturn
   */
  export type job_categoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category
     */
    select?: job_categorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_category
     */
    omit?: job_categoryOmit<ExtArgs> | null
    /**
     * The data used to create many job_categories.
     */
    data: job_categoryCreateManyInput | job_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_category update
   */
  export type job_categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category
     */
    select?: job_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category
     */
    omit?: job_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a job_category.
     */
    data: XOR<job_categoryUpdateInput, job_categoryUncheckedUpdateInput>
    /**
     * Choose, which job_category to update.
     */
    where: job_categoryWhereUniqueInput
  }

  /**
   * job_category updateMany
   */
  export type job_categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_categories.
     */
    data: XOR<job_categoryUpdateManyMutationInput, job_categoryUncheckedUpdateManyInput>
    /**
     * Filter which job_categories to update
     */
    where?: job_categoryWhereInput
    /**
     * Limit how many job_categories to update.
     */
    limit?: number
  }

  /**
   * job_category updateManyAndReturn
   */
  export type job_categoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category
     */
    select?: job_categorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_category
     */
    omit?: job_categoryOmit<ExtArgs> | null
    /**
     * The data used to update job_categories.
     */
    data: XOR<job_categoryUpdateManyMutationInput, job_categoryUncheckedUpdateManyInput>
    /**
     * Filter which job_categories to update
     */
    where?: job_categoryWhereInput
    /**
     * Limit how many job_categories to update.
     */
    limit?: number
  }

  /**
   * job_category upsert
   */
  export type job_categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category
     */
    select?: job_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category
     */
    omit?: job_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the job_category to update in case it exists.
     */
    where: job_categoryWhereUniqueInput
    /**
     * In case the job_category found by the `where` argument doesn't exist, create a new job_category with this data.
     */
    create: XOR<job_categoryCreateInput, job_categoryUncheckedCreateInput>
    /**
     * In case the job_category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_categoryUpdateInput, job_categoryUncheckedUpdateInput>
  }

  /**
   * job_category delete
   */
  export type job_categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category
     */
    select?: job_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category
     */
    omit?: job_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_categoryInclude<ExtArgs> | null
    /**
     * Filter which job_category to delete.
     */
    where: job_categoryWhereUniqueInput
  }

  /**
   * job_category deleteMany
   */
  export type job_categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_categories to delete
     */
    where?: job_categoryWhereInput
    /**
     * Limit how many job_categories to delete.
     */
    limit?: number
  }

  /**
   * job_category.job_category_map
   */
  export type job_category$job_category_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category_map
     */
    select?: job_category_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category_map
     */
    omit?: job_category_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_category_mapInclude<ExtArgs> | null
    where?: job_category_mapWhereInput
    orderBy?: job_category_mapOrderByWithRelationInput | job_category_mapOrderByWithRelationInput[]
    cursor?: job_category_mapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_category_mapScalarFieldEnum | Job_category_mapScalarFieldEnum[]
  }

  /**
   * job_category without action
   */
  export type job_categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category
     */
    select?: job_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category
     */
    omit?: job_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_categoryInclude<ExtArgs> | null
  }


  /**
   * Model job_category_map
   */

  export type AggregateJob_category_map = {
    _count: Job_category_mapCountAggregateOutputType | null
    _avg: Job_category_mapAvgAggregateOutputType | null
    _sum: Job_category_mapSumAggregateOutputType | null
    _min: Job_category_mapMinAggregateOutputType | null
    _max: Job_category_mapMaxAggregateOutputType | null
  }

  export type Job_category_mapAvgAggregateOutputType = {
    job_category_map_id: number | null
    job_id: number | null
    category_id: number | null
  }

  export type Job_category_mapSumAggregateOutputType = {
    job_category_map_id: number | null
    job_id: number | null
    category_id: number | null
  }

  export type Job_category_mapMinAggregateOutputType = {
    job_category_map_id: number | null
    job_category_map_uuid: string | null
    job_id: number | null
    category_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_category_mapMaxAggregateOutputType = {
    job_category_map_id: number | null
    job_category_map_uuid: string | null
    job_id: number | null
    category_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_category_mapCountAggregateOutputType = {
    job_category_map_id: number
    job_category_map_uuid: number
    job_id: number
    category_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Job_category_mapAvgAggregateInputType = {
    job_category_map_id?: true
    job_id?: true
    category_id?: true
  }

  export type Job_category_mapSumAggregateInputType = {
    job_category_map_id?: true
    job_id?: true
    category_id?: true
  }

  export type Job_category_mapMinAggregateInputType = {
    job_category_map_id?: true
    job_category_map_uuid?: true
    job_id?: true
    category_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_category_mapMaxAggregateInputType = {
    job_category_map_id?: true
    job_category_map_uuid?: true
    job_id?: true
    category_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_category_mapCountAggregateInputType = {
    job_category_map_id?: true
    job_category_map_uuid?: true
    job_id?: true
    category_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Job_category_mapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_category_map to aggregate.
     */
    where?: job_category_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_category_maps to fetch.
     */
    orderBy?: job_category_mapOrderByWithRelationInput | job_category_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_category_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_category_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_category_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_category_maps
    **/
    _count?: true | Job_category_mapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Job_category_mapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Job_category_mapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_category_mapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_category_mapMaxAggregateInputType
  }

  export type GetJob_category_mapAggregateType<T extends Job_category_mapAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_category_map]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_category_map[P]>
      : GetScalarType<T[P], AggregateJob_category_map[P]>
  }




  export type job_category_mapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_category_mapWhereInput
    orderBy?: job_category_mapOrderByWithAggregationInput | job_category_mapOrderByWithAggregationInput[]
    by: Job_category_mapScalarFieldEnum[] | Job_category_mapScalarFieldEnum
    having?: job_category_mapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_category_mapCountAggregateInputType | true
    _avg?: Job_category_mapAvgAggregateInputType
    _sum?: Job_category_mapSumAggregateInputType
    _min?: Job_category_mapMinAggregateInputType
    _max?: Job_category_mapMaxAggregateInputType
  }

  export type Job_category_mapGroupByOutputType = {
    job_category_map_id: number
    job_category_map_uuid: string
    job_id: number
    category_id: number
    created_at: Date
    updated_at: Date
    _count: Job_category_mapCountAggregateOutputType | null
    _avg: Job_category_mapAvgAggregateOutputType | null
    _sum: Job_category_mapSumAggregateOutputType | null
    _min: Job_category_mapMinAggregateOutputType | null
    _max: Job_category_mapMaxAggregateOutputType | null
  }

  type GetJob_category_mapGroupByPayload<T extends job_category_mapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_category_mapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_category_mapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_category_mapGroupByOutputType[P]>
            : GetScalarType<T[P], Job_category_mapGroupByOutputType[P]>
        }
      >
    >


  export type job_category_mapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_category_map_id?: boolean
    job_category_map_uuid?: boolean
    job_id?: boolean
    category_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    job_category?: boolean | job_categoryDefaultArgs<ExtArgs>
    job?: boolean | jobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_category_map"]>

  export type job_category_mapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_category_map_id?: boolean
    job_category_map_uuid?: boolean
    job_id?: boolean
    category_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    job_category?: boolean | job_categoryDefaultArgs<ExtArgs>
    job?: boolean | jobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_category_map"]>

  export type job_category_mapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_category_map_id?: boolean
    job_category_map_uuid?: boolean
    job_id?: boolean
    category_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    job_category?: boolean | job_categoryDefaultArgs<ExtArgs>
    job?: boolean | jobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_category_map"]>

  export type job_category_mapSelectScalar = {
    job_category_map_id?: boolean
    job_category_map_uuid?: boolean
    job_id?: boolean
    category_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type job_category_mapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"job_category_map_id" | "job_category_map_uuid" | "job_id" | "category_id" | "created_at" | "updated_at", ExtArgs["result"]["job_category_map"]>
  export type job_category_mapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_category?: boolean | job_categoryDefaultArgs<ExtArgs>
    job?: boolean | jobDefaultArgs<ExtArgs>
  }
  export type job_category_mapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_category?: boolean | job_categoryDefaultArgs<ExtArgs>
    job?: boolean | jobDefaultArgs<ExtArgs>
  }
  export type job_category_mapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_category?: boolean | job_categoryDefaultArgs<ExtArgs>
    job?: boolean | jobDefaultArgs<ExtArgs>
  }

  export type $job_category_mapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_category_map"
    objects: {
      job_category: Prisma.$job_categoryPayload<ExtArgs>
      job: Prisma.$jobPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      job_category_map_id: number
      job_category_map_uuid: string
      job_id: number
      category_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["job_category_map"]>
    composites: {}
  }

  type job_category_mapGetPayload<S extends boolean | null | undefined | job_category_mapDefaultArgs> = $Result.GetResult<Prisma.$job_category_mapPayload, S>

  type job_category_mapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_category_mapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_category_mapCountAggregateInputType | true
    }

  export interface job_category_mapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_category_map'], meta: { name: 'job_category_map' } }
    /**
     * Find zero or one Job_category_map that matches the filter.
     * @param {job_category_mapFindUniqueArgs} args - Arguments to find a Job_category_map
     * @example
     * // Get one Job_category_map
     * const job_category_map = await prisma.job_category_map.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_category_mapFindUniqueArgs>(args: SelectSubset<T, job_category_mapFindUniqueArgs<ExtArgs>>): Prisma__job_category_mapClient<$Result.GetResult<Prisma.$job_category_mapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_category_map that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_category_mapFindUniqueOrThrowArgs} args - Arguments to find a Job_category_map
     * @example
     * // Get one Job_category_map
     * const job_category_map = await prisma.job_category_map.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_category_mapFindUniqueOrThrowArgs>(args: SelectSubset<T, job_category_mapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_category_mapClient<$Result.GetResult<Prisma.$job_category_mapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_category_map that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_category_mapFindFirstArgs} args - Arguments to find a Job_category_map
     * @example
     * // Get one Job_category_map
     * const job_category_map = await prisma.job_category_map.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_category_mapFindFirstArgs>(args?: SelectSubset<T, job_category_mapFindFirstArgs<ExtArgs>>): Prisma__job_category_mapClient<$Result.GetResult<Prisma.$job_category_mapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_category_map that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_category_mapFindFirstOrThrowArgs} args - Arguments to find a Job_category_map
     * @example
     * // Get one Job_category_map
     * const job_category_map = await prisma.job_category_map.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_category_mapFindFirstOrThrowArgs>(args?: SelectSubset<T, job_category_mapFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_category_mapClient<$Result.GetResult<Prisma.$job_category_mapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_category_maps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_category_mapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_category_maps
     * const job_category_maps = await prisma.job_category_map.findMany()
     * 
     * // Get first 10 Job_category_maps
     * const job_category_maps = await prisma.job_category_map.findMany({ take: 10 })
     * 
     * // Only select the `job_category_map_id`
     * const job_category_mapWithJob_category_map_idOnly = await prisma.job_category_map.findMany({ select: { job_category_map_id: true } })
     * 
     */
    findMany<T extends job_category_mapFindManyArgs>(args?: SelectSubset<T, job_category_mapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_category_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_category_map.
     * @param {job_category_mapCreateArgs} args - Arguments to create a Job_category_map.
     * @example
     * // Create one Job_category_map
     * const Job_category_map = await prisma.job_category_map.create({
     *   data: {
     *     // ... data to create a Job_category_map
     *   }
     * })
     * 
     */
    create<T extends job_category_mapCreateArgs>(args: SelectSubset<T, job_category_mapCreateArgs<ExtArgs>>): Prisma__job_category_mapClient<$Result.GetResult<Prisma.$job_category_mapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_category_maps.
     * @param {job_category_mapCreateManyArgs} args - Arguments to create many Job_category_maps.
     * @example
     * // Create many Job_category_maps
     * const job_category_map = await prisma.job_category_map.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_category_mapCreateManyArgs>(args?: SelectSubset<T, job_category_mapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Job_category_maps and returns the data saved in the database.
     * @param {job_category_mapCreateManyAndReturnArgs} args - Arguments to create many Job_category_maps.
     * @example
     * // Create many Job_category_maps
     * const job_category_map = await prisma.job_category_map.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Job_category_maps and only return the `job_category_map_id`
     * const job_category_mapWithJob_category_map_idOnly = await prisma.job_category_map.createManyAndReturn({
     *   select: { job_category_map_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends job_category_mapCreateManyAndReturnArgs>(args?: SelectSubset<T, job_category_mapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_category_mapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job_category_map.
     * @param {job_category_mapDeleteArgs} args - Arguments to delete one Job_category_map.
     * @example
     * // Delete one Job_category_map
     * const Job_category_map = await prisma.job_category_map.delete({
     *   where: {
     *     // ... filter to delete one Job_category_map
     *   }
     * })
     * 
     */
    delete<T extends job_category_mapDeleteArgs>(args: SelectSubset<T, job_category_mapDeleteArgs<ExtArgs>>): Prisma__job_category_mapClient<$Result.GetResult<Prisma.$job_category_mapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_category_map.
     * @param {job_category_mapUpdateArgs} args - Arguments to update one Job_category_map.
     * @example
     * // Update one Job_category_map
     * const job_category_map = await prisma.job_category_map.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_category_mapUpdateArgs>(args: SelectSubset<T, job_category_mapUpdateArgs<ExtArgs>>): Prisma__job_category_mapClient<$Result.GetResult<Prisma.$job_category_mapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_category_maps.
     * @param {job_category_mapDeleteManyArgs} args - Arguments to filter Job_category_maps to delete.
     * @example
     * // Delete a few Job_category_maps
     * const { count } = await prisma.job_category_map.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_category_mapDeleteManyArgs>(args?: SelectSubset<T, job_category_mapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_category_maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_category_mapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_category_maps
     * const job_category_map = await prisma.job_category_map.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_category_mapUpdateManyArgs>(args: SelectSubset<T, job_category_mapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_category_maps and returns the data updated in the database.
     * @param {job_category_mapUpdateManyAndReturnArgs} args - Arguments to update many Job_category_maps.
     * @example
     * // Update many Job_category_maps
     * const job_category_map = await prisma.job_category_map.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Job_category_maps and only return the `job_category_map_id`
     * const job_category_mapWithJob_category_map_idOnly = await prisma.job_category_map.updateManyAndReturn({
     *   select: { job_category_map_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends job_category_mapUpdateManyAndReturnArgs>(args: SelectSubset<T, job_category_mapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_category_mapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job_category_map.
     * @param {job_category_mapUpsertArgs} args - Arguments to update or create a Job_category_map.
     * @example
     * // Update or create a Job_category_map
     * const job_category_map = await prisma.job_category_map.upsert({
     *   create: {
     *     // ... data to create a Job_category_map
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_category_map we want to update
     *   }
     * })
     */
    upsert<T extends job_category_mapUpsertArgs>(args: SelectSubset<T, job_category_mapUpsertArgs<ExtArgs>>): Prisma__job_category_mapClient<$Result.GetResult<Prisma.$job_category_mapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_category_maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_category_mapCountArgs} args - Arguments to filter Job_category_maps to count.
     * @example
     * // Count the number of Job_category_maps
     * const count = await prisma.job_category_map.count({
     *   where: {
     *     // ... the filter for the Job_category_maps we want to count
     *   }
     * })
    **/
    count<T extends job_category_mapCountArgs>(
      args?: Subset<T, job_category_mapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_category_mapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_category_map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_category_mapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_category_mapAggregateArgs>(args: Subset<T, Job_category_mapAggregateArgs>): Prisma.PrismaPromise<GetJob_category_mapAggregateType<T>>

    /**
     * Group by Job_category_map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_category_mapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_category_mapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_category_mapGroupByArgs['orderBy'] }
        : { orderBy?: job_category_mapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_category_mapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_category_mapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_category_map model
   */
  readonly fields: job_category_mapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_category_map.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_category_mapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job_category<T extends job_categoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, job_categoryDefaultArgs<ExtArgs>>): Prisma__job_categoryClient<$Result.GetResult<Prisma.$job_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    job<T extends jobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobDefaultArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_category_map model
   */
  interface job_category_mapFieldRefs {
    readonly job_category_map_id: FieldRef<"job_category_map", 'Int'>
    readonly job_category_map_uuid: FieldRef<"job_category_map", 'String'>
    readonly job_id: FieldRef<"job_category_map", 'Int'>
    readonly category_id: FieldRef<"job_category_map", 'Int'>
    readonly created_at: FieldRef<"job_category_map", 'DateTime'>
    readonly updated_at: FieldRef<"job_category_map", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * job_category_map findUnique
   */
  export type job_category_mapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category_map
     */
    select?: job_category_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category_map
     */
    omit?: job_category_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_category_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_category_map to fetch.
     */
    where: job_category_mapWhereUniqueInput
  }

  /**
   * job_category_map findUniqueOrThrow
   */
  export type job_category_mapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category_map
     */
    select?: job_category_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category_map
     */
    omit?: job_category_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_category_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_category_map to fetch.
     */
    where: job_category_mapWhereUniqueInput
  }

  /**
   * job_category_map findFirst
   */
  export type job_category_mapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category_map
     */
    select?: job_category_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category_map
     */
    omit?: job_category_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_category_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_category_map to fetch.
     */
    where?: job_category_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_category_maps to fetch.
     */
    orderBy?: job_category_mapOrderByWithRelationInput | job_category_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_category_maps.
     */
    cursor?: job_category_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_category_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_category_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_category_maps.
     */
    distinct?: Job_category_mapScalarFieldEnum | Job_category_mapScalarFieldEnum[]
  }

  /**
   * job_category_map findFirstOrThrow
   */
  export type job_category_mapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category_map
     */
    select?: job_category_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category_map
     */
    omit?: job_category_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_category_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_category_map to fetch.
     */
    where?: job_category_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_category_maps to fetch.
     */
    orderBy?: job_category_mapOrderByWithRelationInput | job_category_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_category_maps.
     */
    cursor?: job_category_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_category_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_category_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_category_maps.
     */
    distinct?: Job_category_mapScalarFieldEnum | Job_category_mapScalarFieldEnum[]
  }

  /**
   * job_category_map findMany
   */
  export type job_category_mapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category_map
     */
    select?: job_category_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category_map
     */
    omit?: job_category_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_category_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_category_maps to fetch.
     */
    where?: job_category_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_category_maps to fetch.
     */
    orderBy?: job_category_mapOrderByWithRelationInput | job_category_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_category_maps.
     */
    cursor?: job_category_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_category_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_category_maps.
     */
    skip?: number
    distinct?: Job_category_mapScalarFieldEnum | Job_category_mapScalarFieldEnum[]
  }

  /**
   * job_category_map create
   */
  export type job_category_mapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category_map
     */
    select?: job_category_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category_map
     */
    omit?: job_category_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_category_mapInclude<ExtArgs> | null
    /**
     * The data needed to create a job_category_map.
     */
    data: XOR<job_category_mapCreateInput, job_category_mapUncheckedCreateInput>
  }

  /**
   * job_category_map createMany
   */
  export type job_category_mapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_category_maps.
     */
    data: job_category_mapCreateManyInput | job_category_mapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_category_map createManyAndReturn
   */
  export type job_category_mapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category_map
     */
    select?: job_category_mapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_category_map
     */
    omit?: job_category_mapOmit<ExtArgs> | null
    /**
     * The data used to create many job_category_maps.
     */
    data: job_category_mapCreateManyInput | job_category_mapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_category_mapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_category_map update
   */
  export type job_category_mapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category_map
     */
    select?: job_category_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category_map
     */
    omit?: job_category_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_category_mapInclude<ExtArgs> | null
    /**
     * The data needed to update a job_category_map.
     */
    data: XOR<job_category_mapUpdateInput, job_category_mapUncheckedUpdateInput>
    /**
     * Choose, which job_category_map to update.
     */
    where: job_category_mapWhereUniqueInput
  }

  /**
   * job_category_map updateMany
   */
  export type job_category_mapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_category_maps.
     */
    data: XOR<job_category_mapUpdateManyMutationInput, job_category_mapUncheckedUpdateManyInput>
    /**
     * Filter which job_category_maps to update
     */
    where?: job_category_mapWhereInput
    /**
     * Limit how many job_category_maps to update.
     */
    limit?: number
  }

  /**
   * job_category_map updateManyAndReturn
   */
  export type job_category_mapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category_map
     */
    select?: job_category_mapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_category_map
     */
    omit?: job_category_mapOmit<ExtArgs> | null
    /**
     * The data used to update job_category_maps.
     */
    data: XOR<job_category_mapUpdateManyMutationInput, job_category_mapUncheckedUpdateManyInput>
    /**
     * Filter which job_category_maps to update
     */
    where?: job_category_mapWhereInput
    /**
     * Limit how many job_category_maps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_category_mapIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_category_map upsert
   */
  export type job_category_mapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category_map
     */
    select?: job_category_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category_map
     */
    omit?: job_category_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_category_mapInclude<ExtArgs> | null
    /**
     * The filter to search for the job_category_map to update in case it exists.
     */
    where: job_category_mapWhereUniqueInput
    /**
     * In case the job_category_map found by the `where` argument doesn't exist, create a new job_category_map with this data.
     */
    create: XOR<job_category_mapCreateInput, job_category_mapUncheckedCreateInput>
    /**
     * In case the job_category_map was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_category_mapUpdateInput, job_category_mapUncheckedUpdateInput>
  }

  /**
   * job_category_map delete
   */
  export type job_category_mapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category_map
     */
    select?: job_category_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category_map
     */
    omit?: job_category_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_category_mapInclude<ExtArgs> | null
    /**
     * Filter which job_category_map to delete.
     */
    where: job_category_mapWhereUniqueInput
  }

  /**
   * job_category_map deleteMany
   */
  export type job_category_mapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_category_maps to delete
     */
    where?: job_category_mapWhereInput
    /**
     * Limit how many job_category_maps to delete.
     */
    limit?: number
  }

  /**
   * job_category_map without action
   */
  export type job_category_mapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_category_map
     */
    select?: job_category_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_category_map
     */
    omit?: job_category_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_category_mapInclude<ExtArgs> | null
  }


  /**
   * Model job_salary
   */

  export type AggregateJob_salary = {
    _count: Job_salaryCountAggregateOutputType | null
    _avg: Job_salaryAvgAggregateOutputType | null
    _sum: Job_salarySumAggregateOutputType | null
    _min: Job_salaryMinAggregateOutputType | null
    _max: Job_salaryMaxAggregateOutputType | null
  }

  export type Job_salaryAvgAggregateOutputType = {
    job_salary_id: number | null
  }

  export type Job_salarySumAggregateOutputType = {
    job_salary_id: number | null
  }

  export type Job_salaryMinAggregateOutputType = {
    job_salary_id: number | null
    job_salary_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_salaryMaxAggregateOutputType = {
    job_salary_id: number | null
    job_salary_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_salaryCountAggregateOutputType = {
    job_salary_id: number
    job_salary_name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Job_salaryAvgAggregateInputType = {
    job_salary_id?: true
  }

  export type Job_salarySumAggregateInputType = {
    job_salary_id?: true
  }

  export type Job_salaryMinAggregateInputType = {
    job_salary_id?: true
    job_salary_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_salaryMaxAggregateInputType = {
    job_salary_id?: true
    job_salary_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_salaryCountAggregateInputType = {
    job_salary_id?: true
    job_salary_name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Job_salaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_salary to aggregate.
     */
    where?: job_salaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_salaries to fetch.
     */
    orderBy?: job_salaryOrderByWithRelationInput | job_salaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_salaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_salaries
    **/
    _count?: true | Job_salaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Job_salaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Job_salarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_salaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_salaryMaxAggregateInputType
  }

  export type GetJob_salaryAggregateType<T extends Job_salaryAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_salary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_salary[P]>
      : GetScalarType<T[P], AggregateJob_salary[P]>
  }




  export type job_salaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_salaryWhereInput
    orderBy?: job_salaryOrderByWithAggregationInput | job_salaryOrderByWithAggregationInput[]
    by: Job_salaryScalarFieldEnum[] | Job_salaryScalarFieldEnum
    having?: job_salaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_salaryCountAggregateInputType | true
    _avg?: Job_salaryAvgAggregateInputType
    _sum?: Job_salarySumAggregateInputType
    _min?: Job_salaryMinAggregateInputType
    _max?: Job_salaryMaxAggregateInputType
  }

  export type Job_salaryGroupByOutputType = {
    job_salary_id: number
    job_salary_name: string
    created_at: Date
    updated_at: Date
    _count: Job_salaryCountAggregateOutputType | null
    _avg: Job_salaryAvgAggregateOutputType | null
    _sum: Job_salarySumAggregateOutputType | null
    _min: Job_salaryMinAggregateOutputType | null
    _max: Job_salaryMaxAggregateOutputType | null
  }

  type GetJob_salaryGroupByPayload<T extends job_salaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_salaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_salaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_salaryGroupByOutputType[P]>
            : GetScalarType<T[P], Job_salaryGroupByOutputType[P]>
        }
      >
    >


  export type job_salarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_salary_id?: boolean
    job_salary_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    job_salary_map?: boolean | job_salary$job_salary_mapArgs<ExtArgs>
    _count?: boolean | Job_salaryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_salary"]>

  export type job_salarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_salary_id?: boolean
    job_salary_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["job_salary"]>

  export type job_salarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_salary_id?: boolean
    job_salary_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["job_salary"]>

  export type job_salarySelectScalar = {
    job_salary_id?: boolean
    job_salary_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type job_salaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"job_salary_id" | "job_salary_name" | "created_at" | "updated_at", ExtArgs["result"]["job_salary"]>
  export type job_salaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_salary_map?: boolean | job_salary$job_salary_mapArgs<ExtArgs>
    _count?: boolean | Job_salaryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type job_salaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type job_salaryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $job_salaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_salary"
    objects: {
      job_salary_map: Prisma.$job_salary_mapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      job_salary_id: number
      job_salary_name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["job_salary"]>
    composites: {}
  }

  type job_salaryGetPayload<S extends boolean | null | undefined | job_salaryDefaultArgs> = $Result.GetResult<Prisma.$job_salaryPayload, S>

  type job_salaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_salaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_salaryCountAggregateInputType | true
    }

  export interface job_salaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_salary'], meta: { name: 'job_salary' } }
    /**
     * Find zero or one Job_salary that matches the filter.
     * @param {job_salaryFindUniqueArgs} args - Arguments to find a Job_salary
     * @example
     * // Get one Job_salary
     * const job_salary = await prisma.job_salary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_salaryFindUniqueArgs>(args: SelectSubset<T, job_salaryFindUniqueArgs<ExtArgs>>): Prisma__job_salaryClient<$Result.GetResult<Prisma.$job_salaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_salary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_salaryFindUniqueOrThrowArgs} args - Arguments to find a Job_salary
     * @example
     * // Get one Job_salary
     * const job_salary = await prisma.job_salary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_salaryFindUniqueOrThrowArgs>(args: SelectSubset<T, job_salaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_salaryClient<$Result.GetResult<Prisma.$job_salaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_salary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_salaryFindFirstArgs} args - Arguments to find a Job_salary
     * @example
     * // Get one Job_salary
     * const job_salary = await prisma.job_salary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_salaryFindFirstArgs>(args?: SelectSubset<T, job_salaryFindFirstArgs<ExtArgs>>): Prisma__job_salaryClient<$Result.GetResult<Prisma.$job_salaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_salary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_salaryFindFirstOrThrowArgs} args - Arguments to find a Job_salary
     * @example
     * // Get one Job_salary
     * const job_salary = await prisma.job_salary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_salaryFindFirstOrThrowArgs>(args?: SelectSubset<T, job_salaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_salaryClient<$Result.GetResult<Prisma.$job_salaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_salaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_salaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_salaries
     * const job_salaries = await prisma.job_salary.findMany()
     * 
     * // Get first 10 Job_salaries
     * const job_salaries = await prisma.job_salary.findMany({ take: 10 })
     * 
     * // Only select the `job_salary_id`
     * const job_salaryWithJob_salary_idOnly = await prisma.job_salary.findMany({ select: { job_salary_id: true } })
     * 
     */
    findMany<T extends job_salaryFindManyArgs>(args?: SelectSubset<T, job_salaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_salaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_salary.
     * @param {job_salaryCreateArgs} args - Arguments to create a Job_salary.
     * @example
     * // Create one Job_salary
     * const Job_salary = await prisma.job_salary.create({
     *   data: {
     *     // ... data to create a Job_salary
     *   }
     * })
     * 
     */
    create<T extends job_salaryCreateArgs>(args: SelectSubset<T, job_salaryCreateArgs<ExtArgs>>): Prisma__job_salaryClient<$Result.GetResult<Prisma.$job_salaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_salaries.
     * @param {job_salaryCreateManyArgs} args - Arguments to create many Job_salaries.
     * @example
     * // Create many Job_salaries
     * const job_salary = await prisma.job_salary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_salaryCreateManyArgs>(args?: SelectSubset<T, job_salaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Job_salaries and returns the data saved in the database.
     * @param {job_salaryCreateManyAndReturnArgs} args - Arguments to create many Job_salaries.
     * @example
     * // Create many Job_salaries
     * const job_salary = await prisma.job_salary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Job_salaries and only return the `job_salary_id`
     * const job_salaryWithJob_salary_idOnly = await prisma.job_salary.createManyAndReturn({
     *   select: { job_salary_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends job_salaryCreateManyAndReturnArgs>(args?: SelectSubset<T, job_salaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_salaryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job_salary.
     * @param {job_salaryDeleteArgs} args - Arguments to delete one Job_salary.
     * @example
     * // Delete one Job_salary
     * const Job_salary = await prisma.job_salary.delete({
     *   where: {
     *     // ... filter to delete one Job_salary
     *   }
     * })
     * 
     */
    delete<T extends job_salaryDeleteArgs>(args: SelectSubset<T, job_salaryDeleteArgs<ExtArgs>>): Prisma__job_salaryClient<$Result.GetResult<Prisma.$job_salaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_salary.
     * @param {job_salaryUpdateArgs} args - Arguments to update one Job_salary.
     * @example
     * // Update one Job_salary
     * const job_salary = await prisma.job_salary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_salaryUpdateArgs>(args: SelectSubset<T, job_salaryUpdateArgs<ExtArgs>>): Prisma__job_salaryClient<$Result.GetResult<Prisma.$job_salaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_salaries.
     * @param {job_salaryDeleteManyArgs} args - Arguments to filter Job_salaries to delete.
     * @example
     * // Delete a few Job_salaries
     * const { count } = await prisma.job_salary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_salaryDeleteManyArgs>(args?: SelectSubset<T, job_salaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_salaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_salaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_salaries
     * const job_salary = await prisma.job_salary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_salaryUpdateManyArgs>(args: SelectSubset<T, job_salaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_salaries and returns the data updated in the database.
     * @param {job_salaryUpdateManyAndReturnArgs} args - Arguments to update many Job_salaries.
     * @example
     * // Update many Job_salaries
     * const job_salary = await prisma.job_salary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Job_salaries and only return the `job_salary_id`
     * const job_salaryWithJob_salary_idOnly = await prisma.job_salary.updateManyAndReturn({
     *   select: { job_salary_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends job_salaryUpdateManyAndReturnArgs>(args: SelectSubset<T, job_salaryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_salaryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job_salary.
     * @param {job_salaryUpsertArgs} args - Arguments to update or create a Job_salary.
     * @example
     * // Update or create a Job_salary
     * const job_salary = await prisma.job_salary.upsert({
     *   create: {
     *     // ... data to create a Job_salary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_salary we want to update
     *   }
     * })
     */
    upsert<T extends job_salaryUpsertArgs>(args: SelectSubset<T, job_salaryUpsertArgs<ExtArgs>>): Prisma__job_salaryClient<$Result.GetResult<Prisma.$job_salaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_salaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_salaryCountArgs} args - Arguments to filter Job_salaries to count.
     * @example
     * // Count the number of Job_salaries
     * const count = await prisma.job_salary.count({
     *   where: {
     *     // ... the filter for the Job_salaries we want to count
     *   }
     * })
    **/
    count<T extends job_salaryCountArgs>(
      args?: Subset<T, job_salaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_salaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_salary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_salaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_salaryAggregateArgs>(args: Subset<T, Job_salaryAggregateArgs>): Prisma.PrismaPromise<GetJob_salaryAggregateType<T>>

    /**
     * Group by Job_salary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_salaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_salaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_salaryGroupByArgs['orderBy'] }
        : { orderBy?: job_salaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_salaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_salaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_salary model
   */
  readonly fields: job_salaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_salary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_salaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job_salary_map<T extends job_salary$job_salary_mapArgs<ExtArgs> = {}>(args?: Subset<T, job_salary$job_salary_mapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_salary_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_salary model
   */
  interface job_salaryFieldRefs {
    readonly job_salary_id: FieldRef<"job_salary", 'Int'>
    readonly job_salary_name: FieldRef<"job_salary", 'String'>
    readonly created_at: FieldRef<"job_salary", 'DateTime'>
    readonly updated_at: FieldRef<"job_salary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * job_salary findUnique
   */
  export type job_salaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary
     */
    select?: job_salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary
     */
    omit?: job_salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salaryInclude<ExtArgs> | null
    /**
     * Filter, which job_salary to fetch.
     */
    where: job_salaryWhereUniqueInput
  }

  /**
   * job_salary findUniqueOrThrow
   */
  export type job_salaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary
     */
    select?: job_salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary
     */
    omit?: job_salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salaryInclude<ExtArgs> | null
    /**
     * Filter, which job_salary to fetch.
     */
    where: job_salaryWhereUniqueInput
  }

  /**
   * job_salary findFirst
   */
  export type job_salaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary
     */
    select?: job_salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary
     */
    omit?: job_salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salaryInclude<ExtArgs> | null
    /**
     * Filter, which job_salary to fetch.
     */
    where?: job_salaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_salaries to fetch.
     */
    orderBy?: job_salaryOrderByWithRelationInput | job_salaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_salaries.
     */
    cursor?: job_salaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_salaries.
     */
    distinct?: Job_salaryScalarFieldEnum | Job_salaryScalarFieldEnum[]
  }

  /**
   * job_salary findFirstOrThrow
   */
  export type job_salaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary
     */
    select?: job_salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary
     */
    omit?: job_salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salaryInclude<ExtArgs> | null
    /**
     * Filter, which job_salary to fetch.
     */
    where?: job_salaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_salaries to fetch.
     */
    orderBy?: job_salaryOrderByWithRelationInput | job_salaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_salaries.
     */
    cursor?: job_salaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_salaries.
     */
    distinct?: Job_salaryScalarFieldEnum | Job_salaryScalarFieldEnum[]
  }

  /**
   * job_salary findMany
   */
  export type job_salaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary
     */
    select?: job_salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary
     */
    omit?: job_salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salaryInclude<ExtArgs> | null
    /**
     * Filter, which job_salaries to fetch.
     */
    where?: job_salaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_salaries to fetch.
     */
    orderBy?: job_salaryOrderByWithRelationInput | job_salaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_salaries.
     */
    cursor?: job_salaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_salaries.
     */
    skip?: number
    distinct?: Job_salaryScalarFieldEnum | Job_salaryScalarFieldEnum[]
  }

  /**
   * job_salary create
   */
  export type job_salaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary
     */
    select?: job_salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary
     */
    omit?: job_salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salaryInclude<ExtArgs> | null
    /**
     * The data needed to create a job_salary.
     */
    data: XOR<job_salaryCreateInput, job_salaryUncheckedCreateInput>
  }

  /**
   * job_salary createMany
   */
  export type job_salaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_salaries.
     */
    data: job_salaryCreateManyInput | job_salaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_salary createManyAndReturn
   */
  export type job_salaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary
     */
    select?: job_salarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary
     */
    omit?: job_salaryOmit<ExtArgs> | null
    /**
     * The data used to create many job_salaries.
     */
    data: job_salaryCreateManyInput | job_salaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_salary update
   */
  export type job_salaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary
     */
    select?: job_salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary
     */
    omit?: job_salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salaryInclude<ExtArgs> | null
    /**
     * The data needed to update a job_salary.
     */
    data: XOR<job_salaryUpdateInput, job_salaryUncheckedUpdateInput>
    /**
     * Choose, which job_salary to update.
     */
    where: job_salaryWhereUniqueInput
  }

  /**
   * job_salary updateMany
   */
  export type job_salaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_salaries.
     */
    data: XOR<job_salaryUpdateManyMutationInput, job_salaryUncheckedUpdateManyInput>
    /**
     * Filter which job_salaries to update
     */
    where?: job_salaryWhereInput
    /**
     * Limit how many job_salaries to update.
     */
    limit?: number
  }

  /**
   * job_salary updateManyAndReturn
   */
  export type job_salaryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary
     */
    select?: job_salarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary
     */
    omit?: job_salaryOmit<ExtArgs> | null
    /**
     * The data used to update job_salaries.
     */
    data: XOR<job_salaryUpdateManyMutationInput, job_salaryUncheckedUpdateManyInput>
    /**
     * Filter which job_salaries to update
     */
    where?: job_salaryWhereInput
    /**
     * Limit how many job_salaries to update.
     */
    limit?: number
  }

  /**
   * job_salary upsert
   */
  export type job_salaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary
     */
    select?: job_salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary
     */
    omit?: job_salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salaryInclude<ExtArgs> | null
    /**
     * The filter to search for the job_salary to update in case it exists.
     */
    where: job_salaryWhereUniqueInput
    /**
     * In case the job_salary found by the `where` argument doesn't exist, create a new job_salary with this data.
     */
    create: XOR<job_salaryCreateInput, job_salaryUncheckedCreateInput>
    /**
     * In case the job_salary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_salaryUpdateInput, job_salaryUncheckedUpdateInput>
  }

  /**
   * job_salary delete
   */
  export type job_salaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary
     */
    select?: job_salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary
     */
    omit?: job_salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salaryInclude<ExtArgs> | null
    /**
     * Filter which job_salary to delete.
     */
    where: job_salaryWhereUniqueInput
  }

  /**
   * job_salary deleteMany
   */
  export type job_salaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_salaries to delete
     */
    where?: job_salaryWhereInput
    /**
     * Limit how many job_salaries to delete.
     */
    limit?: number
  }

  /**
   * job_salary.job_salary_map
   */
  export type job_salary$job_salary_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary_map
     */
    select?: job_salary_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary_map
     */
    omit?: job_salary_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salary_mapInclude<ExtArgs> | null
    where?: job_salary_mapWhereInput
    orderBy?: job_salary_mapOrderByWithRelationInput | job_salary_mapOrderByWithRelationInput[]
    cursor?: job_salary_mapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_salary_mapScalarFieldEnum | Job_salary_mapScalarFieldEnum[]
  }

  /**
   * job_salary without action
   */
  export type job_salaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary
     */
    select?: job_salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary
     */
    omit?: job_salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salaryInclude<ExtArgs> | null
  }


  /**
   * Model job_salary_map
   */

  export type AggregateJob_salary_map = {
    _count: Job_salary_mapCountAggregateOutputType | null
    _avg: Job_salary_mapAvgAggregateOutputType | null
    _sum: Job_salary_mapSumAggregateOutputType | null
    _min: Job_salary_mapMinAggregateOutputType | null
    _max: Job_salary_mapMaxAggregateOutputType | null
  }

  export type Job_salary_mapAvgAggregateOutputType = {
    job_salary_map_id: number | null
    job_id: number | null
    salary_id: number | null
  }

  export type Job_salary_mapSumAggregateOutputType = {
    job_salary_map_id: number | null
    job_id: number | null
    salary_id: number | null
  }

  export type Job_salary_mapMinAggregateOutputType = {
    job_salary_map_id: number | null
    job_salary_map_uuid: string | null
    job_id: number | null
    salary_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_salary_mapMaxAggregateOutputType = {
    job_salary_map_id: number | null
    job_salary_map_uuid: string | null
    job_id: number | null
    salary_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_salary_mapCountAggregateOutputType = {
    job_salary_map_id: number
    job_salary_map_uuid: number
    job_id: number
    salary_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Job_salary_mapAvgAggregateInputType = {
    job_salary_map_id?: true
    job_id?: true
    salary_id?: true
  }

  export type Job_salary_mapSumAggregateInputType = {
    job_salary_map_id?: true
    job_id?: true
    salary_id?: true
  }

  export type Job_salary_mapMinAggregateInputType = {
    job_salary_map_id?: true
    job_salary_map_uuid?: true
    job_id?: true
    salary_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_salary_mapMaxAggregateInputType = {
    job_salary_map_id?: true
    job_salary_map_uuid?: true
    job_id?: true
    salary_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_salary_mapCountAggregateInputType = {
    job_salary_map_id?: true
    job_salary_map_uuid?: true
    job_id?: true
    salary_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Job_salary_mapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_salary_map to aggregate.
     */
    where?: job_salary_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_salary_maps to fetch.
     */
    orderBy?: job_salary_mapOrderByWithRelationInput | job_salary_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_salary_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_salary_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_salary_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_salary_maps
    **/
    _count?: true | Job_salary_mapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Job_salary_mapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Job_salary_mapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_salary_mapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_salary_mapMaxAggregateInputType
  }

  export type GetJob_salary_mapAggregateType<T extends Job_salary_mapAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_salary_map]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_salary_map[P]>
      : GetScalarType<T[P], AggregateJob_salary_map[P]>
  }




  export type job_salary_mapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_salary_mapWhereInput
    orderBy?: job_salary_mapOrderByWithAggregationInput | job_salary_mapOrderByWithAggregationInput[]
    by: Job_salary_mapScalarFieldEnum[] | Job_salary_mapScalarFieldEnum
    having?: job_salary_mapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_salary_mapCountAggregateInputType | true
    _avg?: Job_salary_mapAvgAggregateInputType
    _sum?: Job_salary_mapSumAggregateInputType
    _min?: Job_salary_mapMinAggregateInputType
    _max?: Job_salary_mapMaxAggregateInputType
  }

  export type Job_salary_mapGroupByOutputType = {
    job_salary_map_id: number
    job_salary_map_uuid: string
    job_id: number
    salary_id: number
    created_at: Date
    updated_at: Date
    _count: Job_salary_mapCountAggregateOutputType | null
    _avg: Job_salary_mapAvgAggregateOutputType | null
    _sum: Job_salary_mapSumAggregateOutputType | null
    _min: Job_salary_mapMinAggregateOutputType | null
    _max: Job_salary_mapMaxAggregateOutputType | null
  }

  type GetJob_salary_mapGroupByPayload<T extends job_salary_mapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_salary_mapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_salary_mapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_salary_mapGroupByOutputType[P]>
            : GetScalarType<T[P], Job_salary_mapGroupByOutputType[P]>
        }
      >
    >


  export type job_salary_mapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_salary_map_id?: boolean
    job_salary_map_uuid?: boolean
    job_id?: boolean
    salary_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_salary?: boolean | job_salaryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_salary_map"]>

  export type job_salary_mapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_salary_map_id?: boolean
    job_salary_map_uuid?: boolean
    job_id?: boolean
    salary_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_salary?: boolean | job_salaryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_salary_map"]>

  export type job_salary_mapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_salary_map_id?: boolean
    job_salary_map_uuid?: boolean
    job_id?: boolean
    salary_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_salary?: boolean | job_salaryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_salary_map"]>

  export type job_salary_mapSelectScalar = {
    job_salary_map_id?: boolean
    job_salary_map_uuid?: boolean
    job_id?: boolean
    salary_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type job_salary_mapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"job_salary_map_id" | "job_salary_map_uuid" | "job_id" | "salary_id" | "created_at" | "updated_at", ExtArgs["result"]["job_salary_map"]>
  export type job_salary_mapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_salary?: boolean | job_salaryDefaultArgs<ExtArgs>
  }
  export type job_salary_mapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_salary?: boolean | job_salaryDefaultArgs<ExtArgs>
  }
  export type job_salary_mapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_salary?: boolean | job_salaryDefaultArgs<ExtArgs>
  }

  export type $job_salary_mapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_salary_map"
    objects: {
      job: Prisma.$jobPayload<ExtArgs>
      job_salary: Prisma.$job_salaryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      job_salary_map_id: number
      job_salary_map_uuid: string
      job_id: number
      salary_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["job_salary_map"]>
    composites: {}
  }

  type job_salary_mapGetPayload<S extends boolean | null | undefined | job_salary_mapDefaultArgs> = $Result.GetResult<Prisma.$job_salary_mapPayload, S>

  type job_salary_mapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_salary_mapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_salary_mapCountAggregateInputType | true
    }

  export interface job_salary_mapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_salary_map'], meta: { name: 'job_salary_map' } }
    /**
     * Find zero or one Job_salary_map that matches the filter.
     * @param {job_salary_mapFindUniqueArgs} args - Arguments to find a Job_salary_map
     * @example
     * // Get one Job_salary_map
     * const job_salary_map = await prisma.job_salary_map.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_salary_mapFindUniqueArgs>(args: SelectSubset<T, job_salary_mapFindUniqueArgs<ExtArgs>>): Prisma__job_salary_mapClient<$Result.GetResult<Prisma.$job_salary_mapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_salary_map that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_salary_mapFindUniqueOrThrowArgs} args - Arguments to find a Job_salary_map
     * @example
     * // Get one Job_salary_map
     * const job_salary_map = await prisma.job_salary_map.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_salary_mapFindUniqueOrThrowArgs>(args: SelectSubset<T, job_salary_mapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_salary_mapClient<$Result.GetResult<Prisma.$job_salary_mapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_salary_map that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_salary_mapFindFirstArgs} args - Arguments to find a Job_salary_map
     * @example
     * // Get one Job_salary_map
     * const job_salary_map = await prisma.job_salary_map.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_salary_mapFindFirstArgs>(args?: SelectSubset<T, job_salary_mapFindFirstArgs<ExtArgs>>): Prisma__job_salary_mapClient<$Result.GetResult<Prisma.$job_salary_mapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_salary_map that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_salary_mapFindFirstOrThrowArgs} args - Arguments to find a Job_salary_map
     * @example
     * // Get one Job_salary_map
     * const job_salary_map = await prisma.job_salary_map.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_salary_mapFindFirstOrThrowArgs>(args?: SelectSubset<T, job_salary_mapFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_salary_mapClient<$Result.GetResult<Prisma.$job_salary_mapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_salary_maps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_salary_mapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_salary_maps
     * const job_salary_maps = await prisma.job_salary_map.findMany()
     * 
     * // Get first 10 Job_salary_maps
     * const job_salary_maps = await prisma.job_salary_map.findMany({ take: 10 })
     * 
     * // Only select the `job_salary_map_id`
     * const job_salary_mapWithJob_salary_map_idOnly = await prisma.job_salary_map.findMany({ select: { job_salary_map_id: true } })
     * 
     */
    findMany<T extends job_salary_mapFindManyArgs>(args?: SelectSubset<T, job_salary_mapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_salary_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_salary_map.
     * @param {job_salary_mapCreateArgs} args - Arguments to create a Job_salary_map.
     * @example
     * // Create one Job_salary_map
     * const Job_salary_map = await prisma.job_salary_map.create({
     *   data: {
     *     // ... data to create a Job_salary_map
     *   }
     * })
     * 
     */
    create<T extends job_salary_mapCreateArgs>(args: SelectSubset<T, job_salary_mapCreateArgs<ExtArgs>>): Prisma__job_salary_mapClient<$Result.GetResult<Prisma.$job_salary_mapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_salary_maps.
     * @param {job_salary_mapCreateManyArgs} args - Arguments to create many Job_salary_maps.
     * @example
     * // Create many Job_salary_maps
     * const job_salary_map = await prisma.job_salary_map.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_salary_mapCreateManyArgs>(args?: SelectSubset<T, job_salary_mapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Job_salary_maps and returns the data saved in the database.
     * @param {job_salary_mapCreateManyAndReturnArgs} args - Arguments to create many Job_salary_maps.
     * @example
     * // Create many Job_salary_maps
     * const job_salary_map = await prisma.job_salary_map.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Job_salary_maps and only return the `job_salary_map_id`
     * const job_salary_mapWithJob_salary_map_idOnly = await prisma.job_salary_map.createManyAndReturn({
     *   select: { job_salary_map_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends job_salary_mapCreateManyAndReturnArgs>(args?: SelectSubset<T, job_salary_mapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_salary_mapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job_salary_map.
     * @param {job_salary_mapDeleteArgs} args - Arguments to delete one Job_salary_map.
     * @example
     * // Delete one Job_salary_map
     * const Job_salary_map = await prisma.job_salary_map.delete({
     *   where: {
     *     // ... filter to delete one Job_salary_map
     *   }
     * })
     * 
     */
    delete<T extends job_salary_mapDeleteArgs>(args: SelectSubset<T, job_salary_mapDeleteArgs<ExtArgs>>): Prisma__job_salary_mapClient<$Result.GetResult<Prisma.$job_salary_mapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_salary_map.
     * @param {job_salary_mapUpdateArgs} args - Arguments to update one Job_salary_map.
     * @example
     * // Update one Job_salary_map
     * const job_salary_map = await prisma.job_salary_map.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_salary_mapUpdateArgs>(args: SelectSubset<T, job_salary_mapUpdateArgs<ExtArgs>>): Prisma__job_salary_mapClient<$Result.GetResult<Prisma.$job_salary_mapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_salary_maps.
     * @param {job_salary_mapDeleteManyArgs} args - Arguments to filter Job_salary_maps to delete.
     * @example
     * // Delete a few Job_salary_maps
     * const { count } = await prisma.job_salary_map.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_salary_mapDeleteManyArgs>(args?: SelectSubset<T, job_salary_mapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_salary_maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_salary_mapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_salary_maps
     * const job_salary_map = await prisma.job_salary_map.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_salary_mapUpdateManyArgs>(args: SelectSubset<T, job_salary_mapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_salary_maps and returns the data updated in the database.
     * @param {job_salary_mapUpdateManyAndReturnArgs} args - Arguments to update many Job_salary_maps.
     * @example
     * // Update many Job_salary_maps
     * const job_salary_map = await prisma.job_salary_map.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Job_salary_maps and only return the `job_salary_map_id`
     * const job_salary_mapWithJob_salary_map_idOnly = await prisma.job_salary_map.updateManyAndReturn({
     *   select: { job_salary_map_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends job_salary_mapUpdateManyAndReturnArgs>(args: SelectSubset<T, job_salary_mapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_salary_mapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job_salary_map.
     * @param {job_salary_mapUpsertArgs} args - Arguments to update or create a Job_salary_map.
     * @example
     * // Update or create a Job_salary_map
     * const job_salary_map = await prisma.job_salary_map.upsert({
     *   create: {
     *     // ... data to create a Job_salary_map
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_salary_map we want to update
     *   }
     * })
     */
    upsert<T extends job_salary_mapUpsertArgs>(args: SelectSubset<T, job_salary_mapUpsertArgs<ExtArgs>>): Prisma__job_salary_mapClient<$Result.GetResult<Prisma.$job_salary_mapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_salary_maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_salary_mapCountArgs} args - Arguments to filter Job_salary_maps to count.
     * @example
     * // Count the number of Job_salary_maps
     * const count = await prisma.job_salary_map.count({
     *   where: {
     *     // ... the filter for the Job_salary_maps we want to count
     *   }
     * })
    **/
    count<T extends job_salary_mapCountArgs>(
      args?: Subset<T, job_salary_mapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_salary_mapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_salary_map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_salary_mapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_salary_mapAggregateArgs>(args: Subset<T, Job_salary_mapAggregateArgs>): Prisma.PrismaPromise<GetJob_salary_mapAggregateType<T>>

    /**
     * Group by Job_salary_map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_salary_mapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_salary_mapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_salary_mapGroupByArgs['orderBy'] }
        : { orderBy?: job_salary_mapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_salary_mapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_salary_mapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_salary_map model
   */
  readonly fields: job_salary_mapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_salary_map.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_salary_mapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends jobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobDefaultArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    job_salary<T extends job_salaryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, job_salaryDefaultArgs<ExtArgs>>): Prisma__job_salaryClient<$Result.GetResult<Prisma.$job_salaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_salary_map model
   */
  interface job_salary_mapFieldRefs {
    readonly job_salary_map_id: FieldRef<"job_salary_map", 'Int'>
    readonly job_salary_map_uuid: FieldRef<"job_salary_map", 'String'>
    readonly job_id: FieldRef<"job_salary_map", 'Int'>
    readonly salary_id: FieldRef<"job_salary_map", 'Int'>
    readonly created_at: FieldRef<"job_salary_map", 'DateTime'>
    readonly updated_at: FieldRef<"job_salary_map", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * job_salary_map findUnique
   */
  export type job_salary_mapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary_map
     */
    select?: job_salary_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary_map
     */
    omit?: job_salary_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salary_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_salary_map to fetch.
     */
    where: job_salary_mapWhereUniqueInput
  }

  /**
   * job_salary_map findUniqueOrThrow
   */
  export type job_salary_mapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary_map
     */
    select?: job_salary_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary_map
     */
    omit?: job_salary_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salary_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_salary_map to fetch.
     */
    where: job_salary_mapWhereUniqueInput
  }

  /**
   * job_salary_map findFirst
   */
  export type job_salary_mapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary_map
     */
    select?: job_salary_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary_map
     */
    omit?: job_salary_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salary_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_salary_map to fetch.
     */
    where?: job_salary_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_salary_maps to fetch.
     */
    orderBy?: job_salary_mapOrderByWithRelationInput | job_salary_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_salary_maps.
     */
    cursor?: job_salary_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_salary_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_salary_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_salary_maps.
     */
    distinct?: Job_salary_mapScalarFieldEnum | Job_salary_mapScalarFieldEnum[]
  }

  /**
   * job_salary_map findFirstOrThrow
   */
  export type job_salary_mapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary_map
     */
    select?: job_salary_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary_map
     */
    omit?: job_salary_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salary_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_salary_map to fetch.
     */
    where?: job_salary_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_salary_maps to fetch.
     */
    orderBy?: job_salary_mapOrderByWithRelationInput | job_salary_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_salary_maps.
     */
    cursor?: job_salary_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_salary_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_salary_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_salary_maps.
     */
    distinct?: Job_salary_mapScalarFieldEnum | Job_salary_mapScalarFieldEnum[]
  }

  /**
   * job_salary_map findMany
   */
  export type job_salary_mapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary_map
     */
    select?: job_salary_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary_map
     */
    omit?: job_salary_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salary_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_salary_maps to fetch.
     */
    where?: job_salary_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_salary_maps to fetch.
     */
    orderBy?: job_salary_mapOrderByWithRelationInput | job_salary_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_salary_maps.
     */
    cursor?: job_salary_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_salary_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_salary_maps.
     */
    skip?: number
    distinct?: Job_salary_mapScalarFieldEnum | Job_salary_mapScalarFieldEnum[]
  }

  /**
   * job_salary_map create
   */
  export type job_salary_mapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary_map
     */
    select?: job_salary_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary_map
     */
    omit?: job_salary_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salary_mapInclude<ExtArgs> | null
    /**
     * The data needed to create a job_salary_map.
     */
    data: XOR<job_salary_mapCreateInput, job_salary_mapUncheckedCreateInput>
  }

  /**
   * job_salary_map createMany
   */
  export type job_salary_mapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_salary_maps.
     */
    data: job_salary_mapCreateManyInput | job_salary_mapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_salary_map createManyAndReturn
   */
  export type job_salary_mapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary_map
     */
    select?: job_salary_mapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary_map
     */
    omit?: job_salary_mapOmit<ExtArgs> | null
    /**
     * The data used to create many job_salary_maps.
     */
    data: job_salary_mapCreateManyInput | job_salary_mapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salary_mapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_salary_map update
   */
  export type job_salary_mapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary_map
     */
    select?: job_salary_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary_map
     */
    omit?: job_salary_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salary_mapInclude<ExtArgs> | null
    /**
     * The data needed to update a job_salary_map.
     */
    data: XOR<job_salary_mapUpdateInput, job_salary_mapUncheckedUpdateInput>
    /**
     * Choose, which job_salary_map to update.
     */
    where: job_salary_mapWhereUniqueInput
  }

  /**
   * job_salary_map updateMany
   */
  export type job_salary_mapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_salary_maps.
     */
    data: XOR<job_salary_mapUpdateManyMutationInput, job_salary_mapUncheckedUpdateManyInput>
    /**
     * Filter which job_salary_maps to update
     */
    where?: job_salary_mapWhereInput
    /**
     * Limit how many job_salary_maps to update.
     */
    limit?: number
  }

  /**
   * job_salary_map updateManyAndReturn
   */
  export type job_salary_mapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary_map
     */
    select?: job_salary_mapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary_map
     */
    omit?: job_salary_mapOmit<ExtArgs> | null
    /**
     * The data used to update job_salary_maps.
     */
    data: XOR<job_salary_mapUpdateManyMutationInput, job_salary_mapUncheckedUpdateManyInput>
    /**
     * Filter which job_salary_maps to update
     */
    where?: job_salary_mapWhereInput
    /**
     * Limit how many job_salary_maps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salary_mapIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_salary_map upsert
   */
  export type job_salary_mapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary_map
     */
    select?: job_salary_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary_map
     */
    omit?: job_salary_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salary_mapInclude<ExtArgs> | null
    /**
     * The filter to search for the job_salary_map to update in case it exists.
     */
    where: job_salary_mapWhereUniqueInput
    /**
     * In case the job_salary_map found by the `where` argument doesn't exist, create a new job_salary_map with this data.
     */
    create: XOR<job_salary_mapCreateInput, job_salary_mapUncheckedCreateInput>
    /**
     * In case the job_salary_map was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_salary_mapUpdateInput, job_salary_mapUncheckedUpdateInput>
  }

  /**
   * job_salary_map delete
   */
  export type job_salary_mapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary_map
     */
    select?: job_salary_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary_map
     */
    omit?: job_salary_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salary_mapInclude<ExtArgs> | null
    /**
     * Filter which job_salary_map to delete.
     */
    where: job_salary_mapWhereUniqueInput
  }

  /**
   * job_salary_map deleteMany
   */
  export type job_salary_mapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_salary_maps to delete
     */
    where?: job_salary_mapWhereInput
    /**
     * Limit how many job_salary_maps to delete.
     */
    limit?: number
  }

  /**
   * job_salary_map without action
   */
  export type job_salary_mapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_salary_map
     */
    select?: job_salary_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_salary_map
     */
    omit?: job_salary_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_salary_mapInclude<ExtArgs> | null
  }


  /**
   * Model job_schedule
   */

  export type AggregateJob_schedule = {
    _count: Job_scheduleCountAggregateOutputType | null
    _avg: Job_scheduleAvgAggregateOutputType | null
    _sum: Job_scheduleSumAggregateOutputType | null
    _min: Job_scheduleMinAggregateOutputType | null
    _max: Job_scheduleMaxAggregateOutputType | null
  }

  export type Job_scheduleAvgAggregateOutputType = {
    job_schedule_id: number | null
  }

  export type Job_scheduleSumAggregateOutputType = {
    job_schedule_id: number | null
  }

  export type Job_scheduleMinAggregateOutputType = {
    job_schedule_id: number | null
    job_schedule_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_scheduleMaxAggregateOutputType = {
    job_schedule_id: number | null
    job_schedule_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_scheduleCountAggregateOutputType = {
    job_schedule_id: number
    job_schedule_name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Job_scheduleAvgAggregateInputType = {
    job_schedule_id?: true
  }

  export type Job_scheduleSumAggregateInputType = {
    job_schedule_id?: true
  }

  export type Job_scheduleMinAggregateInputType = {
    job_schedule_id?: true
    job_schedule_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_scheduleMaxAggregateInputType = {
    job_schedule_id?: true
    job_schedule_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_scheduleCountAggregateInputType = {
    job_schedule_id?: true
    job_schedule_name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Job_scheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_schedule to aggregate.
     */
    where?: job_scheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_schedules to fetch.
     */
    orderBy?: job_scheduleOrderByWithRelationInput | job_scheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_scheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_schedules
    **/
    _count?: true | Job_scheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Job_scheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Job_scheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_scheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_scheduleMaxAggregateInputType
  }

  export type GetJob_scheduleAggregateType<T extends Job_scheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_schedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_schedule[P]>
      : GetScalarType<T[P], AggregateJob_schedule[P]>
  }




  export type job_scheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_scheduleWhereInput
    orderBy?: job_scheduleOrderByWithAggregationInput | job_scheduleOrderByWithAggregationInput[]
    by: Job_scheduleScalarFieldEnum[] | Job_scheduleScalarFieldEnum
    having?: job_scheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_scheduleCountAggregateInputType | true
    _avg?: Job_scheduleAvgAggregateInputType
    _sum?: Job_scheduleSumAggregateInputType
    _min?: Job_scheduleMinAggregateInputType
    _max?: Job_scheduleMaxAggregateInputType
  }

  export type Job_scheduleGroupByOutputType = {
    job_schedule_id: number
    job_schedule_name: string
    created_at: Date
    updated_at: Date
    _count: Job_scheduleCountAggregateOutputType | null
    _avg: Job_scheduleAvgAggregateOutputType | null
    _sum: Job_scheduleSumAggregateOutputType | null
    _min: Job_scheduleMinAggregateOutputType | null
    _max: Job_scheduleMaxAggregateOutputType | null
  }

  type GetJob_scheduleGroupByPayload<T extends job_scheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_scheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_scheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_scheduleGroupByOutputType[P]>
            : GetScalarType<T[P], Job_scheduleGroupByOutputType[P]>
        }
      >
    >


  export type job_scheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_schedule_id?: boolean
    job_schedule_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    job_schedule_map?: boolean | job_schedule$job_schedule_mapArgs<ExtArgs>
    _count?: boolean | Job_scheduleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_schedule"]>

  export type job_scheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_schedule_id?: boolean
    job_schedule_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["job_schedule"]>

  export type job_scheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_schedule_id?: boolean
    job_schedule_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["job_schedule"]>

  export type job_scheduleSelectScalar = {
    job_schedule_id?: boolean
    job_schedule_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type job_scheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"job_schedule_id" | "job_schedule_name" | "created_at" | "updated_at", ExtArgs["result"]["job_schedule"]>
  export type job_scheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_schedule_map?: boolean | job_schedule$job_schedule_mapArgs<ExtArgs>
    _count?: boolean | Job_scheduleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type job_scheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type job_scheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $job_schedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_schedule"
    objects: {
      job_schedule_map: Prisma.$job_schedule_mapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      job_schedule_id: number
      job_schedule_name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["job_schedule"]>
    composites: {}
  }

  type job_scheduleGetPayload<S extends boolean | null | undefined | job_scheduleDefaultArgs> = $Result.GetResult<Prisma.$job_schedulePayload, S>

  type job_scheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_scheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_scheduleCountAggregateInputType | true
    }

  export interface job_scheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_schedule'], meta: { name: 'job_schedule' } }
    /**
     * Find zero or one Job_schedule that matches the filter.
     * @param {job_scheduleFindUniqueArgs} args - Arguments to find a Job_schedule
     * @example
     * // Get one Job_schedule
     * const job_schedule = await prisma.job_schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_scheduleFindUniqueArgs>(args: SelectSubset<T, job_scheduleFindUniqueArgs<ExtArgs>>): Prisma__job_scheduleClient<$Result.GetResult<Prisma.$job_schedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_schedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_scheduleFindUniqueOrThrowArgs} args - Arguments to find a Job_schedule
     * @example
     * // Get one Job_schedule
     * const job_schedule = await prisma.job_schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_scheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, job_scheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_scheduleClient<$Result.GetResult<Prisma.$job_schedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_scheduleFindFirstArgs} args - Arguments to find a Job_schedule
     * @example
     * // Get one Job_schedule
     * const job_schedule = await prisma.job_schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_scheduleFindFirstArgs>(args?: SelectSubset<T, job_scheduleFindFirstArgs<ExtArgs>>): Prisma__job_scheduleClient<$Result.GetResult<Prisma.$job_schedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_scheduleFindFirstOrThrowArgs} args - Arguments to find a Job_schedule
     * @example
     * // Get one Job_schedule
     * const job_schedule = await prisma.job_schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_scheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, job_scheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_scheduleClient<$Result.GetResult<Prisma.$job_schedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_scheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_schedules
     * const job_schedules = await prisma.job_schedule.findMany()
     * 
     * // Get first 10 Job_schedules
     * const job_schedules = await prisma.job_schedule.findMany({ take: 10 })
     * 
     * // Only select the `job_schedule_id`
     * const job_scheduleWithJob_schedule_idOnly = await prisma.job_schedule.findMany({ select: { job_schedule_id: true } })
     * 
     */
    findMany<T extends job_scheduleFindManyArgs>(args?: SelectSubset<T, job_scheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_schedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_schedule.
     * @param {job_scheduleCreateArgs} args - Arguments to create a Job_schedule.
     * @example
     * // Create one Job_schedule
     * const Job_schedule = await prisma.job_schedule.create({
     *   data: {
     *     // ... data to create a Job_schedule
     *   }
     * })
     * 
     */
    create<T extends job_scheduleCreateArgs>(args: SelectSubset<T, job_scheduleCreateArgs<ExtArgs>>): Prisma__job_scheduleClient<$Result.GetResult<Prisma.$job_schedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_schedules.
     * @param {job_scheduleCreateManyArgs} args - Arguments to create many Job_schedules.
     * @example
     * // Create many Job_schedules
     * const job_schedule = await prisma.job_schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_scheduleCreateManyArgs>(args?: SelectSubset<T, job_scheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Job_schedules and returns the data saved in the database.
     * @param {job_scheduleCreateManyAndReturnArgs} args - Arguments to create many Job_schedules.
     * @example
     * // Create many Job_schedules
     * const job_schedule = await prisma.job_schedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Job_schedules and only return the `job_schedule_id`
     * const job_scheduleWithJob_schedule_idOnly = await prisma.job_schedule.createManyAndReturn({
     *   select: { job_schedule_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends job_scheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, job_scheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_schedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job_schedule.
     * @param {job_scheduleDeleteArgs} args - Arguments to delete one Job_schedule.
     * @example
     * // Delete one Job_schedule
     * const Job_schedule = await prisma.job_schedule.delete({
     *   where: {
     *     // ... filter to delete one Job_schedule
     *   }
     * })
     * 
     */
    delete<T extends job_scheduleDeleteArgs>(args: SelectSubset<T, job_scheduleDeleteArgs<ExtArgs>>): Prisma__job_scheduleClient<$Result.GetResult<Prisma.$job_schedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_schedule.
     * @param {job_scheduleUpdateArgs} args - Arguments to update one Job_schedule.
     * @example
     * // Update one Job_schedule
     * const job_schedule = await prisma.job_schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_scheduleUpdateArgs>(args: SelectSubset<T, job_scheduleUpdateArgs<ExtArgs>>): Prisma__job_scheduleClient<$Result.GetResult<Prisma.$job_schedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_schedules.
     * @param {job_scheduleDeleteManyArgs} args - Arguments to filter Job_schedules to delete.
     * @example
     * // Delete a few Job_schedules
     * const { count } = await prisma.job_schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_scheduleDeleteManyArgs>(args?: SelectSubset<T, job_scheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_scheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_schedules
     * const job_schedule = await prisma.job_schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_scheduleUpdateManyArgs>(args: SelectSubset<T, job_scheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_schedules and returns the data updated in the database.
     * @param {job_scheduleUpdateManyAndReturnArgs} args - Arguments to update many Job_schedules.
     * @example
     * // Update many Job_schedules
     * const job_schedule = await prisma.job_schedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Job_schedules and only return the `job_schedule_id`
     * const job_scheduleWithJob_schedule_idOnly = await prisma.job_schedule.updateManyAndReturn({
     *   select: { job_schedule_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends job_scheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, job_scheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_schedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job_schedule.
     * @param {job_scheduleUpsertArgs} args - Arguments to update or create a Job_schedule.
     * @example
     * // Update or create a Job_schedule
     * const job_schedule = await prisma.job_schedule.upsert({
     *   create: {
     *     // ... data to create a Job_schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_schedule we want to update
     *   }
     * })
     */
    upsert<T extends job_scheduleUpsertArgs>(args: SelectSubset<T, job_scheduleUpsertArgs<ExtArgs>>): Prisma__job_scheduleClient<$Result.GetResult<Prisma.$job_schedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_scheduleCountArgs} args - Arguments to filter Job_schedules to count.
     * @example
     * // Count the number of Job_schedules
     * const count = await prisma.job_schedule.count({
     *   where: {
     *     // ... the filter for the Job_schedules we want to count
     *   }
     * })
    **/
    count<T extends job_scheduleCountArgs>(
      args?: Subset<T, job_scheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_scheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_scheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_scheduleAggregateArgs>(args: Subset<T, Job_scheduleAggregateArgs>): Prisma.PrismaPromise<GetJob_scheduleAggregateType<T>>

    /**
     * Group by Job_schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_scheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_scheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_scheduleGroupByArgs['orderBy'] }
        : { orderBy?: job_scheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_scheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_scheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_schedule model
   */
  readonly fields: job_scheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_scheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job_schedule_map<T extends job_schedule$job_schedule_mapArgs<ExtArgs> = {}>(args?: Subset<T, job_schedule$job_schedule_mapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_schedule_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_schedule model
   */
  interface job_scheduleFieldRefs {
    readonly job_schedule_id: FieldRef<"job_schedule", 'Int'>
    readonly job_schedule_name: FieldRef<"job_schedule", 'String'>
    readonly created_at: FieldRef<"job_schedule", 'DateTime'>
    readonly updated_at: FieldRef<"job_schedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * job_schedule findUnique
   */
  export type job_scheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule
     */
    select?: job_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule
     */
    omit?: job_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_scheduleInclude<ExtArgs> | null
    /**
     * Filter, which job_schedule to fetch.
     */
    where: job_scheduleWhereUniqueInput
  }

  /**
   * job_schedule findUniqueOrThrow
   */
  export type job_scheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule
     */
    select?: job_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule
     */
    omit?: job_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_scheduleInclude<ExtArgs> | null
    /**
     * Filter, which job_schedule to fetch.
     */
    where: job_scheduleWhereUniqueInput
  }

  /**
   * job_schedule findFirst
   */
  export type job_scheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule
     */
    select?: job_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule
     */
    omit?: job_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_scheduleInclude<ExtArgs> | null
    /**
     * Filter, which job_schedule to fetch.
     */
    where?: job_scheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_schedules to fetch.
     */
    orderBy?: job_scheduleOrderByWithRelationInput | job_scheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_schedules.
     */
    cursor?: job_scheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_schedules.
     */
    distinct?: Job_scheduleScalarFieldEnum | Job_scheduleScalarFieldEnum[]
  }

  /**
   * job_schedule findFirstOrThrow
   */
  export type job_scheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule
     */
    select?: job_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule
     */
    omit?: job_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_scheduleInclude<ExtArgs> | null
    /**
     * Filter, which job_schedule to fetch.
     */
    where?: job_scheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_schedules to fetch.
     */
    orderBy?: job_scheduleOrderByWithRelationInput | job_scheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_schedules.
     */
    cursor?: job_scheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_schedules.
     */
    distinct?: Job_scheduleScalarFieldEnum | Job_scheduleScalarFieldEnum[]
  }

  /**
   * job_schedule findMany
   */
  export type job_scheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule
     */
    select?: job_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule
     */
    omit?: job_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_scheduleInclude<ExtArgs> | null
    /**
     * Filter, which job_schedules to fetch.
     */
    where?: job_scheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_schedules to fetch.
     */
    orderBy?: job_scheduleOrderByWithRelationInput | job_scheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_schedules.
     */
    cursor?: job_scheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_schedules.
     */
    skip?: number
    distinct?: Job_scheduleScalarFieldEnum | Job_scheduleScalarFieldEnum[]
  }

  /**
   * job_schedule create
   */
  export type job_scheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule
     */
    select?: job_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule
     */
    omit?: job_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_scheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a job_schedule.
     */
    data: XOR<job_scheduleCreateInput, job_scheduleUncheckedCreateInput>
  }

  /**
   * job_schedule createMany
   */
  export type job_scheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_schedules.
     */
    data: job_scheduleCreateManyInput | job_scheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_schedule createManyAndReturn
   */
  export type job_scheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule
     */
    select?: job_scheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule
     */
    omit?: job_scheduleOmit<ExtArgs> | null
    /**
     * The data used to create many job_schedules.
     */
    data: job_scheduleCreateManyInput | job_scheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_schedule update
   */
  export type job_scheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule
     */
    select?: job_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule
     */
    omit?: job_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_scheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a job_schedule.
     */
    data: XOR<job_scheduleUpdateInput, job_scheduleUncheckedUpdateInput>
    /**
     * Choose, which job_schedule to update.
     */
    where: job_scheduleWhereUniqueInput
  }

  /**
   * job_schedule updateMany
   */
  export type job_scheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_schedules.
     */
    data: XOR<job_scheduleUpdateManyMutationInput, job_scheduleUncheckedUpdateManyInput>
    /**
     * Filter which job_schedules to update
     */
    where?: job_scheduleWhereInput
    /**
     * Limit how many job_schedules to update.
     */
    limit?: number
  }

  /**
   * job_schedule updateManyAndReturn
   */
  export type job_scheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule
     */
    select?: job_scheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule
     */
    omit?: job_scheduleOmit<ExtArgs> | null
    /**
     * The data used to update job_schedules.
     */
    data: XOR<job_scheduleUpdateManyMutationInput, job_scheduleUncheckedUpdateManyInput>
    /**
     * Filter which job_schedules to update
     */
    where?: job_scheduleWhereInput
    /**
     * Limit how many job_schedules to update.
     */
    limit?: number
  }

  /**
   * job_schedule upsert
   */
  export type job_scheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule
     */
    select?: job_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule
     */
    omit?: job_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_scheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the job_schedule to update in case it exists.
     */
    where: job_scheduleWhereUniqueInput
    /**
     * In case the job_schedule found by the `where` argument doesn't exist, create a new job_schedule with this data.
     */
    create: XOR<job_scheduleCreateInput, job_scheduleUncheckedCreateInput>
    /**
     * In case the job_schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_scheduleUpdateInput, job_scheduleUncheckedUpdateInput>
  }

  /**
   * job_schedule delete
   */
  export type job_scheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule
     */
    select?: job_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule
     */
    omit?: job_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_scheduleInclude<ExtArgs> | null
    /**
     * Filter which job_schedule to delete.
     */
    where: job_scheduleWhereUniqueInput
  }

  /**
   * job_schedule deleteMany
   */
  export type job_scheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_schedules to delete
     */
    where?: job_scheduleWhereInput
    /**
     * Limit how many job_schedules to delete.
     */
    limit?: number
  }

  /**
   * job_schedule.job_schedule_map
   */
  export type job_schedule$job_schedule_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule_map
     */
    select?: job_schedule_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule_map
     */
    omit?: job_schedule_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_schedule_mapInclude<ExtArgs> | null
    where?: job_schedule_mapWhereInput
    orderBy?: job_schedule_mapOrderByWithRelationInput | job_schedule_mapOrderByWithRelationInput[]
    cursor?: job_schedule_mapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_schedule_mapScalarFieldEnum | Job_schedule_mapScalarFieldEnum[]
  }

  /**
   * job_schedule without action
   */
  export type job_scheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule
     */
    select?: job_scheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule
     */
    omit?: job_scheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_scheduleInclude<ExtArgs> | null
  }


  /**
   * Model job_schedule_map
   */

  export type AggregateJob_schedule_map = {
    _count: Job_schedule_mapCountAggregateOutputType | null
    _avg: Job_schedule_mapAvgAggregateOutputType | null
    _sum: Job_schedule_mapSumAggregateOutputType | null
    _min: Job_schedule_mapMinAggregateOutputType | null
    _max: Job_schedule_mapMaxAggregateOutputType | null
  }

  export type Job_schedule_mapAvgAggregateOutputType = {
    job_schedule_map_id: number | null
    job_id: number | null
    schedule_id: number | null
  }

  export type Job_schedule_mapSumAggregateOutputType = {
    job_schedule_map_id: number | null
    job_id: number | null
    schedule_id: number | null
  }

  export type Job_schedule_mapMinAggregateOutputType = {
    job_schedule_map_id: number | null
    job_schedule_map_uuid: string | null
    job_id: number | null
    schedule_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_schedule_mapMaxAggregateOutputType = {
    job_schedule_map_id: number | null
    job_schedule_map_uuid: string | null
    job_id: number | null
    schedule_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_schedule_mapCountAggregateOutputType = {
    job_schedule_map_id: number
    job_schedule_map_uuid: number
    job_id: number
    schedule_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Job_schedule_mapAvgAggregateInputType = {
    job_schedule_map_id?: true
    job_id?: true
    schedule_id?: true
  }

  export type Job_schedule_mapSumAggregateInputType = {
    job_schedule_map_id?: true
    job_id?: true
    schedule_id?: true
  }

  export type Job_schedule_mapMinAggregateInputType = {
    job_schedule_map_id?: true
    job_schedule_map_uuid?: true
    job_id?: true
    schedule_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_schedule_mapMaxAggregateInputType = {
    job_schedule_map_id?: true
    job_schedule_map_uuid?: true
    job_id?: true
    schedule_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_schedule_mapCountAggregateInputType = {
    job_schedule_map_id?: true
    job_schedule_map_uuid?: true
    job_id?: true
    schedule_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Job_schedule_mapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_schedule_map to aggregate.
     */
    where?: job_schedule_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_schedule_maps to fetch.
     */
    orderBy?: job_schedule_mapOrderByWithRelationInput | job_schedule_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_schedule_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_schedule_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_schedule_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_schedule_maps
    **/
    _count?: true | Job_schedule_mapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Job_schedule_mapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Job_schedule_mapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_schedule_mapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_schedule_mapMaxAggregateInputType
  }

  export type GetJob_schedule_mapAggregateType<T extends Job_schedule_mapAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_schedule_map]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_schedule_map[P]>
      : GetScalarType<T[P], AggregateJob_schedule_map[P]>
  }




  export type job_schedule_mapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_schedule_mapWhereInput
    orderBy?: job_schedule_mapOrderByWithAggregationInput | job_schedule_mapOrderByWithAggregationInput[]
    by: Job_schedule_mapScalarFieldEnum[] | Job_schedule_mapScalarFieldEnum
    having?: job_schedule_mapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_schedule_mapCountAggregateInputType | true
    _avg?: Job_schedule_mapAvgAggregateInputType
    _sum?: Job_schedule_mapSumAggregateInputType
    _min?: Job_schedule_mapMinAggregateInputType
    _max?: Job_schedule_mapMaxAggregateInputType
  }

  export type Job_schedule_mapGroupByOutputType = {
    job_schedule_map_id: number
    job_schedule_map_uuid: string
    job_id: number
    schedule_id: number
    created_at: Date
    updated_at: Date
    _count: Job_schedule_mapCountAggregateOutputType | null
    _avg: Job_schedule_mapAvgAggregateOutputType | null
    _sum: Job_schedule_mapSumAggregateOutputType | null
    _min: Job_schedule_mapMinAggregateOutputType | null
    _max: Job_schedule_mapMaxAggregateOutputType | null
  }

  type GetJob_schedule_mapGroupByPayload<T extends job_schedule_mapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_schedule_mapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_schedule_mapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_schedule_mapGroupByOutputType[P]>
            : GetScalarType<T[P], Job_schedule_mapGroupByOutputType[P]>
        }
      >
    >


  export type job_schedule_mapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_schedule_map_id?: boolean
    job_schedule_map_uuid?: boolean
    job_id?: boolean
    schedule_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_schedule?: boolean | job_scheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_schedule_map"]>

  export type job_schedule_mapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_schedule_map_id?: boolean
    job_schedule_map_uuid?: boolean
    job_id?: boolean
    schedule_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_schedule?: boolean | job_scheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_schedule_map"]>

  export type job_schedule_mapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_schedule_map_id?: boolean
    job_schedule_map_uuid?: boolean
    job_id?: boolean
    schedule_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_schedule?: boolean | job_scheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_schedule_map"]>

  export type job_schedule_mapSelectScalar = {
    job_schedule_map_id?: boolean
    job_schedule_map_uuid?: boolean
    job_id?: boolean
    schedule_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type job_schedule_mapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"job_schedule_map_id" | "job_schedule_map_uuid" | "job_id" | "schedule_id" | "created_at" | "updated_at", ExtArgs["result"]["job_schedule_map"]>
  export type job_schedule_mapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_schedule?: boolean | job_scheduleDefaultArgs<ExtArgs>
  }
  export type job_schedule_mapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_schedule?: boolean | job_scheduleDefaultArgs<ExtArgs>
  }
  export type job_schedule_mapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_schedule?: boolean | job_scheduleDefaultArgs<ExtArgs>
  }

  export type $job_schedule_mapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_schedule_map"
    objects: {
      job: Prisma.$jobPayload<ExtArgs>
      job_schedule: Prisma.$job_schedulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      job_schedule_map_id: number
      job_schedule_map_uuid: string
      job_id: number
      schedule_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["job_schedule_map"]>
    composites: {}
  }

  type job_schedule_mapGetPayload<S extends boolean | null | undefined | job_schedule_mapDefaultArgs> = $Result.GetResult<Prisma.$job_schedule_mapPayload, S>

  type job_schedule_mapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_schedule_mapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_schedule_mapCountAggregateInputType | true
    }

  export interface job_schedule_mapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_schedule_map'], meta: { name: 'job_schedule_map' } }
    /**
     * Find zero or one Job_schedule_map that matches the filter.
     * @param {job_schedule_mapFindUniqueArgs} args - Arguments to find a Job_schedule_map
     * @example
     * // Get one Job_schedule_map
     * const job_schedule_map = await prisma.job_schedule_map.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_schedule_mapFindUniqueArgs>(args: SelectSubset<T, job_schedule_mapFindUniqueArgs<ExtArgs>>): Prisma__job_schedule_mapClient<$Result.GetResult<Prisma.$job_schedule_mapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_schedule_map that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_schedule_mapFindUniqueOrThrowArgs} args - Arguments to find a Job_schedule_map
     * @example
     * // Get one Job_schedule_map
     * const job_schedule_map = await prisma.job_schedule_map.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_schedule_mapFindUniqueOrThrowArgs>(args: SelectSubset<T, job_schedule_mapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_schedule_mapClient<$Result.GetResult<Prisma.$job_schedule_mapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_schedule_map that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_schedule_mapFindFirstArgs} args - Arguments to find a Job_schedule_map
     * @example
     * // Get one Job_schedule_map
     * const job_schedule_map = await prisma.job_schedule_map.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_schedule_mapFindFirstArgs>(args?: SelectSubset<T, job_schedule_mapFindFirstArgs<ExtArgs>>): Prisma__job_schedule_mapClient<$Result.GetResult<Prisma.$job_schedule_mapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_schedule_map that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_schedule_mapFindFirstOrThrowArgs} args - Arguments to find a Job_schedule_map
     * @example
     * // Get one Job_schedule_map
     * const job_schedule_map = await prisma.job_schedule_map.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_schedule_mapFindFirstOrThrowArgs>(args?: SelectSubset<T, job_schedule_mapFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_schedule_mapClient<$Result.GetResult<Prisma.$job_schedule_mapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_schedule_maps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_schedule_mapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_schedule_maps
     * const job_schedule_maps = await prisma.job_schedule_map.findMany()
     * 
     * // Get first 10 Job_schedule_maps
     * const job_schedule_maps = await prisma.job_schedule_map.findMany({ take: 10 })
     * 
     * // Only select the `job_schedule_map_id`
     * const job_schedule_mapWithJob_schedule_map_idOnly = await prisma.job_schedule_map.findMany({ select: { job_schedule_map_id: true } })
     * 
     */
    findMany<T extends job_schedule_mapFindManyArgs>(args?: SelectSubset<T, job_schedule_mapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_schedule_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_schedule_map.
     * @param {job_schedule_mapCreateArgs} args - Arguments to create a Job_schedule_map.
     * @example
     * // Create one Job_schedule_map
     * const Job_schedule_map = await prisma.job_schedule_map.create({
     *   data: {
     *     // ... data to create a Job_schedule_map
     *   }
     * })
     * 
     */
    create<T extends job_schedule_mapCreateArgs>(args: SelectSubset<T, job_schedule_mapCreateArgs<ExtArgs>>): Prisma__job_schedule_mapClient<$Result.GetResult<Prisma.$job_schedule_mapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_schedule_maps.
     * @param {job_schedule_mapCreateManyArgs} args - Arguments to create many Job_schedule_maps.
     * @example
     * // Create many Job_schedule_maps
     * const job_schedule_map = await prisma.job_schedule_map.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_schedule_mapCreateManyArgs>(args?: SelectSubset<T, job_schedule_mapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Job_schedule_maps and returns the data saved in the database.
     * @param {job_schedule_mapCreateManyAndReturnArgs} args - Arguments to create many Job_schedule_maps.
     * @example
     * // Create many Job_schedule_maps
     * const job_schedule_map = await prisma.job_schedule_map.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Job_schedule_maps and only return the `job_schedule_map_id`
     * const job_schedule_mapWithJob_schedule_map_idOnly = await prisma.job_schedule_map.createManyAndReturn({
     *   select: { job_schedule_map_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends job_schedule_mapCreateManyAndReturnArgs>(args?: SelectSubset<T, job_schedule_mapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_schedule_mapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job_schedule_map.
     * @param {job_schedule_mapDeleteArgs} args - Arguments to delete one Job_schedule_map.
     * @example
     * // Delete one Job_schedule_map
     * const Job_schedule_map = await prisma.job_schedule_map.delete({
     *   where: {
     *     // ... filter to delete one Job_schedule_map
     *   }
     * })
     * 
     */
    delete<T extends job_schedule_mapDeleteArgs>(args: SelectSubset<T, job_schedule_mapDeleteArgs<ExtArgs>>): Prisma__job_schedule_mapClient<$Result.GetResult<Prisma.$job_schedule_mapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_schedule_map.
     * @param {job_schedule_mapUpdateArgs} args - Arguments to update one Job_schedule_map.
     * @example
     * // Update one Job_schedule_map
     * const job_schedule_map = await prisma.job_schedule_map.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_schedule_mapUpdateArgs>(args: SelectSubset<T, job_schedule_mapUpdateArgs<ExtArgs>>): Prisma__job_schedule_mapClient<$Result.GetResult<Prisma.$job_schedule_mapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_schedule_maps.
     * @param {job_schedule_mapDeleteManyArgs} args - Arguments to filter Job_schedule_maps to delete.
     * @example
     * // Delete a few Job_schedule_maps
     * const { count } = await prisma.job_schedule_map.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_schedule_mapDeleteManyArgs>(args?: SelectSubset<T, job_schedule_mapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_schedule_maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_schedule_mapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_schedule_maps
     * const job_schedule_map = await prisma.job_schedule_map.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_schedule_mapUpdateManyArgs>(args: SelectSubset<T, job_schedule_mapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_schedule_maps and returns the data updated in the database.
     * @param {job_schedule_mapUpdateManyAndReturnArgs} args - Arguments to update many Job_schedule_maps.
     * @example
     * // Update many Job_schedule_maps
     * const job_schedule_map = await prisma.job_schedule_map.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Job_schedule_maps and only return the `job_schedule_map_id`
     * const job_schedule_mapWithJob_schedule_map_idOnly = await prisma.job_schedule_map.updateManyAndReturn({
     *   select: { job_schedule_map_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends job_schedule_mapUpdateManyAndReturnArgs>(args: SelectSubset<T, job_schedule_mapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_schedule_mapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job_schedule_map.
     * @param {job_schedule_mapUpsertArgs} args - Arguments to update or create a Job_schedule_map.
     * @example
     * // Update or create a Job_schedule_map
     * const job_schedule_map = await prisma.job_schedule_map.upsert({
     *   create: {
     *     // ... data to create a Job_schedule_map
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_schedule_map we want to update
     *   }
     * })
     */
    upsert<T extends job_schedule_mapUpsertArgs>(args: SelectSubset<T, job_schedule_mapUpsertArgs<ExtArgs>>): Prisma__job_schedule_mapClient<$Result.GetResult<Prisma.$job_schedule_mapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_schedule_maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_schedule_mapCountArgs} args - Arguments to filter Job_schedule_maps to count.
     * @example
     * // Count the number of Job_schedule_maps
     * const count = await prisma.job_schedule_map.count({
     *   where: {
     *     // ... the filter for the Job_schedule_maps we want to count
     *   }
     * })
    **/
    count<T extends job_schedule_mapCountArgs>(
      args?: Subset<T, job_schedule_mapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_schedule_mapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_schedule_map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_schedule_mapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_schedule_mapAggregateArgs>(args: Subset<T, Job_schedule_mapAggregateArgs>): Prisma.PrismaPromise<GetJob_schedule_mapAggregateType<T>>

    /**
     * Group by Job_schedule_map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_schedule_mapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_schedule_mapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_schedule_mapGroupByArgs['orderBy'] }
        : { orderBy?: job_schedule_mapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_schedule_mapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_schedule_mapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_schedule_map model
   */
  readonly fields: job_schedule_mapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_schedule_map.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_schedule_mapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends jobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobDefaultArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    job_schedule<T extends job_scheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, job_scheduleDefaultArgs<ExtArgs>>): Prisma__job_scheduleClient<$Result.GetResult<Prisma.$job_schedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_schedule_map model
   */
  interface job_schedule_mapFieldRefs {
    readonly job_schedule_map_id: FieldRef<"job_schedule_map", 'Int'>
    readonly job_schedule_map_uuid: FieldRef<"job_schedule_map", 'String'>
    readonly job_id: FieldRef<"job_schedule_map", 'Int'>
    readonly schedule_id: FieldRef<"job_schedule_map", 'Int'>
    readonly created_at: FieldRef<"job_schedule_map", 'DateTime'>
    readonly updated_at: FieldRef<"job_schedule_map", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * job_schedule_map findUnique
   */
  export type job_schedule_mapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule_map
     */
    select?: job_schedule_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule_map
     */
    omit?: job_schedule_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_schedule_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_schedule_map to fetch.
     */
    where: job_schedule_mapWhereUniqueInput
  }

  /**
   * job_schedule_map findUniqueOrThrow
   */
  export type job_schedule_mapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule_map
     */
    select?: job_schedule_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule_map
     */
    omit?: job_schedule_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_schedule_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_schedule_map to fetch.
     */
    where: job_schedule_mapWhereUniqueInput
  }

  /**
   * job_schedule_map findFirst
   */
  export type job_schedule_mapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule_map
     */
    select?: job_schedule_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule_map
     */
    omit?: job_schedule_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_schedule_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_schedule_map to fetch.
     */
    where?: job_schedule_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_schedule_maps to fetch.
     */
    orderBy?: job_schedule_mapOrderByWithRelationInput | job_schedule_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_schedule_maps.
     */
    cursor?: job_schedule_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_schedule_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_schedule_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_schedule_maps.
     */
    distinct?: Job_schedule_mapScalarFieldEnum | Job_schedule_mapScalarFieldEnum[]
  }

  /**
   * job_schedule_map findFirstOrThrow
   */
  export type job_schedule_mapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule_map
     */
    select?: job_schedule_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule_map
     */
    omit?: job_schedule_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_schedule_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_schedule_map to fetch.
     */
    where?: job_schedule_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_schedule_maps to fetch.
     */
    orderBy?: job_schedule_mapOrderByWithRelationInput | job_schedule_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_schedule_maps.
     */
    cursor?: job_schedule_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_schedule_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_schedule_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_schedule_maps.
     */
    distinct?: Job_schedule_mapScalarFieldEnum | Job_schedule_mapScalarFieldEnum[]
  }

  /**
   * job_schedule_map findMany
   */
  export type job_schedule_mapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule_map
     */
    select?: job_schedule_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule_map
     */
    omit?: job_schedule_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_schedule_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_schedule_maps to fetch.
     */
    where?: job_schedule_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_schedule_maps to fetch.
     */
    orderBy?: job_schedule_mapOrderByWithRelationInput | job_schedule_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_schedule_maps.
     */
    cursor?: job_schedule_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_schedule_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_schedule_maps.
     */
    skip?: number
    distinct?: Job_schedule_mapScalarFieldEnum | Job_schedule_mapScalarFieldEnum[]
  }

  /**
   * job_schedule_map create
   */
  export type job_schedule_mapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule_map
     */
    select?: job_schedule_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule_map
     */
    omit?: job_schedule_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_schedule_mapInclude<ExtArgs> | null
    /**
     * The data needed to create a job_schedule_map.
     */
    data: XOR<job_schedule_mapCreateInput, job_schedule_mapUncheckedCreateInput>
  }

  /**
   * job_schedule_map createMany
   */
  export type job_schedule_mapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_schedule_maps.
     */
    data: job_schedule_mapCreateManyInput | job_schedule_mapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_schedule_map createManyAndReturn
   */
  export type job_schedule_mapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule_map
     */
    select?: job_schedule_mapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule_map
     */
    omit?: job_schedule_mapOmit<ExtArgs> | null
    /**
     * The data used to create many job_schedule_maps.
     */
    data: job_schedule_mapCreateManyInput | job_schedule_mapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_schedule_mapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_schedule_map update
   */
  export type job_schedule_mapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule_map
     */
    select?: job_schedule_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule_map
     */
    omit?: job_schedule_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_schedule_mapInclude<ExtArgs> | null
    /**
     * The data needed to update a job_schedule_map.
     */
    data: XOR<job_schedule_mapUpdateInput, job_schedule_mapUncheckedUpdateInput>
    /**
     * Choose, which job_schedule_map to update.
     */
    where: job_schedule_mapWhereUniqueInput
  }

  /**
   * job_schedule_map updateMany
   */
  export type job_schedule_mapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_schedule_maps.
     */
    data: XOR<job_schedule_mapUpdateManyMutationInput, job_schedule_mapUncheckedUpdateManyInput>
    /**
     * Filter which job_schedule_maps to update
     */
    where?: job_schedule_mapWhereInput
    /**
     * Limit how many job_schedule_maps to update.
     */
    limit?: number
  }

  /**
   * job_schedule_map updateManyAndReturn
   */
  export type job_schedule_mapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule_map
     */
    select?: job_schedule_mapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule_map
     */
    omit?: job_schedule_mapOmit<ExtArgs> | null
    /**
     * The data used to update job_schedule_maps.
     */
    data: XOR<job_schedule_mapUpdateManyMutationInput, job_schedule_mapUncheckedUpdateManyInput>
    /**
     * Filter which job_schedule_maps to update
     */
    where?: job_schedule_mapWhereInput
    /**
     * Limit how many job_schedule_maps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_schedule_mapIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_schedule_map upsert
   */
  export type job_schedule_mapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule_map
     */
    select?: job_schedule_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule_map
     */
    omit?: job_schedule_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_schedule_mapInclude<ExtArgs> | null
    /**
     * The filter to search for the job_schedule_map to update in case it exists.
     */
    where: job_schedule_mapWhereUniqueInput
    /**
     * In case the job_schedule_map found by the `where` argument doesn't exist, create a new job_schedule_map with this data.
     */
    create: XOR<job_schedule_mapCreateInput, job_schedule_mapUncheckedCreateInput>
    /**
     * In case the job_schedule_map was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_schedule_mapUpdateInput, job_schedule_mapUncheckedUpdateInput>
  }

  /**
   * job_schedule_map delete
   */
  export type job_schedule_mapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule_map
     */
    select?: job_schedule_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule_map
     */
    omit?: job_schedule_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_schedule_mapInclude<ExtArgs> | null
    /**
     * Filter which job_schedule_map to delete.
     */
    where: job_schedule_mapWhereUniqueInput
  }

  /**
   * job_schedule_map deleteMany
   */
  export type job_schedule_mapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_schedule_maps to delete
     */
    where?: job_schedule_mapWhereInput
    /**
     * Limit how many job_schedule_maps to delete.
     */
    limit?: number
  }

  /**
   * job_schedule_map without action
   */
  export type job_schedule_mapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_schedule_map
     */
    select?: job_schedule_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_schedule_map
     */
    omit?: job_schedule_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_schedule_mapInclude<ExtArgs> | null
  }


  /**
   * Model job_skill
   */

  export type AggregateJob_skill = {
    _count: Job_skillCountAggregateOutputType | null
    _avg: Job_skillAvgAggregateOutputType | null
    _sum: Job_skillSumAggregateOutputType | null
    _min: Job_skillMinAggregateOutputType | null
    _max: Job_skillMaxAggregateOutputType | null
  }

  export type Job_skillAvgAggregateOutputType = {
    job_skill_id: number | null
  }

  export type Job_skillSumAggregateOutputType = {
    job_skill_id: number | null
  }

  export type Job_skillMinAggregateOutputType = {
    job_skill_id: number | null
    job_skill_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_skillMaxAggregateOutputType = {
    job_skill_id: number | null
    job_skill_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_skillCountAggregateOutputType = {
    job_skill_id: number
    job_skill_name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Job_skillAvgAggregateInputType = {
    job_skill_id?: true
  }

  export type Job_skillSumAggregateInputType = {
    job_skill_id?: true
  }

  export type Job_skillMinAggregateInputType = {
    job_skill_id?: true
    job_skill_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_skillMaxAggregateInputType = {
    job_skill_id?: true
    job_skill_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_skillCountAggregateInputType = {
    job_skill_id?: true
    job_skill_name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Job_skillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_skill to aggregate.
     */
    where?: job_skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_skills to fetch.
     */
    orderBy?: job_skillOrderByWithRelationInput | job_skillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_skills
    **/
    _count?: true | Job_skillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Job_skillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Job_skillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_skillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_skillMaxAggregateInputType
  }

  export type GetJob_skillAggregateType<T extends Job_skillAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_skill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_skill[P]>
      : GetScalarType<T[P], AggregateJob_skill[P]>
  }




  export type job_skillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_skillWhereInput
    orderBy?: job_skillOrderByWithAggregationInput | job_skillOrderByWithAggregationInput[]
    by: Job_skillScalarFieldEnum[] | Job_skillScalarFieldEnum
    having?: job_skillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_skillCountAggregateInputType | true
    _avg?: Job_skillAvgAggregateInputType
    _sum?: Job_skillSumAggregateInputType
    _min?: Job_skillMinAggregateInputType
    _max?: Job_skillMaxAggregateInputType
  }

  export type Job_skillGroupByOutputType = {
    job_skill_id: number
    job_skill_name: string
    created_at: Date
    updated_at: Date
    _count: Job_skillCountAggregateOutputType | null
    _avg: Job_skillAvgAggregateOutputType | null
    _sum: Job_skillSumAggregateOutputType | null
    _min: Job_skillMinAggregateOutputType | null
    _max: Job_skillMaxAggregateOutputType | null
  }

  type GetJob_skillGroupByPayload<T extends job_skillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_skillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_skillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_skillGroupByOutputType[P]>
            : GetScalarType<T[P], Job_skillGroupByOutputType[P]>
        }
      >
    >


  export type job_skillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_skill_id?: boolean
    job_skill_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    job_skill_map?: boolean | job_skill$job_skill_mapArgs<ExtArgs>
    _count?: boolean | Job_skillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_skill"]>

  export type job_skillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_skill_id?: boolean
    job_skill_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["job_skill"]>

  export type job_skillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_skill_id?: boolean
    job_skill_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["job_skill"]>

  export type job_skillSelectScalar = {
    job_skill_id?: boolean
    job_skill_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type job_skillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"job_skill_id" | "job_skill_name" | "created_at" | "updated_at", ExtArgs["result"]["job_skill"]>
  export type job_skillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_skill_map?: boolean | job_skill$job_skill_mapArgs<ExtArgs>
    _count?: boolean | Job_skillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type job_skillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type job_skillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $job_skillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_skill"
    objects: {
      job_skill_map: Prisma.$job_skill_mapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      job_skill_id: number
      job_skill_name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["job_skill"]>
    composites: {}
  }

  type job_skillGetPayload<S extends boolean | null | undefined | job_skillDefaultArgs> = $Result.GetResult<Prisma.$job_skillPayload, S>

  type job_skillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_skillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_skillCountAggregateInputType | true
    }

  export interface job_skillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_skill'], meta: { name: 'job_skill' } }
    /**
     * Find zero or one Job_skill that matches the filter.
     * @param {job_skillFindUniqueArgs} args - Arguments to find a Job_skill
     * @example
     * // Get one Job_skill
     * const job_skill = await prisma.job_skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_skillFindUniqueArgs>(args: SelectSubset<T, job_skillFindUniqueArgs<ExtArgs>>): Prisma__job_skillClient<$Result.GetResult<Prisma.$job_skillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_skill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_skillFindUniqueOrThrowArgs} args - Arguments to find a Job_skill
     * @example
     * // Get one Job_skill
     * const job_skill = await prisma.job_skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_skillFindUniqueOrThrowArgs>(args: SelectSubset<T, job_skillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_skillClient<$Result.GetResult<Prisma.$job_skillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_skillFindFirstArgs} args - Arguments to find a Job_skill
     * @example
     * // Get one Job_skill
     * const job_skill = await prisma.job_skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_skillFindFirstArgs>(args?: SelectSubset<T, job_skillFindFirstArgs<ExtArgs>>): Prisma__job_skillClient<$Result.GetResult<Prisma.$job_skillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_skillFindFirstOrThrowArgs} args - Arguments to find a Job_skill
     * @example
     * // Get one Job_skill
     * const job_skill = await prisma.job_skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_skillFindFirstOrThrowArgs>(args?: SelectSubset<T, job_skillFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_skillClient<$Result.GetResult<Prisma.$job_skillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_skillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_skills
     * const job_skills = await prisma.job_skill.findMany()
     * 
     * // Get first 10 Job_skills
     * const job_skills = await prisma.job_skill.findMany({ take: 10 })
     * 
     * // Only select the `job_skill_id`
     * const job_skillWithJob_skill_idOnly = await prisma.job_skill.findMany({ select: { job_skill_id: true } })
     * 
     */
    findMany<T extends job_skillFindManyArgs>(args?: SelectSubset<T, job_skillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_skillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_skill.
     * @param {job_skillCreateArgs} args - Arguments to create a Job_skill.
     * @example
     * // Create one Job_skill
     * const Job_skill = await prisma.job_skill.create({
     *   data: {
     *     // ... data to create a Job_skill
     *   }
     * })
     * 
     */
    create<T extends job_skillCreateArgs>(args: SelectSubset<T, job_skillCreateArgs<ExtArgs>>): Prisma__job_skillClient<$Result.GetResult<Prisma.$job_skillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_skills.
     * @param {job_skillCreateManyArgs} args - Arguments to create many Job_skills.
     * @example
     * // Create many Job_skills
     * const job_skill = await prisma.job_skill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_skillCreateManyArgs>(args?: SelectSubset<T, job_skillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Job_skills and returns the data saved in the database.
     * @param {job_skillCreateManyAndReturnArgs} args - Arguments to create many Job_skills.
     * @example
     * // Create many Job_skills
     * const job_skill = await prisma.job_skill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Job_skills and only return the `job_skill_id`
     * const job_skillWithJob_skill_idOnly = await prisma.job_skill.createManyAndReturn({
     *   select: { job_skill_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends job_skillCreateManyAndReturnArgs>(args?: SelectSubset<T, job_skillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_skillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job_skill.
     * @param {job_skillDeleteArgs} args - Arguments to delete one Job_skill.
     * @example
     * // Delete one Job_skill
     * const Job_skill = await prisma.job_skill.delete({
     *   where: {
     *     // ... filter to delete one Job_skill
     *   }
     * })
     * 
     */
    delete<T extends job_skillDeleteArgs>(args: SelectSubset<T, job_skillDeleteArgs<ExtArgs>>): Prisma__job_skillClient<$Result.GetResult<Prisma.$job_skillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_skill.
     * @param {job_skillUpdateArgs} args - Arguments to update one Job_skill.
     * @example
     * // Update one Job_skill
     * const job_skill = await prisma.job_skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_skillUpdateArgs>(args: SelectSubset<T, job_skillUpdateArgs<ExtArgs>>): Prisma__job_skillClient<$Result.GetResult<Prisma.$job_skillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_skills.
     * @param {job_skillDeleteManyArgs} args - Arguments to filter Job_skills to delete.
     * @example
     * // Delete a few Job_skills
     * const { count } = await prisma.job_skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_skillDeleteManyArgs>(args?: SelectSubset<T, job_skillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_skillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_skills
     * const job_skill = await prisma.job_skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_skillUpdateManyArgs>(args: SelectSubset<T, job_skillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_skills and returns the data updated in the database.
     * @param {job_skillUpdateManyAndReturnArgs} args - Arguments to update many Job_skills.
     * @example
     * // Update many Job_skills
     * const job_skill = await prisma.job_skill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Job_skills and only return the `job_skill_id`
     * const job_skillWithJob_skill_idOnly = await prisma.job_skill.updateManyAndReturn({
     *   select: { job_skill_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends job_skillUpdateManyAndReturnArgs>(args: SelectSubset<T, job_skillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_skillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job_skill.
     * @param {job_skillUpsertArgs} args - Arguments to update or create a Job_skill.
     * @example
     * // Update or create a Job_skill
     * const job_skill = await prisma.job_skill.upsert({
     *   create: {
     *     // ... data to create a Job_skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_skill we want to update
     *   }
     * })
     */
    upsert<T extends job_skillUpsertArgs>(args: SelectSubset<T, job_skillUpsertArgs<ExtArgs>>): Prisma__job_skillClient<$Result.GetResult<Prisma.$job_skillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_skillCountArgs} args - Arguments to filter Job_skills to count.
     * @example
     * // Count the number of Job_skills
     * const count = await prisma.job_skill.count({
     *   where: {
     *     // ... the filter for the Job_skills we want to count
     *   }
     * })
    **/
    count<T extends job_skillCountArgs>(
      args?: Subset<T, job_skillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_skillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_skillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_skillAggregateArgs>(args: Subset<T, Job_skillAggregateArgs>): Prisma.PrismaPromise<GetJob_skillAggregateType<T>>

    /**
     * Group by Job_skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_skillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_skillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_skillGroupByArgs['orderBy'] }
        : { orderBy?: job_skillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_skillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_skillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_skill model
   */
  readonly fields: job_skillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_skillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job_skill_map<T extends job_skill$job_skill_mapArgs<ExtArgs> = {}>(args?: Subset<T, job_skill$job_skill_mapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_skill_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_skill model
   */
  interface job_skillFieldRefs {
    readonly job_skill_id: FieldRef<"job_skill", 'Int'>
    readonly job_skill_name: FieldRef<"job_skill", 'String'>
    readonly created_at: FieldRef<"job_skill", 'DateTime'>
    readonly updated_at: FieldRef<"job_skill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * job_skill findUnique
   */
  export type job_skillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill
     */
    select?: job_skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill
     */
    omit?: job_skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skillInclude<ExtArgs> | null
    /**
     * Filter, which job_skill to fetch.
     */
    where: job_skillWhereUniqueInput
  }

  /**
   * job_skill findUniqueOrThrow
   */
  export type job_skillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill
     */
    select?: job_skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill
     */
    omit?: job_skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skillInclude<ExtArgs> | null
    /**
     * Filter, which job_skill to fetch.
     */
    where: job_skillWhereUniqueInput
  }

  /**
   * job_skill findFirst
   */
  export type job_skillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill
     */
    select?: job_skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill
     */
    omit?: job_skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skillInclude<ExtArgs> | null
    /**
     * Filter, which job_skill to fetch.
     */
    where?: job_skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_skills to fetch.
     */
    orderBy?: job_skillOrderByWithRelationInput | job_skillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_skills.
     */
    cursor?: job_skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_skills.
     */
    distinct?: Job_skillScalarFieldEnum | Job_skillScalarFieldEnum[]
  }

  /**
   * job_skill findFirstOrThrow
   */
  export type job_skillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill
     */
    select?: job_skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill
     */
    omit?: job_skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skillInclude<ExtArgs> | null
    /**
     * Filter, which job_skill to fetch.
     */
    where?: job_skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_skills to fetch.
     */
    orderBy?: job_skillOrderByWithRelationInput | job_skillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_skills.
     */
    cursor?: job_skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_skills.
     */
    distinct?: Job_skillScalarFieldEnum | Job_skillScalarFieldEnum[]
  }

  /**
   * job_skill findMany
   */
  export type job_skillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill
     */
    select?: job_skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill
     */
    omit?: job_skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skillInclude<ExtArgs> | null
    /**
     * Filter, which job_skills to fetch.
     */
    where?: job_skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_skills to fetch.
     */
    orderBy?: job_skillOrderByWithRelationInput | job_skillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_skills.
     */
    cursor?: job_skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_skills.
     */
    skip?: number
    distinct?: Job_skillScalarFieldEnum | Job_skillScalarFieldEnum[]
  }

  /**
   * job_skill create
   */
  export type job_skillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill
     */
    select?: job_skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill
     */
    omit?: job_skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skillInclude<ExtArgs> | null
    /**
     * The data needed to create a job_skill.
     */
    data: XOR<job_skillCreateInput, job_skillUncheckedCreateInput>
  }

  /**
   * job_skill createMany
   */
  export type job_skillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_skills.
     */
    data: job_skillCreateManyInput | job_skillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_skill createManyAndReturn
   */
  export type job_skillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill
     */
    select?: job_skillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill
     */
    omit?: job_skillOmit<ExtArgs> | null
    /**
     * The data used to create many job_skills.
     */
    data: job_skillCreateManyInput | job_skillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_skill update
   */
  export type job_skillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill
     */
    select?: job_skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill
     */
    omit?: job_skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skillInclude<ExtArgs> | null
    /**
     * The data needed to update a job_skill.
     */
    data: XOR<job_skillUpdateInput, job_skillUncheckedUpdateInput>
    /**
     * Choose, which job_skill to update.
     */
    where: job_skillWhereUniqueInput
  }

  /**
   * job_skill updateMany
   */
  export type job_skillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_skills.
     */
    data: XOR<job_skillUpdateManyMutationInput, job_skillUncheckedUpdateManyInput>
    /**
     * Filter which job_skills to update
     */
    where?: job_skillWhereInput
    /**
     * Limit how many job_skills to update.
     */
    limit?: number
  }

  /**
   * job_skill updateManyAndReturn
   */
  export type job_skillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill
     */
    select?: job_skillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill
     */
    omit?: job_skillOmit<ExtArgs> | null
    /**
     * The data used to update job_skills.
     */
    data: XOR<job_skillUpdateManyMutationInput, job_skillUncheckedUpdateManyInput>
    /**
     * Filter which job_skills to update
     */
    where?: job_skillWhereInput
    /**
     * Limit how many job_skills to update.
     */
    limit?: number
  }

  /**
   * job_skill upsert
   */
  export type job_skillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill
     */
    select?: job_skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill
     */
    omit?: job_skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skillInclude<ExtArgs> | null
    /**
     * The filter to search for the job_skill to update in case it exists.
     */
    where: job_skillWhereUniqueInput
    /**
     * In case the job_skill found by the `where` argument doesn't exist, create a new job_skill with this data.
     */
    create: XOR<job_skillCreateInput, job_skillUncheckedCreateInput>
    /**
     * In case the job_skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_skillUpdateInput, job_skillUncheckedUpdateInput>
  }

  /**
   * job_skill delete
   */
  export type job_skillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill
     */
    select?: job_skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill
     */
    omit?: job_skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skillInclude<ExtArgs> | null
    /**
     * Filter which job_skill to delete.
     */
    where: job_skillWhereUniqueInput
  }

  /**
   * job_skill deleteMany
   */
  export type job_skillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_skills to delete
     */
    where?: job_skillWhereInput
    /**
     * Limit how many job_skills to delete.
     */
    limit?: number
  }

  /**
   * job_skill.job_skill_map
   */
  export type job_skill$job_skill_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill_map
     */
    select?: job_skill_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill_map
     */
    omit?: job_skill_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skill_mapInclude<ExtArgs> | null
    where?: job_skill_mapWhereInput
    orderBy?: job_skill_mapOrderByWithRelationInput | job_skill_mapOrderByWithRelationInput[]
    cursor?: job_skill_mapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_skill_mapScalarFieldEnum | Job_skill_mapScalarFieldEnum[]
  }

  /**
   * job_skill without action
   */
  export type job_skillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill
     */
    select?: job_skillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill
     */
    omit?: job_skillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skillInclude<ExtArgs> | null
  }


  /**
   * Model job_skill_map
   */

  export type AggregateJob_skill_map = {
    _count: Job_skill_mapCountAggregateOutputType | null
    _avg: Job_skill_mapAvgAggregateOutputType | null
    _sum: Job_skill_mapSumAggregateOutputType | null
    _min: Job_skill_mapMinAggregateOutputType | null
    _max: Job_skill_mapMaxAggregateOutputType | null
  }

  export type Job_skill_mapAvgAggregateOutputType = {
    job_skill_map_id: number | null
    job_id: number | null
    skill_id: number | null
  }

  export type Job_skill_mapSumAggregateOutputType = {
    job_skill_map_id: number | null
    job_id: number | null
    skill_id: number | null
  }

  export type Job_skill_mapMinAggregateOutputType = {
    job_skill_map_id: number | null
    job_skill_map_uuid: string | null
    job_id: number | null
    skill_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_skill_mapMaxAggregateOutputType = {
    job_skill_map_id: number | null
    job_skill_map_uuid: string | null
    job_id: number | null
    skill_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_skill_mapCountAggregateOutputType = {
    job_skill_map_id: number
    job_skill_map_uuid: number
    job_id: number
    skill_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Job_skill_mapAvgAggregateInputType = {
    job_skill_map_id?: true
    job_id?: true
    skill_id?: true
  }

  export type Job_skill_mapSumAggregateInputType = {
    job_skill_map_id?: true
    job_id?: true
    skill_id?: true
  }

  export type Job_skill_mapMinAggregateInputType = {
    job_skill_map_id?: true
    job_skill_map_uuid?: true
    job_id?: true
    skill_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_skill_mapMaxAggregateInputType = {
    job_skill_map_id?: true
    job_skill_map_uuid?: true
    job_id?: true
    skill_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_skill_mapCountAggregateInputType = {
    job_skill_map_id?: true
    job_skill_map_uuid?: true
    job_id?: true
    skill_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Job_skill_mapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_skill_map to aggregate.
     */
    where?: job_skill_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_skill_maps to fetch.
     */
    orderBy?: job_skill_mapOrderByWithRelationInput | job_skill_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_skill_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_skill_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_skill_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_skill_maps
    **/
    _count?: true | Job_skill_mapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Job_skill_mapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Job_skill_mapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_skill_mapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_skill_mapMaxAggregateInputType
  }

  export type GetJob_skill_mapAggregateType<T extends Job_skill_mapAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_skill_map]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_skill_map[P]>
      : GetScalarType<T[P], AggregateJob_skill_map[P]>
  }




  export type job_skill_mapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_skill_mapWhereInput
    orderBy?: job_skill_mapOrderByWithAggregationInput | job_skill_mapOrderByWithAggregationInput[]
    by: Job_skill_mapScalarFieldEnum[] | Job_skill_mapScalarFieldEnum
    having?: job_skill_mapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_skill_mapCountAggregateInputType | true
    _avg?: Job_skill_mapAvgAggregateInputType
    _sum?: Job_skill_mapSumAggregateInputType
    _min?: Job_skill_mapMinAggregateInputType
    _max?: Job_skill_mapMaxAggregateInputType
  }

  export type Job_skill_mapGroupByOutputType = {
    job_skill_map_id: number
    job_skill_map_uuid: string
    job_id: number
    skill_id: number
    created_at: Date
    updated_at: Date
    _count: Job_skill_mapCountAggregateOutputType | null
    _avg: Job_skill_mapAvgAggregateOutputType | null
    _sum: Job_skill_mapSumAggregateOutputType | null
    _min: Job_skill_mapMinAggregateOutputType | null
    _max: Job_skill_mapMaxAggregateOutputType | null
  }

  type GetJob_skill_mapGroupByPayload<T extends job_skill_mapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_skill_mapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_skill_mapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_skill_mapGroupByOutputType[P]>
            : GetScalarType<T[P], Job_skill_mapGroupByOutputType[P]>
        }
      >
    >


  export type job_skill_mapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_skill_map_id?: boolean
    job_skill_map_uuid?: boolean
    job_id?: boolean
    skill_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_skill?: boolean | job_skillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_skill_map"]>

  export type job_skill_mapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_skill_map_id?: boolean
    job_skill_map_uuid?: boolean
    job_id?: boolean
    skill_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_skill?: boolean | job_skillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_skill_map"]>

  export type job_skill_mapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_skill_map_id?: boolean
    job_skill_map_uuid?: boolean
    job_id?: boolean
    skill_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_skill?: boolean | job_skillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_skill_map"]>

  export type job_skill_mapSelectScalar = {
    job_skill_map_id?: boolean
    job_skill_map_uuid?: boolean
    job_id?: boolean
    skill_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type job_skill_mapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"job_skill_map_id" | "job_skill_map_uuid" | "job_id" | "skill_id" | "created_at" | "updated_at", ExtArgs["result"]["job_skill_map"]>
  export type job_skill_mapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_skill?: boolean | job_skillDefaultArgs<ExtArgs>
  }
  export type job_skill_mapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_skill?: boolean | job_skillDefaultArgs<ExtArgs>
  }
  export type job_skill_mapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_skill?: boolean | job_skillDefaultArgs<ExtArgs>
  }

  export type $job_skill_mapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_skill_map"
    objects: {
      job: Prisma.$jobPayload<ExtArgs>
      job_skill: Prisma.$job_skillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      job_skill_map_id: number
      job_skill_map_uuid: string
      job_id: number
      skill_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["job_skill_map"]>
    composites: {}
  }

  type job_skill_mapGetPayload<S extends boolean | null | undefined | job_skill_mapDefaultArgs> = $Result.GetResult<Prisma.$job_skill_mapPayload, S>

  type job_skill_mapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_skill_mapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_skill_mapCountAggregateInputType | true
    }

  export interface job_skill_mapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_skill_map'], meta: { name: 'job_skill_map' } }
    /**
     * Find zero or one Job_skill_map that matches the filter.
     * @param {job_skill_mapFindUniqueArgs} args - Arguments to find a Job_skill_map
     * @example
     * // Get one Job_skill_map
     * const job_skill_map = await prisma.job_skill_map.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_skill_mapFindUniqueArgs>(args: SelectSubset<T, job_skill_mapFindUniqueArgs<ExtArgs>>): Prisma__job_skill_mapClient<$Result.GetResult<Prisma.$job_skill_mapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_skill_map that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_skill_mapFindUniqueOrThrowArgs} args - Arguments to find a Job_skill_map
     * @example
     * // Get one Job_skill_map
     * const job_skill_map = await prisma.job_skill_map.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_skill_mapFindUniqueOrThrowArgs>(args: SelectSubset<T, job_skill_mapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_skill_mapClient<$Result.GetResult<Prisma.$job_skill_mapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_skill_map that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_skill_mapFindFirstArgs} args - Arguments to find a Job_skill_map
     * @example
     * // Get one Job_skill_map
     * const job_skill_map = await prisma.job_skill_map.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_skill_mapFindFirstArgs>(args?: SelectSubset<T, job_skill_mapFindFirstArgs<ExtArgs>>): Prisma__job_skill_mapClient<$Result.GetResult<Prisma.$job_skill_mapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_skill_map that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_skill_mapFindFirstOrThrowArgs} args - Arguments to find a Job_skill_map
     * @example
     * // Get one Job_skill_map
     * const job_skill_map = await prisma.job_skill_map.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_skill_mapFindFirstOrThrowArgs>(args?: SelectSubset<T, job_skill_mapFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_skill_mapClient<$Result.GetResult<Prisma.$job_skill_mapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_skill_maps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_skill_mapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_skill_maps
     * const job_skill_maps = await prisma.job_skill_map.findMany()
     * 
     * // Get first 10 Job_skill_maps
     * const job_skill_maps = await prisma.job_skill_map.findMany({ take: 10 })
     * 
     * // Only select the `job_skill_map_id`
     * const job_skill_mapWithJob_skill_map_idOnly = await prisma.job_skill_map.findMany({ select: { job_skill_map_id: true } })
     * 
     */
    findMany<T extends job_skill_mapFindManyArgs>(args?: SelectSubset<T, job_skill_mapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_skill_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_skill_map.
     * @param {job_skill_mapCreateArgs} args - Arguments to create a Job_skill_map.
     * @example
     * // Create one Job_skill_map
     * const Job_skill_map = await prisma.job_skill_map.create({
     *   data: {
     *     // ... data to create a Job_skill_map
     *   }
     * })
     * 
     */
    create<T extends job_skill_mapCreateArgs>(args: SelectSubset<T, job_skill_mapCreateArgs<ExtArgs>>): Prisma__job_skill_mapClient<$Result.GetResult<Prisma.$job_skill_mapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_skill_maps.
     * @param {job_skill_mapCreateManyArgs} args - Arguments to create many Job_skill_maps.
     * @example
     * // Create many Job_skill_maps
     * const job_skill_map = await prisma.job_skill_map.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_skill_mapCreateManyArgs>(args?: SelectSubset<T, job_skill_mapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Job_skill_maps and returns the data saved in the database.
     * @param {job_skill_mapCreateManyAndReturnArgs} args - Arguments to create many Job_skill_maps.
     * @example
     * // Create many Job_skill_maps
     * const job_skill_map = await prisma.job_skill_map.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Job_skill_maps and only return the `job_skill_map_id`
     * const job_skill_mapWithJob_skill_map_idOnly = await prisma.job_skill_map.createManyAndReturn({
     *   select: { job_skill_map_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends job_skill_mapCreateManyAndReturnArgs>(args?: SelectSubset<T, job_skill_mapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_skill_mapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job_skill_map.
     * @param {job_skill_mapDeleteArgs} args - Arguments to delete one Job_skill_map.
     * @example
     * // Delete one Job_skill_map
     * const Job_skill_map = await prisma.job_skill_map.delete({
     *   where: {
     *     // ... filter to delete one Job_skill_map
     *   }
     * })
     * 
     */
    delete<T extends job_skill_mapDeleteArgs>(args: SelectSubset<T, job_skill_mapDeleteArgs<ExtArgs>>): Prisma__job_skill_mapClient<$Result.GetResult<Prisma.$job_skill_mapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_skill_map.
     * @param {job_skill_mapUpdateArgs} args - Arguments to update one Job_skill_map.
     * @example
     * // Update one Job_skill_map
     * const job_skill_map = await prisma.job_skill_map.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_skill_mapUpdateArgs>(args: SelectSubset<T, job_skill_mapUpdateArgs<ExtArgs>>): Prisma__job_skill_mapClient<$Result.GetResult<Prisma.$job_skill_mapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_skill_maps.
     * @param {job_skill_mapDeleteManyArgs} args - Arguments to filter Job_skill_maps to delete.
     * @example
     * // Delete a few Job_skill_maps
     * const { count } = await prisma.job_skill_map.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_skill_mapDeleteManyArgs>(args?: SelectSubset<T, job_skill_mapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_skill_maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_skill_mapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_skill_maps
     * const job_skill_map = await prisma.job_skill_map.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_skill_mapUpdateManyArgs>(args: SelectSubset<T, job_skill_mapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_skill_maps and returns the data updated in the database.
     * @param {job_skill_mapUpdateManyAndReturnArgs} args - Arguments to update many Job_skill_maps.
     * @example
     * // Update many Job_skill_maps
     * const job_skill_map = await prisma.job_skill_map.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Job_skill_maps and only return the `job_skill_map_id`
     * const job_skill_mapWithJob_skill_map_idOnly = await prisma.job_skill_map.updateManyAndReturn({
     *   select: { job_skill_map_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends job_skill_mapUpdateManyAndReturnArgs>(args: SelectSubset<T, job_skill_mapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_skill_mapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job_skill_map.
     * @param {job_skill_mapUpsertArgs} args - Arguments to update or create a Job_skill_map.
     * @example
     * // Update or create a Job_skill_map
     * const job_skill_map = await prisma.job_skill_map.upsert({
     *   create: {
     *     // ... data to create a Job_skill_map
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_skill_map we want to update
     *   }
     * })
     */
    upsert<T extends job_skill_mapUpsertArgs>(args: SelectSubset<T, job_skill_mapUpsertArgs<ExtArgs>>): Prisma__job_skill_mapClient<$Result.GetResult<Prisma.$job_skill_mapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_skill_maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_skill_mapCountArgs} args - Arguments to filter Job_skill_maps to count.
     * @example
     * // Count the number of Job_skill_maps
     * const count = await prisma.job_skill_map.count({
     *   where: {
     *     // ... the filter for the Job_skill_maps we want to count
     *   }
     * })
    **/
    count<T extends job_skill_mapCountArgs>(
      args?: Subset<T, job_skill_mapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_skill_mapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_skill_map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_skill_mapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_skill_mapAggregateArgs>(args: Subset<T, Job_skill_mapAggregateArgs>): Prisma.PrismaPromise<GetJob_skill_mapAggregateType<T>>

    /**
     * Group by Job_skill_map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_skill_mapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_skill_mapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_skill_mapGroupByArgs['orderBy'] }
        : { orderBy?: job_skill_mapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_skill_mapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_skill_mapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_skill_map model
   */
  readonly fields: job_skill_mapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_skill_map.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_skill_mapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends jobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobDefaultArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    job_skill<T extends job_skillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, job_skillDefaultArgs<ExtArgs>>): Prisma__job_skillClient<$Result.GetResult<Prisma.$job_skillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_skill_map model
   */
  interface job_skill_mapFieldRefs {
    readonly job_skill_map_id: FieldRef<"job_skill_map", 'Int'>
    readonly job_skill_map_uuid: FieldRef<"job_skill_map", 'String'>
    readonly job_id: FieldRef<"job_skill_map", 'Int'>
    readonly skill_id: FieldRef<"job_skill_map", 'Int'>
    readonly created_at: FieldRef<"job_skill_map", 'DateTime'>
    readonly updated_at: FieldRef<"job_skill_map", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * job_skill_map findUnique
   */
  export type job_skill_mapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill_map
     */
    select?: job_skill_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill_map
     */
    omit?: job_skill_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skill_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_skill_map to fetch.
     */
    where: job_skill_mapWhereUniqueInput
  }

  /**
   * job_skill_map findUniqueOrThrow
   */
  export type job_skill_mapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill_map
     */
    select?: job_skill_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill_map
     */
    omit?: job_skill_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skill_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_skill_map to fetch.
     */
    where: job_skill_mapWhereUniqueInput
  }

  /**
   * job_skill_map findFirst
   */
  export type job_skill_mapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill_map
     */
    select?: job_skill_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill_map
     */
    omit?: job_skill_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skill_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_skill_map to fetch.
     */
    where?: job_skill_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_skill_maps to fetch.
     */
    orderBy?: job_skill_mapOrderByWithRelationInput | job_skill_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_skill_maps.
     */
    cursor?: job_skill_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_skill_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_skill_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_skill_maps.
     */
    distinct?: Job_skill_mapScalarFieldEnum | Job_skill_mapScalarFieldEnum[]
  }

  /**
   * job_skill_map findFirstOrThrow
   */
  export type job_skill_mapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill_map
     */
    select?: job_skill_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill_map
     */
    omit?: job_skill_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skill_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_skill_map to fetch.
     */
    where?: job_skill_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_skill_maps to fetch.
     */
    orderBy?: job_skill_mapOrderByWithRelationInput | job_skill_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_skill_maps.
     */
    cursor?: job_skill_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_skill_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_skill_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_skill_maps.
     */
    distinct?: Job_skill_mapScalarFieldEnum | Job_skill_mapScalarFieldEnum[]
  }

  /**
   * job_skill_map findMany
   */
  export type job_skill_mapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill_map
     */
    select?: job_skill_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill_map
     */
    omit?: job_skill_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skill_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_skill_maps to fetch.
     */
    where?: job_skill_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_skill_maps to fetch.
     */
    orderBy?: job_skill_mapOrderByWithRelationInput | job_skill_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_skill_maps.
     */
    cursor?: job_skill_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_skill_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_skill_maps.
     */
    skip?: number
    distinct?: Job_skill_mapScalarFieldEnum | Job_skill_mapScalarFieldEnum[]
  }

  /**
   * job_skill_map create
   */
  export type job_skill_mapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill_map
     */
    select?: job_skill_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill_map
     */
    omit?: job_skill_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skill_mapInclude<ExtArgs> | null
    /**
     * The data needed to create a job_skill_map.
     */
    data: XOR<job_skill_mapCreateInput, job_skill_mapUncheckedCreateInput>
  }

  /**
   * job_skill_map createMany
   */
  export type job_skill_mapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_skill_maps.
     */
    data: job_skill_mapCreateManyInput | job_skill_mapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_skill_map createManyAndReturn
   */
  export type job_skill_mapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill_map
     */
    select?: job_skill_mapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill_map
     */
    omit?: job_skill_mapOmit<ExtArgs> | null
    /**
     * The data used to create many job_skill_maps.
     */
    data: job_skill_mapCreateManyInput | job_skill_mapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skill_mapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_skill_map update
   */
  export type job_skill_mapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill_map
     */
    select?: job_skill_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill_map
     */
    omit?: job_skill_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skill_mapInclude<ExtArgs> | null
    /**
     * The data needed to update a job_skill_map.
     */
    data: XOR<job_skill_mapUpdateInput, job_skill_mapUncheckedUpdateInput>
    /**
     * Choose, which job_skill_map to update.
     */
    where: job_skill_mapWhereUniqueInput
  }

  /**
   * job_skill_map updateMany
   */
  export type job_skill_mapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_skill_maps.
     */
    data: XOR<job_skill_mapUpdateManyMutationInput, job_skill_mapUncheckedUpdateManyInput>
    /**
     * Filter which job_skill_maps to update
     */
    where?: job_skill_mapWhereInput
    /**
     * Limit how many job_skill_maps to update.
     */
    limit?: number
  }

  /**
   * job_skill_map updateManyAndReturn
   */
  export type job_skill_mapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill_map
     */
    select?: job_skill_mapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill_map
     */
    omit?: job_skill_mapOmit<ExtArgs> | null
    /**
     * The data used to update job_skill_maps.
     */
    data: XOR<job_skill_mapUpdateManyMutationInput, job_skill_mapUncheckedUpdateManyInput>
    /**
     * Filter which job_skill_maps to update
     */
    where?: job_skill_mapWhereInput
    /**
     * Limit how many job_skill_maps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skill_mapIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_skill_map upsert
   */
  export type job_skill_mapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill_map
     */
    select?: job_skill_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill_map
     */
    omit?: job_skill_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skill_mapInclude<ExtArgs> | null
    /**
     * The filter to search for the job_skill_map to update in case it exists.
     */
    where: job_skill_mapWhereUniqueInput
    /**
     * In case the job_skill_map found by the `where` argument doesn't exist, create a new job_skill_map with this data.
     */
    create: XOR<job_skill_mapCreateInput, job_skill_mapUncheckedCreateInput>
    /**
     * In case the job_skill_map was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_skill_mapUpdateInput, job_skill_mapUncheckedUpdateInput>
  }

  /**
   * job_skill_map delete
   */
  export type job_skill_mapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill_map
     */
    select?: job_skill_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill_map
     */
    omit?: job_skill_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skill_mapInclude<ExtArgs> | null
    /**
     * Filter which job_skill_map to delete.
     */
    where: job_skill_mapWhereUniqueInput
  }

  /**
   * job_skill_map deleteMany
   */
  export type job_skill_mapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_skill_maps to delete
     */
    where?: job_skill_mapWhereInput
    /**
     * Limit how many job_skill_maps to delete.
     */
    limit?: number
  }

  /**
   * job_skill_map without action
   */
  export type job_skill_mapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_skill_map
     */
    select?: job_skill_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_skill_map
     */
    omit?: job_skill_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_skill_mapInclude<ExtArgs> | null
  }


  /**
   * Model job_source
   */

  export type AggregateJob_source = {
    _count: Job_sourceCountAggregateOutputType | null
    _avg: Job_sourceAvgAggregateOutputType | null
    _sum: Job_sourceSumAggregateOutputType | null
    _min: Job_sourceMinAggregateOutputType | null
    _max: Job_sourceMaxAggregateOutputType | null
  }

  export type Job_sourceAvgAggregateOutputType = {
    job_source_id: number | null
  }

  export type Job_sourceSumAggregateOutputType = {
    job_source_id: number | null
  }

  export type Job_sourceMinAggregateOutputType = {
    job_source_id: number | null
    job_source_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_sourceMaxAggregateOutputType = {
    job_source_id: number | null
    job_source_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_sourceCountAggregateOutputType = {
    job_source_id: number
    job_source_name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Job_sourceAvgAggregateInputType = {
    job_source_id?: true
  }

  export type Job_sourceSumAggregateInputType = {
    job_source_id?: true
  }

  export type Job_sourceMinAggregateInputType = {
    job_source_id?: true
    job_source_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_sourceMaxAggregateInputType = {
    job_source_id?: true
    job_source_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_sourceCountAggregateInputType = {
    job_source_id?: true
    job_source_name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Job_sourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_source to aggregate.
     */
    where?: job_sourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_sources to fetch.
     */
    orderBy?: job_sourceOrderByWithRelationInput | job_sourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_sourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_sources
    **/
    _count?: true | Job_sourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Job_sourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Job_sourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_sourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_sourceMaxAggregateInputType
  }

  export type GetJob_sourceAggregateType<T extends Job_sourceAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_source]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_source[P]>
      : GetScalarType<T[P], AggregateJob_source[P]>
  }




  export type job_sourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_sourceWhereInput
    orderBy?: job_sourceOrderByWithAggregationInput | job_sourceOrderByWithAggregationInput[]
    by: Job_sourceScalarFieldEnum[] | Job_sourceScalarFieldEnum
    having?: job_sourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_sourceCountAggregateInputType | true
    _avg?: Job_sourceAvgAggregateInputType
    _sum?: Job_sourceSumAggregateInputType
    _min?: Job_sourceMinAggregateInputType
    _max?: Job_sourceMaxAggregateInputType
  }

  export type Job_sourceGroupByOutputType = {
    job_source_id: number
    job_source_name: string
    created_at: Date
    updated_at: Date
    _count: Job_sourceCountAggregateOutputType | null
    _avg: Job_sourceAvgAggregateOutputType | null
    _sum: Job_sourceSumAggregateOutputType | null
    _min: Job_sourceMinAggregateOutputType | null
    _max: Job_sourceMaxAggregateOutputType | null
  }

  type GetJob_sourceGroupByPayload<T extends job_sourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_sourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_sourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_sourceGroupByOutputType[P]>
            : GetScalarType<T[P], Job_sourceGroupByOutputType[P]>
        }
      >
    >


  export type job_sourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_source_id?: boolean
    job_source_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    job_source_map?: boolean | job_source$job_source_mapArgs<ExtArgs>
    _count?: boolean | Job_sourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_source"]>

  export type job_sourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_source_id?: boolean
    job_source_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["job_source"]>

  export type job_sourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_source_id?: boolean
    job_source_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["job_source"]>

  export type job_sourceSelectScalar = {
    job_source_id?: boolean
    job_source_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type job_sourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"job_source_id" | "job_source_name" | "created_at" | "updated_at", ExtArgs["result"]["job_source"]>
  export type job_sourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_source_map?: boolean | job_source$job_source_mapArgs<ExtArgs>
    _count?: boolean | Job_sourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type job_sourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type job_sourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $job_sourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_source"
    objects: {
      job_source_map: Prisma.$job_source_mapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      job_source_id: number
      job_source_name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["job_source"]>
    composites: {}
  }

  type job_sourceGetPayload<S extends boolean | null | undefined | job_sourceDefaultArgs> = $Result.GetResult<Prisma.$job_sourcePayload, S>

  type job_sourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_sourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_sourceCountAggregateInputType | true
    }

  export interface job_sourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_source'], meta: { name: 'job_source' } }
    /**
     * Find zero or one Job_source that matches the filter.
     * @param {job_sourceFindUniqueArgs} args - Arguments to find a Job_source
     * @example
     * // Get one Job_source
     * const job_source = await prisma.job_source.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_sourceFindUniqueArgs>(args: SelectSubset<T, job_sourceFindUniqueArgs<ExtArgs>>): Prisma__job_sourceClient<$Result.GetResult<Prisma.$job_sourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_source that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_sourceFindUniqueOrThrowArgs} args - Arguments to find a Job_source
     * @example
     * // Get one Job_source
     * const job_source = await prisma.job_source.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_sourceFindUniqueOrThrowArgs>(args: SelectSubset<T, job_sourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_sourceClient<$Result.GetResult<Prisma.$job_sourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_source that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_sourceFindFirstArgs} args - Arguments to find a Job_source
     * @example
     * // Get one Job_source
     * const job_source = await prisma.job_source.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_sourceFindFirstArgs>(args?: SelectSubset<T, job_sourceFindFirstArgs<ExtArgs>>): Prisma__job_sourceClient<$Result.GetResult<Prisma.$job_sourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_source that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_sourceFindFirstOrThrowArgs} args - Arguments to find a Job_source
     * @example
     * // Get one Job_source
     * const job_source = await prisma.job_source.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_sourceFindFirstOrThrowArgs>(args?: SelectSubset<T, job_sourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_sourceClient<$Result.GetResult<Prisma.$job_sourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_sources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_sourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_sources
     * const job_sources = await prisma.job_source.findMany()
     * 
     * // Get first 10 Job_sources
     * const job_sources = await prisma.job_source.findMany({ take: 10 })
     * 
     * // Only select the `job_source_id`
     * const job_sourceWithJob_source_idOnly = await prisma.job_source.findMany({ select: { job_source_id: true } })
     * 
     */
    findMany<T extends job_sourceFindManyArgs>(args?: SelectSubset<T, job_sourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_sourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_source.
     * @param {job_sourceCreateArgs} args - Arguments to create a Job_source.
     * @example
     * // Create one Job_source
     * const Job_source = await prisma.job_source.create({
     *   data: {
     *     // ... data to create a Job_source
     *   }
     * })
     * 
     */
    create<T extends job_sourceCreateArgs>(args: SelectSubset<T, job_sourceCreateArgs<ExtArgs>>): Prisma__job_sourceClient<$Result.GetResult<Prisma.$job_sourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_sources.
     * @param {job_sourceCreateManyArgs} args - Arguments to create many Job_sources.
     * @example
     * // Create many Job_sources
     * const job_source = await prisma.job_source.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_sourceCreateManyArgs>(args?: SelectSubset<T, job_sourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Job_sources and returns the data saved in the database.
     * @param {job_sourceCreateManyAndReturnArgs} args - Arguments to create many Job_sources.
     * @example
     * // Create many Job_sources
     * const job_source = await prisma.job_source.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Job_sources and only return the `job_source_id`
     * const job_sourceWithJob_source_idOnly = await prisma.job_source.createManyAndReturn({
     *   select: { job_source_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends job_sourceCreateManyAndReturnArgs>(args?: SelectSubset<T, job_sourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_sourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job_source.
     * @param {job_sourceDeleteArgs} args - Arguments to delete one Job_source.
     * @example
     * // Delete one Job_source
     * const Job_source = await prisma.job_source.delete({
     *   where: {
     *     // ... filter to delete one Job_source
     *   }
     * })
     * 
     */
    delete<T extends job_sourceDeleteArgs>(args: SelectSubset<T, job_sourceDeleteArgs<ExtArgs>>): Prisma__job_sourceClient<$Result.GetResult<Prisma.$job_sourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_source.
     * @param {job_sourceUpdateArgs} args - Arguments to update one Job_source.
     * @example
     * // Update one Job_source
     * const job_source = await prisma.job_source.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_sourceUpdateArgs>(args: SelectSubset<T, job_sourceUpdateArgs<ExtArgs>>): Prisma__job_sourceClient<$Result.GetResult<Prisma.$job_sourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_sources.
     * @param {job_sourceDeleteManyArgs} args - Arguments to filter Job_sources to delete.
     * @example
     * // Delete a few Job_sources
     * const { count } = await prisma.job_source.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_sourceDeleteManyArgs>(args?: SelectSubset<T, job_sourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_sourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_sources
     * const job_source = await prisma.job_source.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_sourceUpdateManyArgs>(args: SelectSubset<T, job_sourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_sources and returns the data updated in the database.
     * @param {job_sourceUpdateManyAndReturnArgs} args - Arguments to update many Job_sources.
     * @example
     * // Update many Job_sources
     * const job_source = await prisma.job_source.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Job_sources and only return the `job_source_id`
     * const job_sourceWithJob_source_idOnly = await prisma.job_source.updateManyAndReturn({
     *   select: { job_source_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends job_sourceUpdateManyAndReturnArgs>(args: SelectSubset<T, job_sourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_sourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job_source.
     * @param {job_sourceUpsertArgs} args - Arguments to update or create a Job_source.
     * @example
     * // Update or create a Job_source
     * const job_source = await prisma.job_source.upsert({
     *   create: {
     *     // ... data to create a Job_source
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_source we want to update
     *   }
     * })
     */
    upsert<T extends job_sourceUpsertArgs>(args: SelectSubset<T, job_sourceUpsertArgs<ExtArgs>>): Prisma__job_sourceClient<$Result.GetResult<Prisma.$job_sourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_sourceCountArgs} args - Arguments to filter Job_sources to count.
     * @example
     * // Count the number of Job_sources
     * const count = await prisma.job_source.count({
     *   where: {
     *     // ... the filter for the Job_sources we want to count
     *   }
     * })
    **/
    count<T extends job_sourceCountArgs>(
      args?: Subset<T, job_sourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_sourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_sourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_sourceAggregateArgs>(args: Subset<T, Job_sourceAggregateArgs>): Prisma.PrismaPromise<GetJob_sourceAggregateType<T>>

    /**
     * Group by Job_source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_sourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_sourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_sourceGroupByArgs['orderBy'] }
        : { orderBy?: job_sourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_sourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_sourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_source model
   */
  readonly fields: job_sourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_source.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_sourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job_source_map<T extends job_source$job_source_mapArgs<ExtArgs> = {}>(args?: Subset<T, job_source$job_source_mapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_source_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_source model
   */
  interface job_sourceFieldRefs {
    readonly job_source_id: FieldRef<"job_source", 'Int'>
    readonly job_source_name: FieldRef<"job_source", 'String'>
    readonly created_at: FieldRef<"job_source", 'DateTime'>
    readonly updated_at: FieldRef<"job_source", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * job_source findUnique
   */
  export type job_sourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source
     */
    select?: job_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source
     */
    omit?: job_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_sourceInclude<ExtArgs> | null
    /**
     * Filter, which job_source to fetch.
     */
    where: job_sourceWhereUniqueInput
  }

  /**
   * job_source findUniqueOrThrow
   */
  export type job_sourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source
     */
    select?: job_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source
     */
    omit?: job_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_sourceInclude<ExtArgs> | null
    /**
     * Filter, which job_source to fetch.
     */
    where: job_sourceWhereUniqueInput
  }

  /**
   * job_source findFirst
   */
  export type job_sourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source
     */
    select?: job_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source
     */
    omit?: job_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_sourceInclude<ExtArgs> | null
    /**
     * Filter, which job_source to fetch.
     */
    where?: job_sourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_sources to fetch.
     */
    orderBy?: job_sourceOrderByWithRelationInput | job_sourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_sources.
     */
    cursor?: job_sourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_sources.
     */
    distinct?: Job_sourceScalarFieldEnum | Job_sourceScalarFieldEnum[]
  }

  /**
   * job_source findFirstOrThrow
   */
  export type job_sourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source
     */
    select?: job_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source
     */
    omit?: job_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_sourceInclude<ExtArgs> | null
    /**
     * Filter, which job_source to fetch.
     */
    where?: job_sourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_sources to fetch.
     */
    orderBy?: job_sourceOrderByWithRelationInput | job_sourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_sources.
     */
    cursor?: job_sourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_sources.
     */
    distinct?: Job_sourceScalarFieldEnum | Job_sourceScalarFieldEnum[]
  }

  /**
   * job_source findMany
   */
  export type job_sourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source
     */
    select?: job_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source
     */
    omit?: job_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_sourceInclude<ExtArgs> | null
    /**
     * Filter, which job_sources to fetch.
     */
    where?: job_sourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_sources to fetch.
     */
    orderBy?: job_sourceOrderByWithRelationInput | job_sourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_sources.
     */
    cursor?: job_sourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_sources.
     */
    skip?: number
    distinct?: Job_sourceScalarFieldEnum | Job_sourceScalarFieldEnum[]
  }

  /**
   * job_source create
   */
  export type job_sourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source
     */
    select?: job_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source
     */
    omit?: job_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_sourceInclude<ExtArgs> | null
    /**
     * The data needed to create a job_source.
     */
    data: XOR<job_sourceCreateInput, job_sourceUncheckedCreateInput>
  }

  /**
   * job_source createMany
   */
  export type job_sourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_sources.
     */
    data: job_sourceCreateManyInput | job_sourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_source createManyAndReturn
   */
  export type job_sourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source
     */
    select?: job_sourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_source
     */
    omit?: job_sourceOmit<ExtArgs> | null
    /**
     * The data used to create many job_sources.
     */
    data: job_sourceCreateManyInput | job_sourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_source update
   */
  export type job_sourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source
     */
    select?: job_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source
     */
    omit?: job_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_sourceInclude<ExtArgs> | null
    /**
     * The data needed to update a job_source.
     */
    data: XOR<job_sourceUpdateInput, job_sourceUncheckedUpdateInput>
    /**
     * Choose, which job_source to update.
     */
    where: job_sourceWhereUniqueInput
  }

  /**
   * job_source updateMany
   */
  export type job_sourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_sources.
     */
    data: XOR<job_sourceUpdateManyMutationInput, job_sourceUncheckedUpdateManyInput>
    /**
     * Filter which job_sources to update
     */
    where?: job_sourceWhereInput
    /**
     * Limit how many job_sources to update.
     */
    limit?: number
  }

  /**
   * job_source updateManyAndReturn
   */
  export type job_sourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source
     */
    select?: job_sourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_source
     */
    omit?: job_sourceOmit<ExtArgs> | null
    /**
     * The data used to update job_sources.
     */
    data: XOR<job_sourceUpdateManyMutationInput, job_sourceUncheckedUpdateManyInput>
    /**
     * Filter which job_sources to update
     */
    where?: job_sourceWhereInput
    /**
     * Limit how many job_sources to update.
     */
    limit?: number
  }

  /**
   * job_source upsert
   */
  export type job_sourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source
     */
    select?: job_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source
     */
    omit?: job_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_sourceInclude<ExtArgs> | null
    /**
     * The filter to search for the job_source to update in case it exists.
     */
    where: job_sourceWhereUniqueInput
    /**
     * In case the job_source found by the `where` argument doesn't exist, create a new job_source with this data.
     */
    create: XOR<job_sourceCreateInput, job_sourceUncheckedCreateInput>
    /**
     * In case the job_source was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_sourceUpdateInput, job_sourceUncheckedUpdateInput>
  }

  /**
   * job_source delete
   */
  export type job_sourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source
     */
    select?: job_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source
     */
    omit?: job_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_sourceInclude<ExtArgs> | null
    /**
     * Filter which job_source to delete.
     */
    where: job_sourceWhereUniqueInput
  }

  /**
   * job_source deleteMany
   */
  export type job_sourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_sources to delete
     */
    where?: job_sourceWhereInput
    /**
     * Limit how many job_sources to delete.
     */
    limit?: number
  }

  /**
   * job_source.job_source_map
   */
  export type job_source$job_source_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source_map
     */
    select?: job_source_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source_map
     */
    omit?: job_source_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_source_mapInclude<ExtArgs> | null
    where?: job_source_mapWhereInput
    orderBy?: job_source_mapOrderByWithRelationInput | job_source_mapOrderByWithRelationInput[]
    cursor?: job_source_mapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_source_mapScalarFieldEnum | Job_source_mapScalarFieldEnum[]
  }

  /**
   * job_source without action
   */
  export type job_sourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source
     */
    select?: job_sourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source
     */
    omit?: job_sourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_sourceInclude<ExtArgs> | null
  }


  /**
   * Model job_source_map
   */

  export type AggregateJob_source_map = {
    _count: Job_source_mapCountAggregateOutputType | null
    _avg: Job_source_mapAvgAggregateOutputType | null
    _sum: Job_source_mapSumAggregateOutputType | null
    _min: Job_source_mapMinAggregateOutputType | null
    _max: Job_source_mapMaxAggregateOutputType | null
  }

  export type Job_source_mapAvgAggregateOutputType = {
    job_source_map_id: number | null
    job_id: number | null
    source_id: number | null
  }

  export type Job_source_mapSumAggregateOutputType = {
    job_source_map_id: number | null
    job_id: number | null
    source_id: number | null
  }

  export type Job_source_mapMinAggregateOutputType = {
    job_source_map_id: number | null
    job_source_map_uuid: string | null
    job_id: number | null
    source_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_source_mapMaxAggregateOutputType = {
    job_source_map_id: number | null
    job_source_map_uuid: string | null
    job_id: number | null
    source_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_source_mapCountAggregateOutputType = {
    job_source_map_id: number
    job_source_map_uuid: number
    job_id: number
    source_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Job_source_mapAvgAggregateInputType = {
    job_source_map_id?: true
    job_id?: true
    source_id?: true
  }

  export type Job_source_mapSumAggregateInputType = {
    job_source_map_id?: true
    job_id?: true
    source_id?: true
  }

  export type Job_source_mapMinAggregateInputType = {
    job_source_map_id?: true
    job_source_map_uuid?: true
    job_id?: true
    source_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_source_mapMaxAggregateInputType = {
    job_source_map_id?: true
    job_source_map_uuid?: true
    job_id?: true
    source_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_source_mapCountAggregateInputType = {
    job_source_map_id?: true
    job_source_map_uuid?: true
    job_id?: true
    source_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Job_source_mapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_source_map to aggregate.
     */
    where?: job_source_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_source_maps to fetch.
     */
    orderBy?: job_source_mapOrderByWithRelationInput | job_source_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_source_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_source_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_source_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_source_maps
    **/
    _count?: true | Job_source_mapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Job_source_mapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Job_source_mapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_source_mapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_source_mapMaxAggregateInputType
  }

  export type GetJob_source_mapAggregateType<T extends Job_source_mapAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_source_map]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_source_map[P]>
      : GetScalarType<T[P], AggregateJob_source_map[P]>
  }




  export type job_source_mapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_source_mapWhereInput
    orderBy?: job_source_mapOrderByWithAggregationInput | job_source_mapOrderByWithAggregationInput[]
    by: Job_source_mapScalarFieldEnum[] | Job_source_mapScalarFieldEnum
    having?: job_source_mapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_source_mapCountAggregateInputType | true
    _avg?: Job_source_mapAvgAggregateInputType
    _sum?: Job_source_mapSumAggregateInputType
    _min?: Job_source_mapMinAggregateInputType
    _max?: Job_source_mapMaxAggregateInputType
  }

  export type Job_source_mapGroupByOutputType = {
    job_source_map_id: number
    job_source_map_uuid: string
    job_id: number
    source_id: number
    created_at: Date
    updated_at: Date
    _count: Job_source_mapCountAggregateOutputType | null
    _avg: Job_source_mapAvgAggregateOutputType | null
    _sum: Job_source_mapSumAggregateOutputType | null
    _min: Job_source_mapMinAggregateOutputType | null
    _max: Job_source_mapMaxAggregateOutputType | null
  }

  type GetJob_source_mapGroupByPayload<T extends job_source_mapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_source_mapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_source_mapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_source_mapGroupByOutputType[P]>
            : GetScalarType<T[P], Job_source_mapGroupByOutputType[P]>
        }
      >
    >


  export type job_source_mapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_source_map_id?: boolean
    job_source_map_uuid?: boolean
    job_id?: boolean
    source_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_source?: boolean | job_sourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_source_map"]>

  export type job_source_mapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_source_map_id?: boolean
    job_source_map_uuid?: boolean
    job_id?: boolean
    source_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_source?: boolean | job_sourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_source_map"]>

  export type job_source_mapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_source_map_id?: boolean
    job_source_map_uuid?: boolean
    job_id?: boolean
    source_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_source?: boolean | job_sourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_source_map"]>

  export type job_source_mapSelectScalar = {
    job_source_map_id?: boolean
    job_source_map_uuid?: boolean
    job_id?: boolean
    source_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type job_source_mapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"job_source_map_id" | "job_source_map_uuid" | "job_id" | "source_id" | "created_at" | "updated_at", ExtArgs["result"]["job_source_map"]>
  export type job_source_mapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_source?: boolean | job_sourceDefaultArgs<ExtArgs>
  }
  export type job_source_mapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_source?: boolean | job_sourceDefaultArgs<ExtArgs>
  }
  export type job_source_mapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_source?: boolean | job_sourceDefaultArgs<ExtArgs>
  }

  export type $job_source_mapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_source_map"
    objects: {
      job: Prisma.$jobPayload<ExtArgs>
      job_source: Prisma.$job_sourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      job_source_map_id: number
      job_source_map_uuid: string
      job_id: number
      source_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["job_source_map"]>
    composites: {}
  }

  type job_source_mapGetPayload<S extends boolean | null | undefined | job_source_mapDefaultArgs> = $Result.GetResult<Prisma.$job_source_mapPayload, S>

  type job_source_mapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_source_mapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_source_mapCountAggregateInputType | true
    }

  export interface job_source_mapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_source_map'], meta: { name: 'job_source_map' } }
    /**
     * Find zero or one Job_source_map that matches the filter.
     * @param {job_source_mapFindUniqueArgs} args - Arguments to find a Job_source_map
     * @example
     * // Get one Job_source_map
     * const job_source_map = await prisma.job_source_map.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_source_mapFindUniqueArgs>(args: SelectSubset<T, job_source_mapFindUniqueArgs<ExtArgs>>): Prisma__job_source_mapClient<$Result.GetResult<Prisma.$job_source_mapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_source_map that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_source_mapFindUniqueOrThrowArgs} args - Arguments to find a Job_source_map
     * @example
     * // Get one Job_source_map
     * const job_source_map = await prisma.job_source_map.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_source_mapFindUniqueOrThrowArgs>(args: SelectSubset<T, job_source_mapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_source_mapClient<$Result.GetResult<Prisma.$job_source_mapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_source_map that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_source_mapFindFirstArgs} args - Arguments to find a Job_source_map
     * @example
     * // Get one Job_source_map
     * const job_source_map = await prisma.job_source_map.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_source_mapFindFirstArgs>(args?: SelectSubset<T, job_source_mapFindFirstArgs<ExtArgs>>): Prisma__job_source_mapClient<$Result.GetResult<Prisma.$job_source_mapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_source_map that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_source_mapFindFirstOrThrowArgs} args - Arguments to find a Job_source_map
     * @example
     * // Get one Job_source_map
     * const job_source_map = await prisma.job_source_map.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_source_mapFindFirstOrThrowArgs>(args?: SelectSubset<T, job_source_mapFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_source_mapClient<$Result.GetResult<Prisma.$job_source_mapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_source_maps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_source_mapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_source_maps
     * const job_source_maps = await prisma.job_source_map.findMany()
     * 
     * // Get first 10 Job_source_maps
     * const job_source_maps = await prisma.job_source_map.findMany({ take: 10 })
     * 
     * // Only select the `job_source_map_id`
     * const job_source_mapWithJob_source_map_idOnly = await prisma.job_source_map.findMany({ select: { job_source_map_id: true } })
     * 
     */
    findMany<T extends job_source_mapFindManyArgs>(args?: SelectSubset<T, job_source_mapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_source_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_source_map.
     * @param {job_source_mapCreateArgs} args - Arguments to create a Job_source_map.
     * @example
     * // Create one Job_source_map
     * const Job_source_map = await prisma.job_source_map.create({
     *   data: {
     *     // ... data to create a Job_source_map
     *   }
     * })
     * 
     */
    create<T extends job_source_mapCreateArgs>(args: SelectSubset<T, job_source_mapCreateArgs<ExtArgs>>): Prisma__job_source_mapClient<$Result.GetResult<Prisma.$job_source_mapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_source_maps.
     * @param {job_source_mapCreateManyArgs} args - Arguments to create many Job_source_maps.
     * @example
     * // Create many Job_source_maps
     * const job_source_map = await prisma.job_source_map.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_source_mapCreateManyArgs>(args?: SelectSubset<T, job_source_mapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Job_source_maps and returns the data saved in the database.
     * @param {job_source_mapCreateManyAndReturnArgs} args - Arguments to create many Job_source_maps.
     * @example
     * // Create many Job_source_maps
     * const job_source_map = await prisma.job_source_map.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Job_source_maps and only return the `job_source_map_id`
     * const job_source_mapWithJob_source_map_idOnly = await prisma.job_source_map.createManyAndReturn({
     *   select: { job_source_map_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends job_source_mapCreateManyAndReturnArgs>(args?: SelectSubset<T, job_source_mapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_source_mapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job_source_map.
     * @param {job_source_mapDeleteArgs} args - Arguments to delete one Job_source_map.
     * @example
     * // Delete one Job_source_map
     * const Job_source_map = await prisma.job_source_map.delete({
     *   where: {
     *     // ... filter to delete one Job_source_map
     *   }
     * })
     * 
     */
    delete<T extends job_source_mapDeleteArgs>(args: SelectSubset<T, job_source_mapDeleteArgs<ExtArgs>>): Prisma__job_source_mapClient<$Result.GetResult<Prisma.$job_source_mapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_source_map.
     * @param {job_source_mapUpdateArgs} args - Arguments to update one Job_source_map.
     * @example
     * // Update one Job_source_map
     * const job_source_map = await prisma.job_source_map.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_source_mapUpdateArgs>(args: SelectSubset<T, job_source_mapUpdateArgs<ExtArgs>>): Prisma__job_source_mapClient<$Result.GetResult<Prisma.$job_source_mapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_source_maps.
     * @param {job_source_mapDeleteManyArgs} args - Arguments to filter Job_source_maps to delete.
     * @example
     * // Delete a few Job_source_maps
     * const { count } = await prisma.job_source_map.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_source_mapDeleteManyArgs>(args?: SelectSubset<T, job_source_mapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_source_maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_source_mapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_source_maps
     * const job_source_map = await prisma.job_source_map.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_source_mapUpdateManyArgs>(args: SelectSubset<T, job_source_mapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_source_maps and returns the data updated in the database.
     * @param {job_source_mapUpdateManyAndReturnArgs} args - Arguments to update many Job_source_maps.
     * @example
     * // Update many Job_source_maps
     * const job_source_map = await prisma.job_source_map.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Job_source_maps and only return the `job_source_map_id`
     * const job_source_mapWithJob_source_map_idOnly = await prisma.job_source_map.updateManyAndReturn({
     *   select: { job_source_map_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends job_source_mapUpdateManyAndReturnArgs>(args: SelectSubset<T, job_source_mapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_source_mapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job_source_map.
     * @param {job_source_mapUpsertArgs} args - Arguments to update or create a Job_source_map.
     * @example
     * // Update or create a Job_source_map
     * const job_source_map = await prisma.job_source_map.upsert({
     *   create: {
     *     // ... data to create a Job_source_map
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_source_map we want to update
     *   }
     * })
     */
    upsert<T extends job_source_mapUpsertArgs>(args: SelectSubset<T, job_source_mapUpsertArgs<ExtArgs>>): Prisma__job_source_mapClient<$Result.GetResult<Prisma.$job_source_mapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_source_maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_source_mapCountArgs} args - Arguments to filter Job_source_maps to count.
     * @example
     * // Count the number of Job_source_maps
     * const count = await prisma.job_source_map.count({
     *   where: {
     *     // ... the filter for the Job_source_maps we want to count
     *   }
     * })
    **/
    count<T extends job_source_mapCountArgs>(
      args?: Subset<T, job_source_mapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_source_mapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_source_map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_source_mapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_source_mapAggregateArgs>(args: Subset<T, Job_source_mapAggregateArgs>): Prisma.PrismaPromise<GetJob_source_mapAggregateType<T>>

    /**
     * Group by Job_source_map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_source_mapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_source_mapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_source_mapGroupByArgs['orderBy'] }
        : { orderBy?: job_source_mapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_source_mapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_source_mapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_source_map model
   */
  readonly fields: job_source_mapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_source_map.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_source_mapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends jobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobDefaultArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    job_source<T extends job_sourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, job_sourceDefaultArgs<ExtArgs>>): Prisma__job_sourceClient<$Result.GetResult<Prisma.$job_sourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_source_map model
   */
  interface job_source_mapFieldRefs {
    readonly job_source_map_id: FieldRef<"job_source_map", 'Int'>
    readonly job_source_map_uuid: FieldRef<"job_source_map", 'String'>
    readonly job_id: FieldRef<"job_source_map", 'Int'>
    readonly source_id: FieldRef<"job_source_map", 'Int'>
    readonly created_at: FieldRef<"job_source_map", 'DateTime'>
    readonly updated_at: FieldRef<"job_source_map", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * job_source_map findUnique
   */
  export type job_source_mapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source_map
     */
    select?: job_source_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source_map
     */
    omit?: job_source_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_source_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_source_map to fetch.
     */
    where: job_source_mapWhereUniqueInput
  }

  /**
   * job_source_map findUniqueOrThrow
   */
  export type job_source_mapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source_map
     */
    select?: job_source_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source_map
     */
    omit?: job_source_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_source_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_source_map to fetch.
     */
    where: job_source_mapWhereUniqueInput
  }

  /**
   * job_source_map findFirst
   */
  export type job_source_mapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source_map
     */
    select?: job_source_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source_map
     */
    omit?: job_source_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_source_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_source_map to fetch.
     */
    where?: job_source_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_source_maps to fetch.
     */
    orderBy?: job_source_mapOrderByWithRelationInput | job_source_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_source_maps.
     */
    cursor?: job_source_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_source_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_source_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_source_maps.
     */
    distinct?: Job_source_mapScalarFieldEnum | Job_source_mapScalarFieldEnum[]
  }

  /**
   * job_source_map findFirstOrThrow
   */
  export type job_source_mapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source_map
     */
    select?: job_source_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source_map
     */
    omit?: job_source_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_source_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_source_map to fetch.
     */
    where?: job_source_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_source_maps to fetch.
     */
    orderBy?: job_source_mapOrderByWithRelationInput | job_source_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_source_maps.
     */
    cursor?: job_source_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_source_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_source_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_source_maps.
     */
    distinct?: Job_source_mapScalarFieldEnum | Job_source_mapScalarFieldEnum[]
  }

  /**
   * job_source_map findMany
   */
  export type job_source_mapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source_map
     */
    select?: job_source_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source_map
     */
    omit?: job_source_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_source_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_source_maps to fetch.
     */
    where?: job_source_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_source_maps to fetch.
     */
    orderBy?: job_source_mapOrderByWithRelationInput | job_source_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_source_maps.
     */
    cursor?: job_source_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_source_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_source_maps.
     */
    skip?: number
    distinct?: Job_source_mapScalarFieldEnum | Job_source_mapScalarFieldEnum[]
  }

  /**
   * job_source_map create
   */
  export type job_source_mapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source_map
     */
    select?: job_source_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source_map
     */
    omit?: job_source_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_source_mapInclude<ExtArgs> | null
    /**
     * The data needed to create a job_source_map.
     */
    data: XOR<job_source_mapCreateInput, job_source_mapUncheckedCreateInput>
  }

  /**
   * job_source_map createMany
   */
  export type job_source_mapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_source_maps.
     */
    data: job_source_mapCreateManyInput | job_source_mapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_source_map createManyAndReturn
   */
  export type job_source_mapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source_map
     */
    select?: job_source_mapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_source_map
     */
    omit?: job_source_mapOmit<ExtArgs> | null
    /**
     * The data used to create many job_source_maps.
     */
    data: job_source_mapCreateManyInput | job_source_mapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_source_mapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_source_map update
   */
  export type job_source_mapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source_map
     */
    select?: job_source_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source_map
     */
    omit?: job_source_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_source_mapInclude<ExtArgs> | null
    /**
     * The data needed to update a job_source_map.
     */
    data: XOR<job_source_mapUpdateInput, job_source_mapUncheckedUpdateInput>
    /**
     * Choose, which job_source_map to update.
     */
    where: job_source_mapWhereUniqueInput
  }

  /**
   * job_source_map updateMany
   */
  export type job_source_mapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_source_maps.
     */
    data: XOR<job_source_mapUpdateManyMutationInput, job_source_mapUncheckedUpdateManyInput>
    /**
     * Filter which job_source_maps to update
     */
    where?: job_source_mapWhereInput
    /**
     * Limit how many job_source_maps to update.
     */
    limit?: number
  }

  /**
   * job_source_map updateManyAndReturn
   */
  export type job_source_mapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source_map
     */
    select?: job_source_mapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_source_map
     */
    omit?: job_source_mapOmit<ExtArgs> | null
    /**
     * The data used to update job_source_maps.
     */
    data: XOR<job_source_mapUpdateManyMutationInput, job_source_mapUncheckedUpdateManyInput>
    /**
     * Filter which job_source_maps to update
     */
    where?: job_source_mapWhereInput
    /**
     * Limit how many job_source_maps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_source_mapIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_source_map upsert
   */
  export type job_source_mapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source_map
     */
    select?: job_source_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source_map
     */
    omit?: job_source_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_source_mapInclude<ExtArgs> | null
    /**
     * The filter to search for the job_source_map to update in case it exists.
     */
    where: job_source_mapWhereUniqueInput
    /**
     * In case the job_source_map found by the `where` argument doesn't exist, create a new job_source_map with this data.
     */
    create: XOR<job_source_mapCreateInput, job_source_mapUncheckedCreateInput>
    /**
     * In case the job_source_map was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_source_mapUpdateInput, job_source_mapUncheckedUpdateInput>
  }

  /**
   * job_source_map delete
   */
  export type job_source_mapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source_map
     */
    select?: job_source_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source_map
     */
    omit?: job_source_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_source_mapInclude<ExtArgs> | null
    /**
     * Filter which job_source_map to delete.
     */
    where: job_source_mapWhereUniqueInput
  }

  /**
   * job_source_map deleteMany
   */
  export type job_source_mapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_source_maps to delete
     */
    where?: job_source_mapWhereInput
    /**
     * Limit how many job_source_maps to delete.
     */
    limit?: number
  }

  /**
   * job_source_map without action
   */
  export type job_source_mapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_source_map
     */
    select?: job_source_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_source_map
     */
    omit?: job_source_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_source_mapInclude<ExtArgs> | null
  }


  /**
   * Model job_type
   */

  export type AggregateJob_type = {
    _count: Job_typeCountAggregateOutputType | null
    _avg: Job_typeAvgAggregateOutputType | null
    _sum: Job_typeSumAggregateOutputType | null
    _min: Job_typeMinAggregateOutputType | null
    _max: Job_typeMaxAggregateOutputType | null
  }

  export type Job_typeAvgAggregateOutputType = {
    job_type_id: number | null
  }

  export type Job_typeSumAggregateOutputType = {
    job_type_id: number | null
  }

  export type Job_typeMinAggregateOutputType = {
    job_type_id: number | null
    job_type_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_typeMaxAggregateOutputType = {
    job_type_id: number | null
    job_type_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_typeCountAggregateOutputType = {
    job_type_id: number
    job_type_name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Job_typeAvgAggregateInputType = {
    job_type_id?: true
  }

  export type Job_typeSumAggregateInputType = {
    job_type_id?: true
  }

  export type Job_typeMinAggregateInputType = {
    job_type_id?: true
    job_type_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_typeMaxAggregateInputType = {
    job_type_id?: true
    job_type_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_typeCountAggregateInputType = {
    job_type_id?: true
    job_type_name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Job_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_type to aggregate.
     */
    where?: job_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_types to fetch.
     */
    orderBy?: job_typeOrderByWithRelationInput | job_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_types
    **/
    _count?: true | Job_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Job_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Job_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_typeMaxAggregateInputType
  }

  export type GetJob_typeAggregateType<T extends Job_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_type[P]>
      : GetScalarType<T[P], AggregateJob_type[P]>
  }




  export type job_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_typeWhereInput
    orderBy?: job_typeOrderByWithAggregationInput | job_typeOrderByWithAggregationInput[]
    by: Job_typeScalarFieldEnum[] | Job_typeScalarFieldEnum
    having?: job_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_typeCountAggregateInputType | true
    _avg?: Job_typeAvgAggregateInputType
    _sum?: Job_typeSumAggregateInputType
    _min?: Job_typeMinAggregateInputType
    _max?: Job_typeMaxAggregateInputType
  }

  export type Job_typeGroupByOutputType = {
    job_type_id: number
    job_type_name: string
    created_at: Date
    updated_at: Date
    _count: Job_typeCountAggregateOutputType | null
    _avg: Job_typeAvgAggregateOutputType | null
    _sum: Job_typeSumAggregateOutputType | null
    _min: Job_typeMinAggregateOutputType | null
    _max: Job_typeMaxAggregateOutputType | null
  }

  type GetJob_typeGroupByPayload<T extends job_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Job_typeGroupByOutputType[P]>
        }
      >
    >


  export type job_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_type_id?: boolean
    job_type_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    job_type_map?: boolean | job_type$job_type_mapArgs<ExtArgs>
    _count?: boolean | Job_typeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_type"]>

  export type job_typeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_type_id?: boolean
    job_type_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["job_type"]>

  export type job_typeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_type_id?: boolean
    job_type_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["job_type"]>

  export type job_typeSelectScalar = {
    job_type_id?: boolean
    job_type_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type job_typeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"job_type_id" | "job_type_name" | "created_at" | "updated_at", ExtArgs["result"]["job_type"]>
  export type job_typeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_type_map?: boolean | job_type$job_type_mapArgs<ExtArgs>
    _count?: boolean | Job_typeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type job_typeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type job_typeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $job_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_type"
    objects: {
      job_type_map: Prisma.$job_type_mapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      job_type_id: number
      job_type_name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["job_type"]>
    composites: {}
  }

  type job_typeGetPayload<S extends boolean | null | undefined | job_typeDefaultArgs> = $Result.GetResult<Prisma.$job_typePayload, S>

  type job_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_typeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_typeCountAggregateInputType | true
    }

  export interface job_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_type'], meta: { name: 'job_type' } }
    /**
     * Find zero or one Job_type that matches the filter.
     * @param {job_typeFindUniqueArgs} args - Arguments to find a Job_type
     * @example
     * // Get one Job_type
     * const job_type = await prisma.job_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_typeFindUniqueArgs>(args: SelectSubset<T, job_typeFindUniqueArgs<ExtArgs>>): Prisma__job_typeClient<$Result.GetResult<Prisma.$job_typePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_typeFindUniqueOrThrowArgs} args - Arguments to find a Job_type
     * @example
     * // Get one Job_type
     * const job_type = await prisma.job_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_typeFindUniqueOrThrowArgs>(args: SelectSubset<T, job_typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_typeClient<$Result.GetResult<Prisma.$job_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_typeFindFirstArgs} args - Arguments to find a Job_type
     * @example
     * // Get one Job_type
     * const job_type = await prisma.job_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_typeFindFirstArgs>(args?: SelectSubset<T, job_typeFindFirstArgs<ExtArgs>>): Prisma__job_typeClient<$Result.GetResult<Prisma.$job_typePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_typeFindFirstOrThrowArgs} args - Arguments to find a Job_type
     * @example
     * // Get one Job_type
     * const job_type = await prisma.job_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_typeFindFirstOrThrowArgs>(args?: SelectSubset<T, job_typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_typeClient<$Result.GetResult<Prisma.$job_typePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_types
     * const job_types = await prisma.job_type.findMany()
     * 
     * // Get first 10 Job_types
     * const job_types = await prisma.job_type.findMany({ take: 10 })
     * 
     * // Only select the `job_type_id`
     * const job_typeWithJob_type_idOnly = await prisma.job_type.findMany({ select: { job_type_id: true } })
     * 
     */
    findMany<T extends job_typeFindManyArgs>(args?: SelectSubset<T, job_typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_type.
     * @param {job_typeCreateArgs} args - Arguments to create a Job_type.
     * @example
     * // Create one Job_type
     * const Job_type = await prisma.job_type.create({
     *   data: {
     *     // ... data to create a Job_type
     *   }
     * })
     * 
     */
    create<T extends job_typeCreateArgs>(args: SelectSubset<T, job_typeCreateArgs<ExtArgs>>): Prisma__job_typeClient<$Result.GetResult<Prisma.$job_typePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_types.
     * @param {job_typeCreateManyArgs} args - Arguments to create many Job_types.
     * @example
     * // Create many Job_types
     * const job_type = await prisma.job_type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_typeCreateManyArgs>(args?: SelectSubset<T, job_typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Job_types and returns the data saved in the database.
     * @param {job_typeCreateManyAndReturnArgs} args - Arguments to create many Job_types.
     * @example
     * // Create many Job_types
     * const job_type = await prisma.job_type.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Job_types and only return the `job_type_id`
     * const job_typeWithJob_type_idOnly = await prisma.job_type.createManyAndReturn({
     *   select: { job_type_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends job_typeCreateManyAndReturnArgs>(args?: SelectSubset<T, job_typeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_typePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job_type.
     * @param {job_typeDeleteArgs} args - Arguments to delete one Job_type.
     * @example
     * // Delete one Job_type
     * const Job_type = await prisma.job_type.delete({
     *   where: {
     *     // ... filter to delete one Job_type
     *   }
     * })
     * 
     */
    delete<T extends job_typeDeleteArgs>(args: SelectSubset<T, job_typeDeleteArgs<ExtArgs>>): Prisma__job_typeClient<$Result.GetResult<Prisma.$job_typePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_type.
     * @param {job_typeUpdateArgs} args - Arguments to update one Job_type.
     * @example
     * // Update one Job_type
     * const job_type = await prisma.job_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_typeUpdateArgs>(args: SelectSubset<T, job_typeUpdateArgs<ExtArgs>>): Prisma__job_typeClient<$Result.GetResult<Prisma.$job_typePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_types.
     * @param {job_typeDeleteManyArgs} args - Arguments to filter Job_types to delete.
     * @example
     * // Delete a few Job_types
     * const { count } = await prisma.job_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_typeDeleteManyArgs>(args?: SelectSubset<T, job_typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_types
     * const job_type = await prisma.job_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_typeUpdateManyArgs>(args: SelectSubset<T, job_typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_types and returns the data updated in the database.
     * @param {job_typeUpdateManyAndReturnArgs} args - Arguments to update many Job_types.
     * @example
     * // Update many Job_types
     * const job_type = await prisma.job_type.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Job_types and only return the `job_type_id`
     * const job_typeWithJob_type_idOnly = await prisma.job_type.updateManyAndReturn({
     *   select: { job_type_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends job_typeUpdateManyAndReturnArgs>(args: SelectSubset<T, job_typeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_typePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job_type.
     * @param {job_typeUpsertArgs} args - Arguments to update or create a Job_type.
     * @example
     * // Update or create a Job_type
     * const job_type = await prisma.job_type.upsert({
     *   create: {
     *     // ... data to create a Job_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_type we want to update
     *   }
     * })
     */
    upsert<T extends job_typeUpsertArgs>(args: SelectSubset<T, job_typeUpsertArgs<ExtArgs>>): Prisma__job_typeClient<$Result.GetResult<Prisma.$job_typePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_typeCountArgs} args - Arguments to filter Job_types to count.
     * @example
     * // Count the number of Job_types
     * const count = await prisma.job_type.count({
     *   where: {
     *     // ... the filter for the Job_types we want to count
     *   }
     * })
    **/
    count<T extends job_typeCountArgs>(
      args?: Subset<T, job_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_typeAggregateArgs>(args: Subset<T, Job_typeAggregateArgs>): Prisma.PrismaPromise<GetJob_typeAggregateType<T>>

    /**
     * Group by Job_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_typeGroupByArgs['orderBy'] }
        : { orderBy?: job_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_type model
   */
  readonly fields: job_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job_type_map<T extends job_type$job_type_mapArgs<ExtArgs> = {}>(args?: Subset<T, job_type$job_type_mapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_type_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_type model
   */
  interface job_typeFieldRefs {
    readonly job_type_id: FieldRef<"job_type", 'Int'>
    readonly job_type_name: FieldRef<"job_type", 'String'>
    readonly created_at: FieldRef<"job_type", 'DateTime'>
    readonly updated_at: FieldRef<"job_type", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * job_type findUnique
   */
  export type job_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type
     */
    select?: job_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type
     */
    omit?: job_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_typeInclude<ExtArgs> | null
    /**
     * Filter, which job_type to fetch.
     */
    where: job_typeWhereUniqueInput
  }

  /**
   * job_type findUniqueOrThrow
   */
  export type job_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type
     */
    select?: job_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type
     */
    omit?: job_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_typeInclude<ExtArgs> | null
    /**
     * Filter, which job_type to fetch.
     */
    where: job_typeWhereUniqueInput
  }

  /**
   * job_type findFirst
   */
  export type job_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type
     */
    select?: job_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type
     */
    omit?: job_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_typeInclude<ExtArgs> | null
    /**
     * Filter, which job_type to fetch.
     */
    where?: job_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_types to fetch.
     */
    orderBy?: job_typeOrderByWithRelationInput | job_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_types.
     */
    cursor?: job_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_types.
     */
    distinct?: Job_typeScalarFieldEnum | Job_typeScalarFieldEnum[]
  }

  /**
   * job_type findFirstOrThrow
   */
  export type job_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type
     */
    select?: job_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type
     */
    omit?: job_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_typeInclude<ExtArgs> | null
    /**
     * Filter, which job_type to fetch.
     */
    where?: job_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_types to fetch.
     */
    orderBy?: job_typeOrderByWithRelationInput | job_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_types.
     */
    cursor?: job_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_types.
     */
    distinct?: Job_typeScalarFieldEnum | Job_typeScalarFieldEnum[]
  }

  /**
   * job_type findMany
   */
  export type job_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type
     */
    select?: job_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type
     */
    omit?: job_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_typeInclude<ExtArgs> | null
    /**
     * Filter, which job_types to fetch.
     */
    where?: job_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_types to fetch.
     */
    orderBy?: job_typeOrderByWithRelationInput | job_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_types.
     */
    cursor?: job_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_types.
     */
    skip?: number
    distinct?: Job_typeScalarFieldEnum | Job_typeScalarFieldEnum[]
  }

  /**
   * job_type create
   */
  export type job_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type
     */
    select?: job_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type
     */
    omit?: job_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_typeInclude<ExtArgs> | null
    /**
     * The data needed to create a job_type.
     */
    data: XOR<job_typeCreateInput, job_typeUncheckedCreateInput>
  }

  /**
   * job_type createMany
   */
  export type job_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_types.
     */
    data: job_typeCreateManyInput | job_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_type createManyAndReturn
   */
  export type job_typeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type
     */
    select?: job_typeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_type
     */
    omit?: job_typeOmit<ExtArgs> | null
    /**
     * The data used to create many job_types.
     */
    data: job_typeCreateManyInput | job_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_type update
   */
  export type job_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type
     */
    select?: job_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type
     */
    omit?: job_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_typeInclude<ExtArgs> | null
    /**
     * The data needed to update a job_type.
     */
    data: XOR<job_typeUpdateInput, job_typeUncheckedUpdateInput>
    /**
     * Choose, which job_type to update.
     */
    where: job_typeWhereUniqueInput
  }

  /**
   * job_type updateMany
   */
  export type job_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_types.
     */
    data: XOR<job_typeUpdateManyMutationInput, job_typeUncheckedUpdateManyInput>
    /**
     * Filter which job_types to update
     */
    where?: job_typeWhereInput
    /**
     * Limit how many job_types to update.
     */
    limit?: number
  }

  /**
   * job_type updateManyAndReturn
   */
  export type job_typeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type
     */
    select?: job_typeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_type
     */
    omit?: job_typeOmit<ExtArgs> | null
    /**
     * The data used to update job_types.
     */
    data: XOR<job_typeUpdateManyMutationInput, job_typeUncheckedUpdateManyInput>
    /**
     * Filter which job_types to update
     */
    where?: job_typeWhereInput
    /**
     * Limit how many job_types to update.
     */
    limit?: number
  }

  /**
   * job_type upsert
   */
  export type job_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type
     */
    select?: job_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type
     */
    omit?: job_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_typeInclude<ExtArgs> | null
    /**
     * The filter to search for the job_type to update in case it exists.
     */
    where: job_typeWhereUniqueInput
    /**
     * In case the job_type found by the `where` argument doesn't exist, create a new job_type with this data.
     */
    create: XOR<job_typeCreateInput, job_typeUncheckedCreateInput>
    /**
     * In case the job_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_typeUpdateInput, job_typeUncheckedUpdateInput>
  }

  /**
   * job_type delete
   */
  export type job_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type
     */
    select?: job_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type
     */
    omit?: job_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_typeInclude<ExtArgs> | null
    /**
     * Filter which job_type to delete.
     */
    where: job_typeWhereUniqueInput
  }

  /**
   * job_type deleteMany
   */
  export type job_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_types to delete
     */
    where?: job_typeWhereInput
    /**
     * Limit how many job_types to delete.
     */
    limit?: number
  }

  /**
   * job_type.job_type_map
   */
  export type job_type$job_type_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type_map
     */
    select?: job_type_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type_map
     */
    omit?: job_type_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_type_mapInclude<ExtArgs> | null
    where?: job_type_mapWhereInput
    orderBy?: job_type_mapOrderByWithRelationInput | job_type_mapOrderByWithRelationInput[]
    cursor?: job_type_mapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_type_mapScalarFieldEnum | Job_type_mapScalarFieldEnum[]
  }

  /**
   * job_type without action
   */
  export type job_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type
     */
    select?: job_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type
     */
    omit?: job_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_typeInclude<ExtArgs> | null
  }


  /**
   * Model job_type_map
   */

  export type AggregateJob_type_map = {
    _count: Job_type_mapCountAggregateOutputType | null
    _avg: Job_type_mapAvgAggregateOutputType | null
    _sum: Job_type_mapSumAggregateOutputType | null
    _min: Job_type_mapMinAggregateOutputType | null
    _max: Job_type_mapMaxAggregateOutputType | null
  }

  export type Job_type_mapAvgAggregateOutputType = {
    job_type_map_id: number | null
    job_id: number | null
    type_id: number | null
  }

  export type Job_type_mapSumAggregateOutputType = {
    job_type_map_id: number | null
    job_id: number | null
    type_id: number | null
  }

  export type Job_type_mapMinAggregateOutputType = {
    job_type_map_id: number | null
    job_type_map_uuid: string | null
    job_id: number | null
    type_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_type_mapMaxAggregateOutputType = {
    job_type_map_id: number | null
    job_type_map_uuid: string | null
    job_id: number | null
    type_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Job_type_mapCountAggregateOutputType = {
    job_type_map_id: number
    job_type_map_uuid: number
    job_id: number
    type_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Job_type_mapAvgAggregateInputType = {
    job_type_map_id?: true
    job_id?: true
    type_id?: true
  }

  export type Job_type_mapSumAggregateInputType = {
    job_type_map_id?: true
    job_id?: true
    type_id?: true
  }

  export type Job_type_mapMinAggregateInputType = {
    job_type_map_id?: true
    job_type_map_uuid?: true
    job_id?: true
    type_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_type_mapMaxAggregateInputType = {
    job_type_map_id?: true
    job_type_map_uuid?: true
    job_id?: true
    type_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Job_type_mapCountAggregateInputType = {
    job_type_map_id?: true
    job_type_map_uuid?: true
    job_id?: true
    type_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Job_type_mapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_type_map to aggregate.
     */
    where?: job_type_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_type_maps to fetch.
     */
    orderBy?: job_type_mapOrderByWithRelationInput | job_type_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_type_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_type_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_type_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_type_maps
    **/
    _count?: true | Job_type_mapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Job_type_mapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Job_type_mapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_type_mapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_type_mapMaxAggregateInputType
  }

  export type GetJob_type_mapAggregateType<T extends Job_type_mapAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_type_map]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_type_map[P]>
      : GetScalarType<T[P], AggregateJob_type_map[P]>
  }




  export type job_type_mapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_type_mapWhereInput
    orderBy?: job_type_mapOrderByWithAggregationInput | job_type_mapOrderByWithAggregationInput[]
    by: Job_type_mapScalarFieldEnum[] | Job_type_mapScalarFieldEnum
    having?: job_type_mapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_type_mapCountAggregateInputType | true
    _avg?: Job_type_mapAvgAggregateInputType
    _sum?: Job_type_mapSumAggregateInputType
    _min?: Job_type_mapMinAggregateInputType
    _max?: Job_type_mapMaxAggregateInputType
  }

  export type Job_type_mapGroupByOutputType = {
    job_type_map_id: number
    job_type_map_uuid: string
    job_id: number
    type_id: number
    created_at: Date
    updated_at: Date
    _count: Job_type_mapCountAggregateOutputType | null
    _avg: Job_type_mapAvgAggregateOutputType | null
    _sum: Job_type_mapSumAggregateOutputType | null
    _min: Job_type_mapMinAggregateOutputType | null
    _max: Job_type_mapMaxAggregateOutputType | null
  }

  type GetJob_type_mapGroupByPayload<T extends job_type_mapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_type_mapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_type_mapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_type_mapGroupByOutputType[P]>
            : GetScalarType<T[P], Job_type_mapGroupByOutputType[P]>
        }
      >
    >


  export type job_type_mapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_type_map_id?: boolean
    job_type_map_uuid?: boolean
    job_id?: boolean
    type_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_type?: boolean | job_typeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_type_map"]>

  export type job_type_mapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_type_map_id?: boolean
    job_type_map_uuid?: boolean
    job_id?: boolean
    type_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_type?: boolean | job_typeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_type_map"]>

  export type job_type_mapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_type_map_id?: boolean
    job_type_map_uuid?: boolean
    job_id?: boolean
    type_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_type?: boolean | job_typeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_type_map"]>

  export type job_type_mapSelectScalar = {
    job_type_map_id?: boolean
    job_type_map_uuid?: boolean
    job_id?: boolean
    type_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type job_type_mapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"job_type_map_id" | "job_type_map_uuid" | "job_id" | "type_id" | "created_at" | "updated_at", ExtArgs["result"]["job_type_map"]>
  export type job_type_mapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_type?: boolean | job_typeDefaultArgs<ExtArgs>
  }
  export type job_type_mapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_type?: boolean | job_typeDefaultArgs<ExtArgs>
  }
  export type job_type_mapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | jobDefaultArgs<ExtArgs>
    job_type?: boolean | job_typeDefaultArgs<ExtArgs>
  }

  export type $job_type_mapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_type_map"
    objects: {
      job: Prisma.$jobPayload<ExtArgs>
      job_type: Prisma.$job_typePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      job_type_map_id: number
      job_type_map_uuid: string
      job_id: number
      type_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["job_type_map"]>
    composites: {}
  }

  type job_type_mapGetPayload<S extends boolean | null | undefined | job_type_mapDefaultArgs> = $Result.GetResult<Prisma.$job_type_mapPayload, S>

  type job_type_mapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_type_mapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_type_mapCountAggregateInputType | true
    }

  export interface job_type_mapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_type_map'], meta: { name: 'job_type_map' } }
    /**
     * Find zero or one Job_type_map that matches the filter.
     * @param {job_type_mapFindUniqueArgs} args - Arguments to find a Job_type_map
     * @example
     * // Get one Job_type_map
     * const job_type_map = await prisma.job_type_map.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_type_mapFindUniqueArgs>(args: SelectSubset<T, job_type_mapFindUniqueArgs<ExtArgs>>): Prisma__job_type_mapClient<$Result.GetResult<Prisma.$job_type_mapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_type_map that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_type_mapFindUniqueOrThrowArgs} args - Arguments to find a Job_type_map
     * @example
     * // Get one Job_type_map
     * const job_type_map = await prisma.job_type_map.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_type_mapFindUniqueOrThrowArgs>(args: SelectSubset<T, job_type_mapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_type_mapClient<$Result.GetResult<Prisma.$job_type_mapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_type_map that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_type_mapFindFirstArgs} args - Arguments to find a Job_type_map
     * @example
     * // Get one Job_type_map
     * const job_type_map = await prisma.job_type_map.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_type_mapFindFirstArgs>(args?: SelectSubset<T, job_type_mapFindFirstArgs<ExtArgs>>): Prisma__job_type_mapClient<$Result.GetResult<Prisma.$job_type_mapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_type_map that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_type_mapFindFirstOrThrowArgs} args - Arguments to find a Job_type_map
     * @example
     * // Get one Job_type_map
     * const job_type_map = await prisma.job_type_map.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_type_mapFindFirstOrThrowArgs>(args?: SelectSubset<T, job_type_mapFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_type_mapClient<$Result.GetResult<Prisma.$job_type_mapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_type_maps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_type_mapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_type_maps
     * const job_type_maps = await prisma.job_type_map.findMany()
     * 
     * // Get first 10 Job_type_maps
     * const job_type_maps = await prisma.job_type_map.findMany({ take: 10 })
     * 
     * // Only select the `job_type_map_id`
     * const job_type_mapWithJob_type_map_idOnly = await prisma.job_type_map.findMany({ select: { job_type_map_id: true } })
     * 
     */
    findMany<T extends job_type_mapFindManyArgs>(args?: SelectSubset<T, job_type_mapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_type_mapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_type_map.
     * @param {job_type_mapCreateArgs} args - Arguments to create a Job_type_map.
     * @example
     * // Create one Job_type_map
     * const Job_type_map = await prisma.job_type_map.create({
     *   data: {
     *     // ... data to create a Job_type_map
     *   }
     * })
     * 
     */
    create<T extends job_type_mapCreateArgs>(args: SelectSubset<T, job_type_mapCreateArgs<ExtArgs>>): Prisma__job_type_mapClient<$Result.GetResult<Prisma.$job_type_mapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_type_maps.
     * @param {job_type_mapCreateManyArgs} args - Arguments to create many Job_type_maps.
     * @example
     * // Create many Job_type_maps
     * const job_type_map = await prisma.job_type_map.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_type_mapCreateManyArgs>(args?: SelectSubset<T, job_type_mapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Job_type_maps and returns the data saved in the database.
     * @param {job_type_mapCreateManyAndReturnArgs} args - Arguments to create many Job_type_maps.
     * @example
     * // Create many Job_type_maps
     * const job_type_map = await prisma.job_type_map.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Job_type_maps and only return the `job_type_map_id`
     * const job_type_mapWithJob_type_map_idOnly = await prisma.job_type_map.createManyAndReturn({
     *   select: { job_type_map_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends job_type_mapCreateManyAndReturnArgs>(args?: SelectSubset<T, job_type_mapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_type_mapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job_type_map.
     * @param {job_type_mapDeleteArgs} args - Arguments to delete one Job_type_map.
     * @example
     * // Delete one Job_type_map
     * const Job_type_map = await prisma.job_type_map.delete({
     *   where: {
     *     // ... filter to delete one Job_type_map
     *   }
     * })
     * 
     */
    delete<T extends job_type_mapDeleteArgs>(args: SelectSubset<T, job_type_mapDeleteArgs<ExtArgs>>): Prisma__job_type_mapClient<$Result.GetResult<Prisma.$job_type_mapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_type_map.
     * @param {job_type_mapUpdateArgs} args - Arguments to update one Job_type_map.
     * @example
     * // Update one Job_type_map
     * const job_type_map = await prisma.job_type_map.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_type_mapUpdateArgs>(args: SelectSubset<T, job_type_mapUpdateArgs<ExtArgs>>): Prisma__job_type_mapClient<$Result.GetResult<Prisma.$job_type_mapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_type_maps.
     * @param {job_type_mapDeleteManyArgs} args - Arguments to filter Job_type_maps to delete.
     * @example
     * // Delete a few Job_type_maps
     * const { count } = await prisma.job_type_map.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_type_mapDeleteManyArgs>(args?: SelectSubset<T, job_type_mapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_type_maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_type_mapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_type_maps
     * const job_type_map = await prisma.job_type_map.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_type_mapUpdateManyArgs>(args: SelectSubset<T, job_type_mapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_type_maps and returns the data updated in the database.
     * @param {job_type_mapUpdateManyAndReturnArgs} args - Arguments to update many Job_type_maps.
     * @example
     * // Update many Job_type_maps
     * const job_type_map = await prisma.job_type_map.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Job_type_maps and only return the `job_type_map_id`
     * const job_type_mapWithJob_type_map_idOnly = await prisma.job_type_map.updateManyAndReturn({
     *   select: { job_type_map_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends job_type_mapUpdateManyAndReturnArgs>(args: SelectSubset<T, job_type_mapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_type_mapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job_type_map.
     * @param {job_type_mapUpsertArgs} args - Arguments to update or create a Job_type_map.
     * @example
     * // Update or create a Job_type_map
     * const job_type_map = await prisma.job_type_map.upsert({
     *   create: {
     *     // ... data to create a Job_type_map
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_type_map we want to update
     *   }
     * })
     */
    upsert<T extends job_type_mapUpsertArgs>(args: SelectSubset<T, job_type_mapUpsertArgs<ExtArgs>>): Prisma__job_type_mapClient<$Result.GetResult<Prisma.$job_type_mapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_type_maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_type_mapCountArgs} args - Arguments to filter Job_type_maps to count.
     * @example
     * // Count the number of Job_type_maps
     * const count = await prisma.job_type_map.count({
     *   where: {
     *     // ... the filter for the Job_type_maps we want to count
     *   }
     * })
    **/
    count<T extends job_type_mapCountArgs>(
      args?: Subset<T, job_type_mapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_type_mapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_type_map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_type_mapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_type_mapAggregateArgs>(args: Subset<T, Job_type_mapAggregateArgs>): Prisma.PrismaPromise<GetJob_type_mapAggregateType<T>>

    /**
     * Group by Job_type_map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_type_mapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_type_mapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_type_mapGroupByArgs['orderBy'] }
        : { orderBy?: job_type_mapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_type_mapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_type_mapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_type_map model
   */
  readonly fields: job_type_mapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_type_map.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_type_mapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends jobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobDefaultArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    job_type<T extends job_typeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, job_typeDefaultArgs<ExtArgs>>): Prisma__job_typeClient<$Result.GetResult<Prisma.$job_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_type_map model
   */
  interface job_type_mapFieldRefs {
    readonly job_type_map_id: FieldRef<"job_type_map", 'Int'>
    readonly job_type_map_uuid: FieldRef<"job_type_map", 'String'>
    readonly job_id: FieldRef<"job_type_map", 'Int'>
    readonly type_id: FieldRef<"job_type_map", 'Int'>
    readonly created_at: FieldRef<"job_type_map", 'DateTime'>
    readonly updated_at: FieldRef<"job_type_map", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * job_type_map findUnique
   */
  export type job_type_mapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type_map
     */
    select?: job_type_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type_map
     */
    omit?: job_type_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_type_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_type_map to fetch.
     */
    where: job_type_mapWhereUniqueInput
  }

  /**
   * job_type_map findUniqueOrThrow
   */
  export type job_type_mapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type_map
     */
    select?: job_type_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type_map
     */
    omit?: job_type_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_type_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_type_map to fetch.
     */
    where: job_type_mapWhereUniqueInput
  }

  /**
   * job_type_map findFirst
   */
  export type job_type_mapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type_map
     */
    select?: job_type_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type_map
     */
    omit?: job_type_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_type_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_type_map to fetch.
     */
    where?: job_type_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_type_maps to fetch.
     */
    orderBy?: job_type_mapOrderByWithRelationInput | job_type_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_type_maps.
     */
    cursor?: job_type_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_type_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_type_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_type_maps.
     */
    distinct?: Job_type_mapScalarFieldEnum | Job_type_mapScalarFieldEnum[]
  }

  /**
   * job_type_map findFirstOrThrow
   */
  export type job_type_mapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type_map
     */
    select?: job_type_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type_map
     */
    omit?: job_type_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_type_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_type_map to fetch.
     */
    where?: job_type_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_type_maps to fetch.
     */
    orderBy?: job_type_mapOrderByWithRelationInput | job_type_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_type_maps.
     */
    cursor?: job_type_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_type_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_type_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_type_maps.
     */
    distinct?: Job_type_mapScalarFieldEnum | Job_type_mapScalarFieldEnum[]
  }

  /**
   * job_type_map findMany
   */
  export type job_type_mapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type_map
     */
    select?: job_type_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type_map
     */
    omit?: job_type_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_type_mapInclude<ExtArgs> | null
    /**
     * Filter, which job_type_maps to fetch.
     */
    where?: job_type_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_type_maps to fetch.
     */
    orderBy?: job_type_mapOrderByWithRelationInput | job_type_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_type_maps.
     */
    cursor?: job_type_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_type_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_type_maps.
     */
    skip?: number
    distinct?: Job_type_mapScalarFieldEnum | Job_type_mapScalarFieldEnum[]
  }

  /**
   * job_type_map create
   */
  export type job_type_mapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type_map
     */
    select?: job_type_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type_map
     */
    omit?: job_type_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_type_mapInclude<ExtArgs> | null
    /**
     * The data needed to create a job_type_map.
     */
    data: XOR<job_type_mapCreateInput, job_type_mapUncheckedCreateInput>
  }

  /**
   * job_type_map createMany
   */
  export type job_type_mapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_type_maps.
     */
    data: job_type_mapCreateManyInput | job_type_mapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_type_map createManyAndReturn
   */
  export type job_type_mapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type_map
     */
    select?: job_type_mapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_type_map
     */
    omit?: job_type_mapOmit<ExtArgs> | null
    /**
     * The data used to create many job_type_maps.
     */
    data: job_type_mapCreateManyInput | job_type_mapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_type_mapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_type_map update
   */
  export type job_type_mapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type_map
     */
    select?: job_type_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type_map
     */
    omit?: job_type_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_type_mapInclude<ExtArgs> | null
    /**
     * The data needed to update a job_type_map.
     */
    data: XOR<job_type_mapUpdateInput, job_type_mapUncheckedUpdateInput>
    /**
     * Choose, which job_type_map to update.
     */
    where: job_type_mapWhereUniqueInput
  }

  /**
   * job_type_map updateMany
   */
  export type job_type_mapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_type_maps.
     */
    data: XOR<job_type_mapUpdateManyMutationInput, job_type_mapUncheckedUpdateManyInput>
    /**
     * Filter which job_type_maps to update
     */
    where?: job_type_mapWhereInput
    /**
     * Limit how many job_type_maps to update.
     */
    limit?: number
  }

  /**
   * job_type_map updateManyAndReturn
   */
  export type job_type_mapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type_map
     */
    select?: job_type_mapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_type_map
     */
    omit?: job_type_mapOmit<ExtArgs> | null
    /**
     * The data used to update job_type_maps.
     */
    data: XOR<job_type_mapUpdateManyMutationInput, job_type_mapUncheckedUpdateManyInput>
    /**
     * Filter which job_type_maps to update
     */
    where?: job_type_mapWhereInput
    /**
     * Limit how many job_type_maps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_type_mapIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_type_map upsert
   */
  export type job_type_mapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type_map
     */
    select?: job_type_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type_map
     */
    omit?: job_type_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_type_mapInclude<ExtArgs> | null
    /**
     * The filter to search for the job_type_map to update in case it exists.
     */
    where: job_type_mapWhereUniqueInput
    /**
     * In case the job_type_map found by the `where` argument doesn't exist, create a new job_type_map with this data.
     */
    create: XOR<job_type_mapCreateInput, job_type_mapUncheckedCreateInput>
    /**
     * In case the job_type_map was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_type_mapUpdateInput, job_type_mapUncheckedUpdateInput>
  }

  /**
   * job_type_map delete
   */
  export type job_type_mapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type_map
     */
    select?: job_type_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type_map
     */
    omit?: job_type_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_type_mapInclude<ExtArgs> | null
    /**
     * Filter which job_type_map to delete.
     */
    where: job_type_mapWhereUniqueInput
  }

  /**
   * job_type_map deleteMany
   */
  export type job_type_mapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_type_maps to delete
     */
    where?: job_type_mapWhereInput
    /**
     * Limit how many job_type_maps to delete.
     */
    limit?: number
  }

  /**
   * job_type_map without action
   */
  export type job_type_mapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_type_map
     */
    select?: job_type_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_type_map
     */
    omit?: job_type_mapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_type_mapInclude<ExtArgs> | null
  }


  /**
   * Model city
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    city_id: number | null
    state_id: number | null
  }

  export type CitySumAggregateOutputType = {
    city_id: number | null
    state_id: number | null
  }

  export type CityMinAggregateOutputType = {
    city_id: number | null
    city_name: string | null
    state_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CityMaxAggregateOutputType = {
    city_id: number | null
    city_name: string | null
    state_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CityCountAggregateOutputType = {
    city_id: number
    city_name: number
    state_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    city_id?: true
    state_id?: true
  }

  export type CitySumAggregateInputType = {
    city_id?: true
    state_id?: true
  }

  export type CityMinAggregateInputType = {
    city_id?: true
    city_name?: true
    state_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CityMaxAggregateInputType = {
    city_id?: true
    city_name?: true
    state_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CityCountAggregateInputType = {
    city_id?: true
    city_name?: true
    state_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which city to aggregate.
     */
    where?: cityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: cityOrderByWithRelationInput | cityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type cityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cityWhereInput
    orderBy?: cityOrderByWithAggregationInput | cityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: cityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    city_id: number
    city_name: string
    state_id: number
    created_at: Date
    updated_at: Date
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends cityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type citySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    city_id?: boolean
    city_name?: boolean
    state_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    company?: boolean | city$companyArgs<ExtArgs>
    job?: boolean | city$jobArgs<ExtArgs>
    state?: boolean | stateDefaultArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type citySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    city_id?: boolean
    city_name?: boolean
    state_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    state?: boolean | stateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type citySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    city_id?: boolean
    city_name?: boolean
    state_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    state?: boolean | stateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type citySelectScalar = {
    city_id?: boolean
    city_name?: boolean
    state_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type cityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"city_id" | "city_name" | "state_id" | "created_at" | "updated_at", ExtArgs["result"]["city"]>
  export type cityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | city$companyArgs<ExtArgs>
    job?: boolean | city$jobArgs<ExtArgs>
    state?: boolean | stateDefaultArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type cityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    state?: boolean | stateDefaultArgs<ExtArgs>
  }
  export type cityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    state?: boolean | stateDefaultArgs<ExtArgs>
  }

  export type $cityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "city"
    objects: {
      company: Prisma.$companyPayload<ExtArgs>[]
      job: Prisma.$jobPayload<ExtArgs>[]
      state: Prisma.$statePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      city_id: number
      city_name: string
      state_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["city"]>
    composites: {}
  }

  type cityGetPayload<S extends boolean | null | undefined | cityDefaultArgs> = $Result.GetResult<Prisma.$cityPayload, S>

  type cityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface cityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['city'], meta: { name: 'city' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {cityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cityFindUniqueArgs>(args: SelectSubset<T, cityFindUniqueArgs<ExtArgs>>): Prisma__cityClient<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one City that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cityFindUniqueOrThrowArgs>(args: SelectSubset<T, cityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cityClient<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cityFindFirstArgs>(args?: SelectSubset<T, cityFindFirstArgs<ExtArgs>>): Prisma__cityClient<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cityFindFirstOrThrowArgs>(args?: SelectSubset<T, cityFindFirstOrThrowArgs<ExtArgs>>): Prisma__cityClient<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `city_id`
     * const cityWithCity_idOnly = await prisma.city.findMany({ select: { city_id: true } })
     * 
     */
    findMany<T extends cityFindManyArgs>(args?: SelectSubset<T, cityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a City.
     * @param {cityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
     */
    create<T extends cityCreateArgs>(args: SelectSubset<T, cityCreateArgs<ExtArgs>>): Prisma__cityClient<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cities.
     * @param {cityCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cityCreateManyArgs>(args?: SelectSubset<T, cityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cities and returns the data saved in the database.
     * @param {cityCreateManyAndReturnArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cities and only return the `city_id`
     * const cityWithCity_idOnly = await prisma.city.createManyAndReturn({
     *   select: { city_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cityCreateManyAndReturnArgs>(args?: SelectSubset<T, cityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a City.
     * @param {cityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
     */
    delete<T extends cityDeleteArgs>(args: SelectSubset<T, cityDeleteArgs<ExtArgs>>): Prisma__cityClient<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one City.
     * @param {cityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cityUpdateArgs>(args: SelectSubset<T, cityUpdateArgs<ExtArgs>>): Prisma__cityClient<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cities.
     * @param {cityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cityDeleteManyArgs>(args?: SelectSubset<T, cityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cityUpdateManyArgs>(args: SelectSubset<T, cityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities and returns the data updated in the database.
     * @param {cityUpdateManyAndReturnArgs} args - Arguments to update many Cities.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cities and only return the `city_id`
     * const cityWithCity_idOnly = await prisma.city.updateManyAndReturn({
     *   select: { city_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cityUpdateManyAndReturnArgs>(args: SelectSubset<T, cityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one City.
     * @param {cityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
     */
    upsert<T extends cityUpsertArgs>(args: SelectSubset<T, cityUpsertArgs<ExtArgs>>): Prisma__cityClient<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends cityCountArgs>(
      args?: Subset<T, cityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cityGroupByArgs['orderBy'] }
        : { orderBy?: cityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the city model
   */
  readonly fields: cityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for city.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends city$companyArgs<ExtArgs> = {}>(args?: Subset<T, city$companyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    job<T extends city$jobArgs<ExtArgs> = {}>(args?: Subset<T, city$jobArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    state<T extends stateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, stateDefaultArgs<ExtArgs>>): Prisma__stateClient<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the city model
   */
  interface cityFieldRefs {
    readonly city_id: FieldRef<"city", 'Int'>
    readonly city_name: FieldRef<"city", 'String'>
    readonly state_id: FieldRef<"city", 'Int'>
    readonly created_at: FieldRef<"city", 'DateTime'>
    readonly updated_at: FieldRef<"city", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * city findUnique
   */
  export type cityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * Omit specific fields from the city
     */
    omit?: cityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cityInclude<ExtArgs> | null
    /**
     * Filter, which city to fetch.
     */
    where: cityWhereUniqueInput
  }

  /**
   * city findUniqueOrThrow
   */
  export type cityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * Omit specific fields from the city
     */
    omit?: cityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cityInclude<ExtArgs> | null
    /**
     * Filter, which city to fetch.
     */
    where: cityWhereUniqueInput
  }

  /**
   * city findFirst
   */
  export type cityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * Omit specific fields from the city
     */
    omit?: cityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cityInclude<ExtArgs> | null
    /**
     * Filter, which city to fetch.
     */
    where?: cityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: cityOrderByWithRelationInput | cityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cities.
     */
    cursor?: cityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * city findFirstOrThrow
   */
  export type cityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * Omit specific fields from the city
     */
    omit?: cityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cityInclude<ExtArgs> | null
    /**
     * Filter, which city to fetch.
     */
    where?: cityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: cityOrderByWithRelationInput | cityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cities.
     */
    cursor?: cityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * city findMany
   */
  export type cityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * Omit specific fields from the city
     */
    omit?: cityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cityInclude<ExtArgs> | null
    /**
     * Filter, which cities to fetch.
     */
    where?: cityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: cityOrderByWithRelationInput | cityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cities.
     */
    cursor?: cityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * city create
   */
  export type cityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * Omit specific fields from the city
     */
    omit?: cityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cityInclude<ExtArgs> | null
    /**
     * The data needed to create a city.
     */
    data: XOR<cityCreateInput, cityUncheckedCreateInput>
  }

  /**
   * city createMany
   */
  export type cityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cities.
     */
    data: cityCreateManyInput | cityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * city createManyAndReturn
   */
  export type cityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the city
     */
    omit?: cityOmit<ExtArgs> | null
    /**
     * The data used to create many cities.
     */
    data: cityCreateManyInput | cityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * city update
   */
  export type cityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * Omit specific fields from the city
     */
    omit?: cityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cityInclude<ExtArgs> | null
    /**
     * The data needed to update a city.
     */
    data: XOR<cityUpdateInput, cityUncheckedUpdateInput>
    /**
     * Choose, which city to update.
     */
    where: cityWhereUniqueInput
  }

  /**
   * city updateMany
   */
  export type cityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cities.
     */
    data: XOR<cityUpdateManyMutationInput, cityUncheckedUpdateManyInput>
    /**
     * Filter which cities to update
     */
    where?: cityWhereInput
    /**
     * Limit how many cities to update.
     */
    limit?: number
  }

  /**
   * city updateManyAndReturn
   */
  export type cityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the city
     */
    omit?: cityOmit<ExtArgs> | null
    /**
     * The data used to update cities.
     */
    data: XOR<cityUpdateManyMutationInput, cityUncheckedUpdateManyInput>
    /**
     * Filter which cities to update
     */
    where?: cityWhereInput
    /**
     * Limit how many cities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * city upsert
   */
  export type cityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * Omit specific fields from the city
     */
    omit?: cityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cityInclude<ExtArgs> | null
    /**
     * The filter to search for the city to update in case it exists.
     */
    where: cityWhereUniqueInput
    /**
     * In case the city found by the `where` argument doesn't exist, create a new city with this data.
     */
    create: XOR<cityCreateInput, cityUncheckedCreateInput>
    /**
     * In case the city was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cityUpdateInput, cityUncheckedUpdateInput>
  }

  /**
   * city delete
   */
  export type cityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * Omit specific fields from the city
     */
    omit?: cityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cityInclude<ExtArgs> | null
    /**
     * Filter which city to delete.
     */
    where: cityWhereUniqueInput
  }

  /**
   * city deleteMany
   */
  export type cityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cities to delete
     */
    where?: cityWhereInput
    /**
     * Limit how many cities to delete.
     */
    limit?: number
  }

  /**
   * city.company
   */
  export type city$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company
     */
    omit?: companyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyInclude<ExtArgs> | null
    where?: companyWhereInput
    orderBy?: companyOrderByWithRelationInput | companyOrderByWithRelationInput[]
    cursor?: companyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * city.job
   */
  export type city$jobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    where?: jobWhereInput
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    cursor?: jobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * city without action
   */
  export type cityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * Omit specific fields from the city
     */
    omit?: cityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cityInclude<ExtArgs> | null
  }


  /**
   * Model country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryAvgAggregateOutputType = {
    country_id: number | null
  }

  export type CountrySumAggregateOutputType = {
    country_id: number | null
  }

  export type CountryMinAggregateOutputType = {
    country_id: number | null
    country_name: string | null
    country_code: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CountryMaxAggregateOutputType = {
    country_id: number | null
    country_name: string | null
    country_code: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CountryCountAggregateOutputType = {
    country_id: number
    country_name: number
    country_code: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CountryAvgAggregateInputType = {
    country_id?: true
  }

  export type CountrySumAggregateInputType = {
    country_id?: true
  }

  export type CountryMinAggregateInputType = {
    country_id?: true
    country_name?: true
    country_code?: true
    created_at?: true
    updated_at?: true
  }

  export type CountryMaxAggregateInputType = {
    country_id?: true
    country_name?: true
    country_code?: true
    created_at?: true
    updated_at?: true
  }

  export type CountryCountAggregateInputType = {
    country_id?: true
    country_name?: true
    country_code?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which country to aggregate.
     */
    where?: countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countryOrderByWithRelationInput | countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type countryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: countryWhereInput
    orderBy?: countryOrderByWithAggregationInput | countryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: countryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _avg?: CountryAvgAggregateInputType
    _sum?: CountrySumAggregateInputType
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    country_id: number
    country_name: string
    country_code: string
    created_at: Date
    updated_at: Date
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends countryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type countrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    country_id?: boolean
    country_name?: boolean
    country_code?: boolean
    created_at?: boolean
    updated_at?: boolean
    company?: boolean | country$companyArgs<ExtArgs>
    job?: boolean | country$jobArgs<ExtArgs>
    state?: boolean | country$stateArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>

  export type countrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    country_id?: boolean
    country_name?: boolean
    country_code?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["country"]>

  export type countrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    country_id?: boolean
    country_name?: boolean
    country_code?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["country"]>

  export type countrySelectScalar = {
    country_id?: boolean
    country_name?: boolean
    country_code?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type countryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"country_id" | "country_name" | "country_code" | "created_at" | "updated_at", ExtArgs["result"]["country"]>
  export type countryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | country$companyArgs<ExtArgs>
    job?: boolean | country$jobArgs<ExtArgs>
    state?: boolean | country$stateArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type countryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type countryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $countryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "country"
    objects: {
      company: Prisma.$companyPayload<ExtArgs>[]
      job: Prisma.$jobPayload<ExtArgs>[]
      state: Prisma.$statePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      country_id: number
      country_name: string
      country_code: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["country"]>
    composites: {}
  }

  type countryGetPayload<S extends boolean | null | undefined | countryDefaultArgs> = $Result.GetResult<Prisma.$countryPayload, S>

  type countryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<countryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface countryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['country'], meta: { name: 'country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {countryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends countryFindUniqueArgs>(args: SelectSubset<T, countryFindUniqueArgs<ExtArgs>>): Prisma__countryClient<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Country that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {countryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends countryFindUniqueOrThrowArgs>(args: SelectSubset<T, countryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__countryClient<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends countryFindFirstArgs>(args?: SelectSubset<T, countryFindFirstArgs<ExtArgs>>): Prisma__countryClient<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends countryFindFirstOrThrowArgs>(args?: SelectSubset<T, countryFindFirstOrThrowArgs<ExtArgs>>): Prisma__countryClient<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `country_id`
     * const countryWithCountry_idOnly = await prisma.country.findMany({ select: { country_id: true } })
     * 
     */
    findMany<T extends countryFindManyArgs>(args?: SelectSubset<T, countryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Country.
     * @param {countryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
     */
    create<T extends countryCreateArgs>(args: SelectSubset<T, countryCreateArgs<ExtArgs>>): Prisma__countryClient<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Countries.
     * @param {countryCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends countryCreateManyArgs>(args?: SelectSubset<T, countryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Countries and returns the data saved in the database.
     * @param {countryCreateManyAndReturnArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Countries and only return the `country_id`
     * const countryWithCountry_idOnly = await prisma.country.createManyAndReturn({
     *   select: { country_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends countryCreateManyAndReturnArgs>(args?: SelectSubset<T, countryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Country.
     * @param {countryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
     */
    delete<T extends countryDeleteArgs>(args: SelectSubset<T, countryDeleteArgs<ExtArgs>>): Prisma__countryClient<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Country.
     * @param {countryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends countryUpdateArgs>(args: SelectSubset<T, countryUpdateArgs<ExtArgs>>): Prisma__countryClient<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Countries.
     * @param {countryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends countryDeleteManyArgs>(args?: SelectSubset<T, countryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends countryUpdateManyArgs>(args: SelectSubset<T, countryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries and returns the data updated in the database.
     * @param {countryUpdateManyAndReturnArgs} args - Arguments to update many Countries.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Countries and only return the `country_id`
     * const countryWithCountry_idOnly = await prisma.country.updateManyAndReturn({
     *   select: { country_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends countryUpdateManyAndReturnArgs>(args: SelectSubset<T, countryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Country.
     * @param {countryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
     */
    upsert<T extends countryUpsertArgs>(args: SelectSubset<T, countryUpsertArgs<ExtArgs>>): Prisma__countryClient<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends countryCountArgs>(
      args?: Subset<T, countryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends countryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: countryGroupByArgs['orderBy'] }
        : { orderBy?: countryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, countryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the country model
   */
  readonly fields: countryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__countryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends country$companyArgs<ExtArgs> = {}>(args?: Subset<T, country$companyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    job<T extends country$jobArgs<ExtArgs> = {}>(args?: Subset<T, country$jobArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    state<T extends country$stateArgs<ExtArgs> = {}>(args?: Subset<T, country$stateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the country model
   */
  interface countryFieldRefs {
    readonly country_id: FieldRef<"country", 'Int'>
    readonly country_name: FieldRef<"country", 'String'>
    readonly country_code: FieldRef<"country", 'String'>
    readonly created_at: FieldRef<"country", 'DateTime'>
    readonly updated_at: FieldRef<"country", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * country findUnique
   */
  export type countryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the country
     */
    omit?: countryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: countryInclude<ExtArgs> | null
    /**
     * Filter, which country to fetch.
     */
    where: countryWhereUniqueInput
  }

  /**
   * country findUniqueOrThrow
   */
  export type countryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the country
     */
    omit?: countryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: countryInclude<ExtArgs> | null
    /**
     * Filter, which country to fetch.
     */
    where: countryWhereUniqueInput
  }

  /**
   * country findFirst
   */
  export type countryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the country
     */
    omit?: countryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: countryInclude<ExtArgs> | null
    /**
     * Filter, which country to fetch.
     */
    where?: countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countryOrderByWithRelationInput | countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for countries.
     */
    cursor?: countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * country findFirstOrThrow
   */
  export type countryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the country
     */
    omit?: countryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: countryInclude<ExtArgs> | null
    /**
     * Filter, which country to fetch.
     */
    where?: countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countryOrderByWithRelationInput | countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for countries.
     */
    cursor?: countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * country findMany
   */
  export type countryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the country
     */
    omit?: countryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: countryInclude<ExtArgs> | null
    /**
     * Filter, which countries to fetch.
     */
    where?: countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     */
    orderBy?: countryOrderByWithRelationInput | countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing countries.
     */
    cursor?: countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * country create
   */
  export type countryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the country
     */
    omit?: countryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: countryInclude<ExtArgs> | null
    /**
     * The data needed to create a country.
     */
    data: XOR<countryCreateInput, countryUncheckedCreateInput>
  }

  /**
   * country createMany
   */
  export type countryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many countries.
     */
    data: countryCreateManyInput | countryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * country createManyAndReturn
   */
  export type countryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the country
     */
    omit?: countryOmit<ExtArgs> | null
    /**
     * The data used to create many countries.
     */
    data: countryCreateManyInput | countryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * country update
   */
  export type countryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the country
     */
    omit?: countryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: countryInclude<ExtArgs> | null
    /**
     * The data needed to update a country.
     */
    data: XOR<countryUpdateInput, countryUncheckedUpdateInput>
    /**
     * Choose, which country to update.
     */
    where: countryWhereUniqueInput
  }

  /**
   * country updateMany
   */
  export type countryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update countries.
     */
    data: XOR<countryUpdateManyMutationInput, countryUncheckedUpdateManyInput>
    /**
     * Filter which countries to update
     */
    where?: countryWhereInput
    /**
     * Limit how many countries to update.
     */
    limit?: number
  }

  /**
   * country updateManyAndReturn
   */
  export type countryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the country
     */
    omit?: countryOmit<ExtArgs> | null
    /**
     * The data used to update countries.
     */
    data: XOR<countryUpdateManyMutationInput, countryUncheckedUpdateManyInput>
    /**
     * Filter which countries to update
     */
    where?: countryWhereInput
    /**
     * Limit how many countries to update.
     */
    limit?: number
  }

  /**
   * country upsert
   */
  export type countryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the country
     */
    omit?: countryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: countryInclude<ExtArgs> | null
    /**
     * The filter to search for the country to update in case it exists.
     */
    where: countryWhereUniqueInput
    /**
     * In case the country found by the `where` argument doesn't exist, create a new country with this data.
     */
    create: XOR<countryCreateInput, countryUncheckedCreateInput>
    /**
     * In case the country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<countryUpdateInput, countryUncheckedUpdateInput>
  }

  /**
   * country delete
   */
  export type countryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the country
     */
    omit?: countryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: countryInclude<ExtArgs> | null
    /**
     * Filter which country to delete.
     */
    where: countryWhereUniqueInput
  }

  /**
   * country deleteMany
   */
  export type countryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which countries to delete
     */
    where?: countryWhereInput
    /**
     * Limit how many countries to delete.
     */
    limit?: number
  }

  /**
   * country.company
   */
  export type country$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company
     */
    omit?: companyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyInclude<ExtArgs> | null
    where?: companyWhereInput
    orderBy?: companyOrderByWithRelationInput | companyOrderByWithRelationInput[]
    cursor?: companyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * country.job
   */
  export type country$jobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    where?: jobWhereInput
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    cursor?: jobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * country.state
   */
  export type country$stateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state
     */
    omit?: stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stateInclude<ExtArgs> | null
    where?: stateWhereInput
    orderBy?: stateOrderByWithRelationInput | stateOrderByWithRelationInput[]
    cursor?: stateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StateScalarFieldEnum | StateScalarFieldEnum[]
  }

  /**
   * country without action
   */
  export type countryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the country
     */
    select?: countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the country
     */
    omit?: countryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: countryInclude<ExtArgs> | null
  }


  /**
   * Model state
   */

  export type AggregateState = {
    _count: StateCountAggregateOutputType | null
    _avg: StateAvgAggregateOutputType | null
    _sum: StateSumAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  export type StateAvgAggregateOutputType = {
    state_id: number | null
    country_id: number | null
  }

  export type StateSumAggregateOutputType = {
    state_id: number | null
    country_id: number | null
  }

  export type StateMinAggregateOutputType = {
    state_id: number | null
    state_name: string | null
    state_code: string | null
    country_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StateMaxAggregateOutputType = {
    state_id: number | null
    state_name: string | null
    state_code: string | null
    country_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StateCountAggregateOutputType = {
    state_id: number
    state_name: number
    state_code: number
    country_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type StateAvgAggregateInputType = {
    state_id?: true
    country_id?: true
  }

  export type StateSumAggregateInputType = {
    state_id?: true
    country_id?: true
  }

  export type StateMinAggregateInputType = {
    state_id?: true
    state_name?: true
    state_code?: true
    country_id?: true
    created_at?: true
    updated_at?: true
  }

  export type StateMaxAggregateInputType = {
    state_id?: true
    state_name?: true
    state_code?: true
    country_id?: true
    created_at?: true
    updated_at?: true
  }

  export type StateCountAggregateInputType = {
    state_id?: true
    state_name?: true
    state_code?: true
    country_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type StateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which state to aggregate.
     */
    where?: stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of states to fetch.
     */
    orderBy?: stateOrderByWithRelationInput | stateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned states
    **/
    _count?: true | StateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StateMaxAggregateInputType
  }

  export type GetStateAggregateType<T extends StateAggregateArgs> = {
        [P in keyof T & keyof AggregateState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateState[P]>
      : GetScalarType<T[P], AggregateState[P]>
  }




  export type stateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: stateWhereInput
    orderBy?: stateOrderByWithAggregationInput | stateOrderByWithAggregationInput[]
    by: StateScalarFieldEnum[] | StateScalarFieldEnum
    having?: stateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StateCountAggregateInputType | true
    _avg?: StateAvgAggregateInputType
    _sum?: StateSumAggregateInputType
    _min?: StateMinAggregateInputType
    _max?: StateMaxAggregateInputType
  }

  export type StateGroupByOutputType = {
    state_id: number
    state_name: string
    state_code: string | null
    country_id: number
    created_at: Date
    updated_at: Date
    _count: StateCountAggregateOutputType | null
    _avg: StateAvgAggregateOutputType | null
    _sum: StateSumAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  type GetStateGroupByPayload<T extends stateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StateGroupByOutputType[P]>
            : GetScalarType<T[P], StateGroupByOutputType[P]>
        }
      >
    >


  export type stateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    state_id?: boolean
    state_name?: boolean
    state_code?: boolean
    country_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    company?: boolean | state$companyArgs<ExtArgs>
    job?: boolean | state$jobArgs<ExtArgs>
    city?: boolean | state$cityArgs<ExtArgs>
    country?: boolean | countryDefaultArgs<ExtArgs>
    _count?: boolean | StateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["state"]>

  export type stateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    state_id?: boolean
    state_name?: boolean
    state_code?: boolean
    country_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    country?: boolean | countryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["state"]>

  export type stateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    state_id?: boolean
    state_name?: boolean
    state_code?: boolean
    country_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    country?: boolean | countryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["state"]>

  export type stateSelectScalar = {
    state_id?: boolean
    state_name?: boolean
    state_code?: boolean
    country_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type stateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"state_id" | "state_name" | "state_code" | "country_id" | "created_at" | "updated_at", ExtArgs["result"]["state"]>
  export type stateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | state$companyArgs<ExtArgs>
    job?: boolean | state$jobArgs<ExtArgs>
    city?: boolean | state$cityArgs<ExtArgs>
    country?: boolean | countryDefaultArgs<ExtArgs>
    _count?: boolean | StateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type stateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | countryDefaultArgs<ExtArgs>
  }
  export type stateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | countryDefaultArgs<ExtArgs>
  }

  export type $statePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "state"
    objects: {
      company: Prisma.$companyPayload<ExtArgs>[]
      job: Prisma.$jobPayload<ExtArgs>[]
      city: Prisma.$cityPayload<ExtArgs>[]
      country: Prisma.$countryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      state_id: number
      state_name: string
      state_code: string | null
      country_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["state"]>
    composites: {}
  }

  type stateGetPayload<S extends boolean | null | undefined | stateDefaultArgs> = $Result.GetResult<Prisma.$statePayload, S>

  type stateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<stateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StateCountAggregateInputType | true
    }

  export interface stateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['state'], meta: { name: 'state' } }
    /**
     * Find zero or one State that matches the filter.
     * @param {stateFindUniqueArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends stateFindUniqueArgs>(args: SelectSubset<T, stateFindUniqueArgs<ExtArgs>>): Prisma__stateClient<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one State that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {stateFindUniqueOrThrowArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends stateFindUniqueOrThrowArgs>(args: SelectSubset<T, stateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__stateClient<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first State that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stateFindFirstArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends stateFindFirstArgs>(args?: SelectSubset<T, stateFindFirstArgs<ExtArgs>>): Prisma__stateClient<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first State that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stateFindFirstOrThrowArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends stateFindFirstOrThrowArgs>(args?: SelectSubset<T, stateFindFirstOrThrowArgs<ExtArgs>>): Prisma__stateClient<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more States that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all States
     * const states = await prisma.state.findMany()
     * 
     * // Get first 10 States
     * const states = await prisma.state.findMany({ take: 10 })
     * 
     * // Only select the `state_id`
     * const stateWithState_idOnly = await prisma.state.findMany({ select: { state_id: true } })
     * 
     */
    findMany<T extends stateFindManyArgs>(args?: SelectSubset<T, stateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a State.
     * @param {stateCreateArgs} args - Arguments to create a State.
     * @example
     * // Create one State
     * const State = await prisma.state.create({
     *   data: {
     *     // ... data to create a State
     *   }
     * })
     * 
     */
    create<T extends stateCreateArgs>(args: SelectSubset<T, stateCreateArgs<ExtArgs>>): Prisma__stateClient<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many States.
     * @param {stateCreateManyArgs} args - Arguments to create many States.
     * @example
     * // Create many States
     * const state = await prisma.state.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends stateCreateManyArgs>(args?: SelectSubset<T, stateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many States and returns the data saved in the database.
     * @param {stateCreateManyAndReturnArgs} args - Arguments to create many States.
     * @example
     * // Create many States
     * const state = await prisma.state.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many States and only return the `state_id`
     * const stateWithState_idOnly = await prisma.state.createManyAndReturn({
     *   select: { state_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends stateCreateManyAndReturnArgs>(args?: SelectSubset<T, stateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a State.
     * @param {stateDeleteArgs} args - Arguments to delete one State.
     * @example
     * // Delete one State
     * const State = await prisma.state.delete({
     *   where: {
     *     // ... filter to delete one State
     *   }
     * })
     * 
     */
    delete<T extends stateDeleteArgs>(args: SelectSubset<T, stateDeleteArgs<ExtArgs>>): Prisma__stateClient<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one State.
     * @param {stateUpdateArgs} args - Arguments to update one State.
     * @example
     * // Update one State
     * const state = await prisma.state.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends stateUpdateArgs>(args: SelectSubset<T, stateUpdateArgs<ExtArgs>>): Prisma__stateClient<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more States.
     * @param {stateDeleteManyArgs} args - Arguments to filter States to delete.
     * @example
     * // Delete a few States
     * const { count } = await prisma.state.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends stateDeleteManyArgs>(args?: SelectSubset<T, stateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many States
     * const state = await prisma.state.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends stateUpdateManyArgs>(args: SelectSubset<T, stateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more States and returns the data updated in the database.
     * @param {stateUpdateManyAndReturnArgs} args - Arguments to update many States.
     * @example
     * // Update many States
     * const state = await prisma.state.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more States and only return the `state_id`
     * const stateWithState_idOnly = await prisma.state.updateManyAndReturn({
     *   select: { state_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends stateUpdateManyAndReturnArgs>(args: SelectSubset<T, stateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one State.
     * @param {stateUpsertArgs} args - Arguments to update or create a State.
     * @example
     * // Update or create a State
     * const state = await prisma.state.upsert({
     *   create: {
     *     // ... data to create a State
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the State we want to update
     *   }
     * })
     */
    upsert<T extends stateUpsertArgs>(args: SelectSubset<T, stateUpsertArgs<ExtArgs>>): Prisma__stateClient<$Result.GetResult<Prisma.$statePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stateCountArgs} args - Arguments to filter States to count.
     * @example
     * // Count the number of States
     * const count = await prisma.state.count({
     *   where: {
     *     // ... the filter for the States we want to count
     *   }
     * })
    **/
    count<T extends stateCountArgs>(
      args?: Subset<T, stateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StateAggregateArgs>(args: Subset<T, StateAggregateArgs>): Prisma.PrismaPromise<GetStateAggregateType<T>>

    /**
     * Group by State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends stateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: stateGroupByArgs['orderBy'] }
        : { orderBy?: stateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, stateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the state model
   */
  readonly fields: stateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for state.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__stateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends state$companyArgs<ExtArgs> = {}>(args?: Subset<T, state$companyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    job<T extends state$jobArgs<ExtArgs> = {}>(args?: Subset<T, state$jobArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    city<T extends state$cityArgs<ExtArgs> = {}>(args?: Subset<T, state$cityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    country<T extends countryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, countryDefaultArgs<ExtArgs>>): Prisma__countryClient<$Result.GetResult<Prisma.$countryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the state model
   */
  interface stateFieldRefs {
    readonly state_id: FieldRef<"state", 'Int'>
    readonly state_name: FieldRef<"state", 'String'>
    readonly state_code: FieldRef<"state", 'String'>
    readonly country_id: FieldRef<"state", 'Int'>
    readonly created_at: FieldRef<"state", 'DateTime'>
    readonly updated_at: FieldRef<"state", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * state findUnique
   */
  export type stateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state
     */
    omit?: stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stateInclude<ExtArgs> | null
    /**
     * Filter, which state to fetch.
     */
    where: stateWhereUniqueInput
  }

  /**
   * state findUniqueOrThrow
   */
  export type stateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state
     */
    omit?: stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stateInclude<ExtArgs> | null
    /**
     * Filter, which state to fetch.
     */
    where: stateWhereUniqueInput
  }

  /**
   * state findFirst
   */
  export type stateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state
     */
    omit?: stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stateInclude<ExtArgs> | null
    /**
     * Filter, which state to fetch.
     */
    where?: stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of states to fetch.
     */
    orderBy?: stateOrderByWithRelationInput | stateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for states.
     */
    cursor?: stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of states.
     */
    distinct?: StateScalarFieldEnum | StateScalarFieldEnum[]
  }

  /**
   * state findFirstOrThrow
   */
  export type stateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state
     */
    omit?: stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stateInclude<ExtArgs> | null
    /**
     * Filter, which state to fetch.
     */
    where?: stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of states to fetch.
     */
    orderBy?: stateOrderByWithRelationInput | stateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for states.
     */
    cursor?: stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of states.
     */
    distinct?: StateScalarFieldEnum | StateScalarFieldEnum[]
  }

  /**
   * state findMany
   */
  export type stateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state
     */
    omit?: stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stateInclude<ExtArgs> | null
    /**
     * Filter, which states to fetch.
     */
    where?: stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of states to fetch.
     */
    orderBy?: stateOrderByWithRelationInput | stateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing states.
     */
    cursor?: stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` states.
     */
    skip?: number
    distinct?: StateScalarFieldEnum | StateScalarFieldEnum[]
  }

  /**
   * state create
   */
  export type stateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state
     */
    omit?: stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stateInclude<ExtArgs> | null
    /**
     * The data needed to create a state.
     */
    data: XOR<stateCreateInput, stateUncheckedCreateInput>
  }

  /**
   * state createMany
   */
  export type stateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many states.
     */
    data: stateCreateManyInput | stateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * state createManyAndReturn
   */
  export type stateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the state
     */
    omit?: stateOmit<ExtArgs> | null
    /**
     * The data used to create many states.
     */
    data: stateCreateManyInput | stateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * state update
   */
  export type stateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state
     */
    omit?: stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stateInclude<ExtArgs> | null
    /**
     * The data needed to update a state.
     */
    data: XOR<stateUpdateInput, stateUncheckedUpdateInput>
    /**
     * Choose, which state to update.
     */
    where: stateWhereUniqueInput
  }

  /**
   * state updateMany
   */
  export type stateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update states.
     */
    data: XOR<stateUpdateManyMutationInput, stateUncheckedUpdateManyInput>
    /**
     * Filter which states to update
     */
    where?: stateWhereInput
    /**
     * Limit how many states to update.
     */
    limit?: number
  }

  /**
   * state updateManyAndReturn
   */
  export type stateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the state
     */
    omit?: stateOmit<ExtArgs> | null
    /**
     * The data used to update states.
     */
    data: XOR<stateUpdateManyMutationInput, stateUncheckedUpdateManyInput>
    /**
     * Filter which states to update
     */
    where?: stateWhereInput
    /**
     * Limit how many states to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * state upsert
   */
  export type stateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state
     */
    omit?: stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stateInclude<ExtArgs> | null
    /**
     * The filter to search for the state to update in case it exists.
     */
    where: stateWhereUniqueInput
    /**
     * In case the state found by the `where` argument doesn't exist, create a new state with this data.
     */
    create: XOR<stateCreateInput, stateUncheckedCreateInput>
    /**
     * In case the state was found with the provided `where` argument, update it with this data.
     */
    update: XOR<stateUpdateInput, stateUncheckedUpdateInput>
  }

  /**
   * state delete
   */
  export type stateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state
     */
    omit?: stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stateInclude<ExtArgs> | null
    /**
     * Filter which state to delete.
     */
    where: stateWhereUniqueInput
  }

  /**
   * state deleteMany
   */
  export type stateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which states to delete
     */
    where?: stateWhereInput
    /**
     * Limit how many states to delete.
     */
    limit?: number
  }

  /**
   * state.company
   */
  export type state$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Omit specific fields from the company
     */
    omit?: companyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyInclude<ExtArgs> | null
    where?: companyWhereInput
    orderBy?: companyOrderByWithRelationInput | companyOrderByWithRelationInput[]
    cursor?: companyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * state.job
   */
  export type state$jobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    where?: jobWhereInput
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    cursor?: jobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * state.city
   */
  export type state$cityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect<ExtArgs> | null
    /**
     * Omit specific fields from the city
     */
    omit?: cityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cityInclude<ExtArgs> | null
    where?: cityWhereInput
    orderBy?: cityOrderByWithRelationInput | cityOrderByWithRelationInput[]
    cursor?: cityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * state without action
   */
  export type stateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the state
     */
    select?: stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the state
     */
    omit?: stateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: stateInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CompanyScalarFieldEnum: {
    company_id: 'company_id',
    company_uuid: 'company_uuid',
    company_name: 'company_name',
    company_description: 'company_description',
    company_website: 'company_website',
    establishment_date: 'establishment_date',
    company_size: 'company_size',
    is_active: 'is_active',
    company_email: 'company_email',
    phone_number: 'phone_number',
    company_country_id: 'company_country_id',
    company_state_id: 'company_state_id',
    company_city_id: 'company_city_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const Company_imageScalarFieldEnum: {
    company_image_id: 'company_image_id',
    company_id: 'company_id',
    company_image: 'company_image',
    is_primary: 'is_primary',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Company_imageScalarFieldEnum = (typeof Company_imageScalarFieldEnum)[keyof typeof Company_imageScalarFieldEnum]


  export const Company_industryScalarFieldEnum: {
    company_industry_id: 'company_industry_id',
    company_industry_uuid: 'company_industry_uuid',
    company_id: 'company_id',
    industry_category_id: 'industry_category_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Company_industryScalarFieldEnum = (typeof Company_industryScalarFieldEnum)[keyof typeof Company_industryScalarFieldEnum]


  export const Industry_categoryScalarFieldEnum: {
    industry_category_id: 'industry_category_id',
    industry_name: 'industry_name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Industry_categoryScalarFieldEnum = (typeof Industry_categoryScalarFieldEnum)[keyof typeof Industry_categoryScalarFieldEnum]


  export const JobScalarFieldEnum: {
    job_id: 'job_id',
    job_uuid: 'job_uuid',
    job_company: 'job_company',
    job_description: 'job_description',
    job_name: 'job_name',
    job_posted_date: 'job_posted_date',
    apply_link: 'apply_link',
    salary_min: 'salary_min',
    salary_max: 'salary_max',
    salary_currency: 'salary_currency',
    salary_frequency: 'salary_frequency',
    job_status: 'job_status',
    is_remote: 'is_remote',
    job_country_id: 'job_country_id',
    job_state_id: 'job_state_id',
    job_city_id: 'job_city_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type JobScalarFieldEnum = (typeof JobScalarFieldEnum)[keyof typeof JobScalarFieldEnum]


  export const Job_categoryScalarFieldEnum: {
    job_category_id: 'job_category_id',
    job_category_name: 'job_category_name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Job_categoryScalarFieldEnum = (typeof Job_categoryScalarFieldEnum)[keyof typeof Job_categoryScalarFieldEnum]


  export const Job_category_mapScalarFieldEnum: {
    job_category_map_id: 'job_category_map_id',
    job_category_map_uuid: 'job_category_map_uuid',
    job_id: 'job_id',
    category_id: 'category_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Job_category_mapScalarFieldEnum = (typeof Job_category_mapScalarFieldEnum)[keyof typeof Job_category_mapScalarFieldEnum]


  export const Job_salaryScalarFieldEnum: {
    job_salary_id: 'job_salary_id',
    job_salary_name: 'job_salary_name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Job_salaryScalarFieldEnum = (typeof Job_salaryScalarFieldEnum)[keyof typeof Job_salaryScalarFieldEnum]


  export const Job_salary_mapScalarFieldEnum: {
    job_salary_map_id: 'job_salary_map_id',
    job_salary_map_uuid: 'job_salary_map_uuid',
    job_id: 'job_id',
    salary_id: 'salary_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Job_salary_mapScalarFieldEnum = (typeof Job_salary_mapScalarFieldEnum)[keyof typeof Job_salary_mapScalarFieldEnum]


  export const Job_scheduleScalarFieldEnum: {
    job_schedule_id: 'job_schedule_id',
    job_schedule_name: 'job_schedule_name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Job_scheduleScalarFieldEnum = (typeof Job_scheduleScalarFieldEnum)[keyof typeof Job_scheduleScalarFieldEnum]


  export const Job_schedule_mapScalarFieldEnum: {
    job_schedule_map_id: 'job_schedule_map_id',
    job_schedule_map_uuid: 'job_schedule_map_uuid',
    job_id: 'job_id',
    schedule_id: 'schedule_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Job_schedule_mapScalarFieldEnum = (typeof Job_schedule_mapScalarFieldEnum)[keyof typeof Job_schedule_mapScalarFieldEnum]


  export const Job_skillScalarFieldEnum: {
    job_skill_id: 'job_skill_id',
    job_skill_name: 'job_skill_name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Job_skillScalarFieldEnum = (typeof Job_skillScalarFieldEnum)[keyof typeof Job_skillScalarFieldEnum]


  export const Job_skill_mapScalarFieldEnum: {
    job_skill_map_id: 'job_skill_map_id',
    job_skill_map_uuid: 'job_skill_map_uuid',
    job_id: 'job_id',
    skill_id: 'skill_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Job_skill_mapScalarFieldEnum = (typeof Job_skill_mapScalarFieldEnum)[keyof typeof Job_skill_mapScalarFieldEnum]


  export const Job_sourceScalarFieldEnum: {
    job_source_id: 'job_source_id',
    job_source_name: 'job_source_name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Job_sourceScalarFieldEnum = (typeof Job_sourceScalarFieldEnum)[keyof typeof Job_sourceScalarFieldEnum]


  export const Job_source_mapScalarFieldEnum: {
    job_source_map_id: 'job_source_map_id',
    job_source_map_uuid: 'job_source_map_uuid',
    job_id: 'job_id',
    source_id: 'source_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Job_source_mapScalarFieldEnum = (typeof Job_source_mapScalarFieldEnum)[keyof typeof Job_source_mapScalarFieldEnum]


  export const Job_typeScalarFieldEnum: {
    job_type_id: 'job_type_id',
    job_type_name: 'job_type_name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Job_typeScalarFieldEnum = (typeof Job_typeScalarFieldEnum)[keyof typeof Job_typeScalarFieldEnum]


  export const Job_type_mapScalarFieldEnum: {
    job_type_map_id: 'job_type_map_id',
    job_type_map_uuid: 'job_type_map_uuid',
    job_id: 'job_id',
    type_id: 'type_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Job_type_mapScalarFieldEnum = (typeof Job_type_mapScalarFieldEnum)[keyof typeof Job_type_mapScalarFieldEnum]


  export const CityScalarFieldEnum: {
    city_id: 'city_id',
    city_name: 'city_name',
    state_id: 'state_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    country_id: 'country_id',
    country_name: 'country_name',
    country_code: 'country_code',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const StateScalarFieldEnum: {
    state_id: 'state_id',
    state_name: 'state_name',
    state_code: 'state_code',
    country_id: 'country_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type StateScalarFieldEnum = (typeof StateScalarFieldEnum)[keyof typeof StateScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'companySizes'
   */
  export type EnumcompanySizesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'companySizes'>
    


  /**
   * Reference to a field of type 'companySizes[]'
   */
  export type ListEnumcompanySizesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'companySizes[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'salaryFrequency'
   */
  export type EnumsalaryFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'salaryFrequency'>
    


  /**
   * Reference to a field of type 'salaryFrequency[]'
   */
  export type ListEnumsalaryFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'salaryFrequency[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type companyWhereInput = {
    AND?: companyWhereInput | companyWhereInput[]
    OR?: companyWhereInput[]
    NOT?: companyWhereInput | companyWhereInput[]
    company_id?: IntFilter<"company"> | number
    company_uuid?: UuidFilter<"company"> | string
    company_name?: StringFilter<"company"> | string
    company_description?: StringNullableFilter<"company"> | string | null
    company_website?: StringNullableFilter<"company"> | string | null
    establishment_date?: DateTimeNullableFilter<"company"> | Date | string | null
    company_size?: EnumcompanySizesNullableFilter<"company"> | $Enums.companySizes | null
    is_active?: BoolFilter<"company"> | boolean
    company_email?: StringNullableFilter<"company"> | string | null
    phone_number?: StringNullableFilter<"company"> | string | null
    company_country_id?: IntFilter<"company"> | number
    company_state_id?: IntFilter<"company"> | number
    company_city_id?: IntFilter<"company"> | number
    created_at?: DateTimeFilter<"company"> | Date | string
    updated_at?: DateTimeFilter<"company"> | Date | string
    deleted_at?: DateTimeNullableFilter<"company"> | Date | string | null
    city?: XOR<CityScalarRelationFilter, cityWhereInput>
    country?: XOR<CountryScalarRelationFilter, countryWhereInput>
    state?: XOR<StateScalarRelationFilter, stateWhereInput>
    company_image?: Company_imageListRelationFilter
    company_industry?: Company_industryListRelationFilter
    job?: JobListRelationFilter
  }

  export type companyOrderByWithRelationInput = {
    company_id?: SortOrder
    company_uuid?: SortOrder
    company_name?: SortOrder
    company_description?: SortOrderInput | SortOrder
    company_website?: SortOrderInput | SortOrder
    establishment_date?: SortOrderInput | SortOrder
    company_size?: SortOrderInput | SortOrder
    is_active?: SortOrder
    company_email?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    company_country_id?: SortOrder
    company_state_id?: SortOrder
    company_city_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    city?: cityOrderByWithRelationInput
    country?: countryOrderByWithRelationInput
    state?: stateOrderByWithRelationInput
    company_image?: company_imageOrderByRelationAggregateInput
    company_industry?: company_industryOrderByRelationAggregateInput
    job?: jobOrderByRelationAggregateInput
  }

  export type companyWhereUniqueInput = Prisma.AtLeast<{
    company_id?: number
    company_uuid?: string
    AND?: companyWhereInput | companyWhereInput[]
    OR?: companyWhereInput[]
    NOT?: companyWhereInput | companyWhereInput[]
    company_name?: StringFilter<"company"> | string
    company_description?: StringNullableFilter<"company"> | string | null
    company_website?: StringNullableFilter<"company"> | string | null
    establishment_date?: DateTimeNullableFilter<"company"> | Date | string | null
    company_size?: EnumcompanySizesNullableFilter<"company"> | $Enums.companySizes | null
    is_active?: BoolFilter<"company"> | boolean
    company_email?: StringNullableFilter<"company"> | string | null
    phone_number?: StringNullableFilter<"company"> | string | null
    company_country_id?: IntFilter<"company"> | number
    company_state_id?: IntFilter<"company"> | number
    company_city_id?: IntFilter<"company"> | number
    created_at?: DateTimeFilter<"company"> | Date | string
    updated_at?: DateTimeFilter<"company"> | Date | string
    deleted_at?: DateTimeNullableFilter<"company"> | Date | string | null
    city?: XOR<CityScalarRelationFilter, cityWhereInput>
    country?: XOR<CountryScalarRelationFilter, countryWhereInput>
    state?: XOR<StateScalarRelationFilter, stateWhereInput>
    company_image?: Company_imageListRelationFilter
    company_industry?: Company_industryListRelationFilter
    job?: JobListRelationFilter
  }, "company_id" | "company_uuid">

  export type companyOrderByWithAggregationInput = {
    company_id?: SortOrder
    company_uuid?: SortOrder
    company_name?: SortOrder
    company_description?: SortOrderInput | SortOrder
    company_website?: SortOrderInput | SortOrder
    establishment_date?: SortOrderInput | SortOrder
    company_size?: SortOrderInput | SortOrder
    is_active?: SortOrder
    company_email?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    company_country_id?: SortOrder
    company_state_id?: SortOrder
    company_city_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: companyCountOrderByAggregateInput
    _avg?: companyAvgOrderByAggregateInput
    _max?: companyMaxOrderByAggregateInput
    _min?: companyMinOrderByAggregateInput
    _sum?: companySumOrderByAggregateInput
  }

  export type companyScalarWhereWithAggregatesInput = {
    AND?: companyScalarWhereWithAggregatesInput | companyScalarWhereWithAggregatesInput[]
    OR?: companyScalarWhereWithAggregatesInput[]
    NOT?: companyScalarWhereWithAggregatesInput | companyScalarWhereWithAggregatesInput[]
    company_id?: IntWithAggregatesFilter<"company"> | number
    company_uuid?: UuidWithAggregatesFilter<"company"> | string
    company_name?: StringWithAggregatesFilter<"company"> | string
    company_description?: StringNullableWithAggregatesFilter<"company"> | string | null
    company_website?: StringNullableWithAggregatesFilter<"company"> | string | null
    establishment_date?: DateTimeNullableWithAggregatesFilter<"company"> | Date | string | null
    company_size?: EnumcompanySizesNullableWithAggregatesFilter<"company"> | $Enums.companySizes | null
    is_active?: BoolWithAggregatesFilter<"company"> | boolean
    company_email?: StringNullableWithAggregatesFilter<"company"> | string | null
    phone_number?: StringNullableWithAggregatesFilter<"company"> | string | null
    company_country_id?: IntWithAggregatesFilter<"company"> | number
    company_state_id?: IntWithAggregatesFilter<"company"> | number
    company_city_id?: IntWithAggregatesFilter<"company"> | number
    created_at?: DateTimeWithAggregatesFilter<"company"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"company"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"company"> | Date | string | null
  }

  export type company_imageWhereInput = {
    AND?: company_imageWhereInput | company_imageWhereInput[]
    OR?: company_imageWhereInput[]
    NOT?: company_imageWhereInput | company_imageWhereInput[]
    company_image_id?: IntFilter<"company_image"> | number
    company_id?: IntFilter<"company_image"> | number
    company_image?: StringNullableFilter<"company_image"> | string | null
    is_primary?: BoolFilter<"company_image"> | boolean
    created_at?: DateTimeFilter<"company_image"> | Date | string
    updated_at?: DateTimeFilter<"company_image"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, companyWhereInput>
  }

  export type company_imageOrderByWithRelationInput = {
    company_image_id?: SortOrder
    company_id?: SortOrder
    company_image?: SortOrderInput | SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    company?: companyOrderByWithRelationInput
  }

  export type company_imageWhereUniqueInput = Prisma.AtLeast<{
    company_image_id?: number
    AND?: company_imageWhereInput | company_imageWhereInput[]
    OR?: company_imageWhereInput[]
    NOT?: company_imageWhereInput | company_imageWhereInput[]
    company_id?: IntFilter<"company_image"> | number
    company_image?: StringNullableFilter<"company_image"> | string | null
    is_primary?: BoolFilter<"company_image"> | boolean
    created_at?: DateTimeFilter<"company_image"> | Date | string
    updated_at?: DateTimeFilter<"company_image"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, companyWhereInput>
  }, "company_image_id">

  export type company_imageOrderByWithAggregationInput = {
    company_image_id?: SortOrder
    company_id?: SortOrder
    company_image?: SortOrderInput | SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: company_imageCountOrderByAggregateInput
    _avg?: company_imageAvgOrderByAggregateInput
    _max?: company_imageMaxOrderByAggregateInput
    _min?: company_imageMinOrderByAggregateInput
    _sum?: company_imageSumOrderByAggregateInput
  }

  export type company_imageScalarWhereWithAggregatesInput = {
    AND?: company_imageScalarWhereWithAggregatesInput | company_imageScalarWhereWithAggregatesInput[]
    OR?: company_imageScalarWhereWithAggregatesInput[]
    NOT?: company_imageScalarWhereWithAggregatesInput | company_imageScalarWhereWithAggregatesInput[]
    company_image_id?: IntWithAggregatesFilter<"company_image"> | number
    company_id?: IntWithAggregatesFilter<"company_image"> | number
    company_image?: StringNullableWithAggregatesFilter<"company_image"> | string | null
    is_primary?: BoolWithAggregatesFilter<"company_image"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"company_image"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"company_image"> | Date | string
  }

  export type company_industryWhereInput = {
    AND?: company_industryWhereInput | company_industryWhereInput[]
    OR?: company_industryWhereInput[]
    NOT?: company_industryWhereInput | company_industryWhereInput[]
    company_industry_id?: IntFilter<"company_industry"> | number
    company_industry_uuid?: UuidFilter<"company_industry"> | string
    company_id?: IntFilter<"company_industry"> | number
    industry_category_id?: IntFilter<"company_industry"> | number
    created_at?: DateTimeFilter<"company_industry"> | Date | string
    updated_at?: DateTimeFilter<"company_industry"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, companyWhereInput>
    industry_category?: XOR<Industry_categoryScalarRelationFilter, industry_categoryWhereInput>
  }

  export type company_industryOrderByWithRelationInput = {
    company_industry_id?: SortOrder
    company_industry_uuid?: SortOrder
    company_id?: SortOrder
    industry_category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    company?: companyOrderByWithRelationInput
    industry_category?: industry_categoryOrderByWithRelationInput
  }

  export type company_industryWhereUniqueInput = Prisma.AtLeast<{
    company_industry_id?: number
    company_industry_uuid?: string
    company_id_industry_category_id?: company_industryCompany_idIndustry_category_idCompoundUniqueInput
    AND?: company_industryWhereInput | company_industryWhereInput[]
    OR?: company_industryWhereInput[]
    NOT?: company_industryWhereInput | company_industryWhereInput[]
    company_id?: IntFilter<"company_industry"> | number
    industry_category_id?: IntFilter<"company_industry"> | number
    created_at?: DateTimeFilter<"company_industry"> | Date | string
    updated_at?: DateTimeFilter<"company_industry"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, companyWhereInput>
    industry_category?: XOR<Industry_categoryScalarRelationFilter, industry_categoryWhereInput>
  }, "company_industry_id" | "company_industry_uuid" | "company_id_industry_category_id">

  export type company_industryOrderByWithAggregationInput = {
    company_industry_id?: SortOrder
    company_industry_uuid?: SortOrder
    company_id?: SortOrder
    industry_category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: company_industryCountOrderByAggregateInput
    _avg?: company_industryAvgOrderByAggregateInput
    _max?: company_industryMaxOrderByAggregateInput
    _min?: company_industryMinOrderByAggregateInput
    _sum?: company_industrySumOrderByAggregateInput
  }

  export type company_industryScalarWhereWithAggregatesInput = {
    AND?: company_industryScalarWhereWithAggregatesInput | company_industryScalarWhereWithAggregatesInput[]
    OR?: company_industryScalarWhereWithAggregatesInput[]
    NOT?: company_industryScalarWhereWithAggregatesInput | company_industryScalarWhereWithAggregatesInput[]
    company_industry_id?: IntWithAggregatesFilter<"company_industry"> | number
    company_industry_uuid?: UuidWithAggregatesFilter<"company_industry"> | string
    company_id?: IntWithAggregatesFilter<"company_industry"> | number
    industry_category_id?: IntWithAggregatesFilter<"company_industry"> | number
    created_at?: DateTimeWithAggregatesFilter<"company_industry"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"company_industry"> | Date | string
  }

  export type industry_categoryWhereInput = {
    AND?: industry_categoryWhereInput | industry_categoryWhereInput[]
    OR?: industry_categoryWhereInput[]
    NOT?: industry_categoryWhereInput | industry_categoryWhereInput[]
    industry_category_id?: IntFilter<"industry_category"> | number
    industry_name?: StringFilter<"industry_category"> | string
    created_at?: DateTimeFilter<"industry_category"> | Date | string
    updated_at?: DateTimeFilter<"industry_category"> | Date | string
    company_industry?: Company_industryListRelationFilter
  }

  export type industry_categoryOrderByWithRelationInput = {
    industry_category_id?: SortOrder
    industry_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    company_industry?: company_industryOrderByRelationAggregateInput
  }

  export type industry_categoryWhereUniqueInput = Prisma.AtLeast<{
    industry_category_id?: number
    AND?: industry_categoryWhereInput | industry_categoryWhereInput[]
    OR?: industry_categoryWhereInput[]
    NOT?: industry_categoryWhereInput | industry_categoryWhereInput[]
    industry_name?: StringFilter<"industry_category"> | string
    created_at?: DateTimeFilter<"industry_category"> | Date | string
    updated_at?: DateTimeFilter<"industry_category"> | Date | string
    company_industry?: Company_industryListRelationFilter
  }, "industry_category_id">

  export type industry_categoryOrderByWithAggregationInput = {
    industry_category_id?: SortOrder
    industry_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: industry_categoryCountOrderByAggregateInput
    _avg?: industry_categoryAvgOrderByAggregateInput
    _max?: industry_categoryMaxOrderByAggregateInput
    _min?: industry_categoryMinOrderByAggregateInput
    _sum?: industry_categorySumOrderByAggregateInput
  }

  export type industry_categoryScalarWhereWithAggregatesInput = {
    AND?: industry_categoryScalarWhereWithAggregatesInput | industry_categoryScalarWhereWithAggregatesInput[]
    OR?: industry_categoryScalarWhereWithAggregatesInput[]
    NOT?: industry_categoryScalarWhereWithAggregatesInput | industry_categoryScalarWhereWithAggregatesInput[]
    industry_category_id?: IntWithAggregatesFilter<"industry_category"> | number
    industry_name?: StringWithAggregatesFilter<"industry_category"> | string
    created_at?: DateTimeWithAggregatesFilter<"industry_category"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"industry_category"> | Date | string
  }

  export type jobWhereInput = {
    AND?: jobWhereInput | jobWhereInput[]
    OR?: jobWhereInput[]
    NOT?: jobWhereInput | jobWhereInput[]
    job_id?: IntFilter<"job"> | number
    job_uuid?: UuidFilter<"job"> | string
    job_company?: IntFilter<"job"> | number
    job_description?: StringNullableFilter<"job"> | string | null
    job_name?: StringFilter<"job"> | string
    job_posted_date?: DateTimeFilter<"job"> | Date | string
    apply_link?: StringFilter<"job"> | string
    salary_min?: DecimalNullableFilter<"job"> | Decimal | DecimalJsLike | number | string | null
    salary_max?: DecimalNullableFilter<"job"> | Decimal | DecimalJsLike | number | string | null
    salary_currency?: StringNullableFilter<"job"> | string | null
    salary_frequency?: EnumsalaryFrequencyNullableFilter<"job"> | $Enums.salaryFrequency | null
    job_status?: BoolFilter<"job"> | boolean
    is_remote?: BoolFilter<"job"> | boolean
    job_country_id?: IntFilter<"job"> | number
    job_state_id?: IntFilter<"job"> | number
    job_city_id?: IntFilter<"job"> | number
    created_at?: DateTimeFilter<"job"> | Date | string
    updated_at?: DateTimeFilter<"job"> | Date | string
    city?: XOR<CityScalarRelationFilter, cityWhereInput>
    company?: XOR<CompanyScalarRelationFilter, companyWhereInput>
    country?: XOR<CountryScalarRelationFilter, countryWhereInput>
    state?: XOR<StateScalarRelationFilter, stateWhereInput>
    job_category_map?: Job_category_mapListRelationFilter
    job_salary_map?: Job_salary_mapListRelationFilter
    job_schedule_map?: Job_schedule_mapListRelationFilter
    job_skill_map?: Job_skill_mapListRelationFilter
    job_source_map?: Job_source_mapListRelationFilter
    job_type_map?: Job_type_mapListRelationFilter
  }

  export type jobOrderByWithRelationInput = {
    job_id?: SortOrder
    job_uuid?: SortOrder
    job_company?: SortOrder
    job_description?: SortOrderInput | SortOrder
    job_name?: SortOrder
    job_posted_date?: SortOrder
    apply_link?: SortOrder
    salary_min?: SortOrderInput | SortOrder
    salary_max?: SortOrderInput | SortOrder
    salary_currency?: SortOrderInput | SortOrder
    salary_frequency?: SortOrderInput | SortOrder
    job_status?: SortOrder
    is_remote?: SortOrder
    job_country_id?: SortOrder
    job_state_id?: SortOrder
    job_city_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    city?: cityOrderByWithRelationInput
    company?: companyOrderByWithRelationInput
    country?: countryOrderByWithRelationInput
    state?: stateOrderByWithRelationInput
    job_category_map?: job_category_mapOrderByRelationAggregateInput
    job_salary_map?: job_salary_mapOrderByRelationAggregateInput
    job_schedule_map?: job_schedule_mapOrderByRelationAggregateInput
    job_skill_map?: job_skill_mapOrderByRelationAggregateInput
    job_source_map?: job_source_mapOrderByRelationAggregateInput
    job_type_map?: job_type_mapOrderByRelationAggregateInput
  }

  export type jobWhereUniqueInput = Prisma.AtLeast<{
    job_id?: number
    job_uuid?: string
    AND?: jobWhereInput | jobWhereInput[]
    OR?: jobWhereInput[]
    NOT?: jobWhereInput | jobWhereInput[]
    job_company?: IntFilter<"job"> | number
    job_description?: StringNullableFilter<"job"> | string | null
    job_name?: StringFilter<"job"> | string
    job_posted_date?: DateTimeFilter<"job"> | Date | string
    apply_link?: StringFilter<"job"> | string
    salary_min?: DecimalNullableFilter<"job"> | Decimal | DecimalJsLike | number | string | null
    salary_max?: DecimalNullableFilter<"job"> | Decimal | DecimalJsLike | number | string | null
    salary_currency?: StringNullableFilter<"job"> | string | null
    salary_frequency?: EnumsalaryFrequencyNullableFilter<"job"> | $Enums.salaryFrequency | null
    job_status?: BoolFilter<"job"> | boolean
    is_remote?: BoolFilter<"job"> | boolean
    job_country_id?: IntFilter<"job"> | number
    job_state_id?: IntFilter<"job"> | number
    job_city_id?: IntFilter<"job"> | number
    created_at?: DateTimeFilter<"job"> | Date | string
    updated_at?: DateTimeFilter<"job"> | Date | string
    city?: XOR<CityScalarRelationFilter, cityWhereInput>
    company?: XOR<CompanyScalarRelationFilter, companyWhereInput>
    country?: XOR<CountryScalarRelationFilter, countryWhereInput>
    state?: XOR<StateScalarRelationFilter, stateWhereInput>
    job_category_map?: Job_category_mapListRelationFilter
    job_salary_map?: Job_salary_mapListRelationFilter
    job_schedule_map?: Job_schedule_mapListRelationFilter
    job_skill_map?: Job_skill_mapListRelationFilter
    job_source_map?: Job_source_mapListRelationFilter
    job_type_map?: Job_type_mapListRelationFilter
  }, "job_id" | "job_uuid">

  export type jobOrderByWithAggregationInput = {
    job_id?: SortOrder
    job_uuid?: SortOrder
    job_company?: SortOrder
    job_description?: SortOrderInput | SortOrder
    job_name?: SortOrder
    job_posted_date?: SortOrder
    apply_link?: SortOrder
    salary_min?: SortOrderInput | SortOrder
    salary_max?: SortOrderInput | SortOrder
    salary_currency?: SortOrderInput | SortOrder
    salary_frequency?: SortOrderInput | SortOrder
    job_status?: SortOrder
    is_remote?: SortOrder
    job_country_id?: SortOrder
    job_state_id?: SortOrder
    job_city_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: jobCountOrderByAggregateInput
    _avg?: jobAvgOrderByAggregateInput
    _max?: jobMaxOrderByAggregateInput
    _min?: jobMinOrderByAggregateInput
    _sum?: jobSumOrderByAggregateInput
  }

  export type jobScalarWhereWithAggregatesInput = {
    AND?: jobScalarWhereWithAggregatesInput | jobScalarWhereWithAggregatesInput[]
    OR?: jobScalarWhereWithAggregatesInput[]
    NOT?: jobScalarWhereWithAggregatesInput | jobScalarWhereWithAggregatesInput[]
    job_id?: IntWithAggregatesFilter<"job"> | number
    job_uuid?: UuidWithAggregatesFilter<"job"> | string
    job_company?: IntWithAggregatesFilter<"job"> | number
    job_description?: StringNullableWithAggregatesFilter<"job"> | string | null
    job_name?: StringWithAggregatesFilter<"job"> | string
    job_posted_date?: DateTimeWithAggregatesFilter<"job"> | Date | string
    apply_link?: StringWithAggregatesFilter<"job"> | string
    salary_min?: DecimalNullableWithAggregatesFilter<"job"> | Decimal | DecimalJsLike | number | string | null
    salary_max?: DecimalNullableWithAggregatesFilter<"job"> | Decimal | DecimalJsLike | number | string | null
    salary_currency?: StringNullableWithAggregatesFilter<"job"> | string | null
    salary_frequency?: EnumsalaryFrequencyNullableWithAggregatesFilter<"job"> | $Enums.salaryFrequency | null
    job_status?: BoolWithAggregatesFilter<"job"> | boolean
    is_remote?: BoolWithAggregatesFilter<"job"> | boolean
    job_country_id?: IntWithAggregatesFilter<"job"> | number
    job_state_id?: IntWithAggregatesFilter<"job"> | number
    job_city_id?: IntWithAggregatesFilter<"job"> | number
    created_at?: DateTimeWithAggregatesFilter<"job"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"job"> | Date | string
  }

  export type job_categoryWhereInput = {
    AND?: job_categoryWhereInput | job_categoryWhereInput[]
    OR?: job_categoryWhereInput[]
    NOT?: job_categoryWhereInput | job_categoryWhereInput[]
    job_category_id?: IntFilter<"job_category"> | number
    job_category_name?: StringFilter<"job_category"> | string
    created_at?: DateTimeFilter<"job_category"> | Date | string
    updated_at?: DateTimeFilter<"job_category"> | Date | string
    job_category_map?: Job_category_mapListRelationFilter
  }

  export type job_categoryOrderByWithRelationInput = {
    job_category_id?: SortOrder
    job_category_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    job_category_map?: job_category_mapOrderByRelationAggregateInput
  }

  export type job_categoryWhereUniqueInput = Prisma.AtLeast<{
    job_category_id?: number
    AND?: job_categoryWhereInput | job_categoryWhereInput[]
    OR?: job_categoryWhereInput[]
    NOT?: job_categoryWhereInput | job_categoryWhereInput[]
    job_category_name?: StringFilter<"job_category"> | string
    created_at?: DateTimeFilter<"job_category"> | Date | string
    updated_at?: DateTimeFilter<"job_category"> | Date | string
    job_category_map?: Job_category_mapListRelationFilter
  }, "job_category_id">

  export type job_categoryOrderByWithAggregationInput = {
    job_category_id?: SortOrder
    job_category_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: job_categoryCountOrderByAggregateInput
    _avg?: job_categoryAvgOrderByAggregateInput
    _max?: job_categoryMaxOrderByAggregateInput
    _min?: job_categoryMinOrderByAggregateInput
    _sum?: job_categorySumOrderByAggregateInput
  }

  export type job_categoryScalarWhereWithAggregatesInput = {
    AND?: job_categoryScalarWhereWithAggregatesInput | job_categoryScalarWhereWithAggregatesInput[]
    OR?: job_categoryScalarWhereWithAggregatesInput[]
    NOT?: job_categoryScalarWhereWithAggregatesInput | job_categoryScalarWhereWithAggregatesInput[]
    job_category_id?: IntWithAggregatesFilter<"job_category"> | number
    job_category_name?: StringWithAggregatesFilter<"job_category"> | string
    created_at?: DateTimeWithAggregatesFilter<"job_category"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"job_category"> | Date | string
  }

  export type job_category_mapWhereInput = {
    AND?: job_category_mapWhereInput | job_category_mapWhereInput[]
    OR?: job_category_mapWhereInput[]
    NOT?: job_category_mapWhereInput | job_category_mapWhereInput[]
    job_category_map_id?: IntFilter<"job_category_map"> | number
    job_category_map_uuid?: UuidFilter<"job_category_map"> | string
    job_id?: IntFilter<"job_category_map"> | number
    category_id?: IntFilter<"job_category_map"> | number
    created_at?: DateTimeFilter<"job_category_map"> | Date | string
    updated_at?: DateTimeFilter<"job_category_map"> | Date | string
    job_category?: XOR<Job_categoryScalarRelationFilter, job_categoryWhereInput>
    job?: XOR<JobScalarRelationFilter, jobWhereInput>
  }

  export type job_category_mapOrderByWithRelationInput = {
    job_category_map_id?: SortOrder
    job_category_map_uuid?: SortOrder
    job_id?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    job_category?: job_categoryOrderByWithRelationInput
    job?: jobOrderByWithRelationInput
  }

  export type job_category_mapWhereUniqueInput = Prisma.AtLeast<{
    job_category_map_id?: number
    job_category_map_uuid?: string
    job_id_category_id?: job_category_mapJob_idCategory_idCompoundUniqueInput
    AND?: job_category_mapWhereInput | job_category_mapWhereInput[]
    OR?: job_category_mapWhereInput[]
    NOT?: job_category_mapWhereInput | job_category_mapWhereInput[]
    job_id?: IntFilter<"job_category_map"> | number
    category_id?: IntFilter<"job_category_map"> | number
    created_at?: DateTimeFilter<"job_category_map"> | Date | string
    updated_at?: DateTimeFilter<"job_category_map"> | Date | string
    job_category?: XOR<Job_categoryScalarRelationFilter, job_categoryWhereInput>
    job?: XOR<JobScalarRelationFilter, jobWhereInput>
  }, "job_category_map_id" | "job_category_map_uuid" | "job_id_category_id">

  export type job_category_mapOrderByWithAggregationInput = {
    job_category_map_id?: SortOrder
    job_category_map_uuid?: SortOrder
    job_id?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: job_category_mapCountOrderByAggregateInput
    _avg?: job_category_mapAvgOrderByAggregateInput
    _max?: job_category_mapMaxOrderByAggregateInput
    _min?: job_category_mapMinOrderByAggregateInput
    _sum?: job_category_mapSumOrderByAggregateInput
  }

  export type job_category_mapScalarWhereWithAggregatesInput = {
    AND?: job_category_mapScalarWhereWithAggregatesInput | job_category_mapScalarWhereWithAggregatesInput[]
    OR?: job_category_mapScalarWhereWithAggregatesInput[]
    NOT?: job_category_mapScalarWhereWithAggregatesInput | job_category_mapScalarWhereWithAggregatesInput[]
    job_category_map_id?: IntWithAggregatesFilter<"job_category_map"> | number
    job_category_map_uuid?: UuidWithAggregatesFilter<"job_category_map"> | string
    job_id?: IntWithAggregatesFilter<"job_category_map"> | number
    category_id?: IntWithAggregatesFilter<"job_category_map"> | number
    created_at?: DateTimeWithAggregatesFilter<"job_category_map"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"job_category_map"> | Date | string
  }

  export type job_salaryWhereInput = {
    AND?: job_salaryWhereInput | job_salaryWhereInput[]
    OR?: job_salaryWhereInput[]
    NOT?: job_salaryWhereInput | job_salaryWhereInput[]
    job_salary_id?: IntFilter<"job_salary"> | number
    job_salary_name?: StringFilter<"job_salary"> | string
    created_at?: DateTimeFilter<"job_salary"> | Date | string
    updated_at?: DateTimeFilter<"job_salary"> | Date | string
    job_salary_map?: Job_salary_mapListRelationFilter
  }

  export type job_salaryOrderByWithRelationInput = {
    job_salary_id?: SortOrder
    job_salary_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    job_salary_map?: job_salary_mapOrderByRelationAggregateInput
  }

  export type job_salaryWhereUniqueInput = Prisma.AtLeast<{
    job_salary_id?: number
    AND?: job_salaryWhereInput | job_salaryWhereInput[]
    OR?: job_salaryWhereInput[]
    NOT?: job_salaryWhereInput | job_salaryWhereInput[]
    job_salary_name?: StringFilter<"job_salary"> | string
    created_at?: DateTimeFilter<"job_salary"> | Date | string
    updated_at?: DateTimeFilter<"job_salary"> | Date | string
    job_salary_map?: Job_salary_mapListRelationFilter
  }, "job_salary_id">

  export type job_salaryOrderByWithAggregationInput = {
    job_salary_id?: SortOrder
    job_salary_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: job_salaryCountOrderByAggregateInput
    _avg?: job_salaryAvgOrderByAggregateInput
    _max?: job_salaryMaxOrderByAggregateInput
    _min?: job_salaryMinOrderByAggregateInput
    _sum?: job_salarySumOrderByAggregateInput
  }

  export type job_salaryScalarWhereWithAggregatesInput = {
    AND?: job_salaryScalarWhereWithAggregatesInput | job_salaryScalarWhereWithAggregatesInput[]
    OR?: job_salaryScalarWhereWithAggregatesInput[]
    NOT?: job_salaryScalarWhereWithAggregatesInput | job_salaryScalarWhereWithAggregatesInput[]
    job_salary_id?: IntWithAggregatesFilter<"job_salary"> | number
    job_salary_name?: StringWithAggregatesFilter<"job_salary"> | string
    created_at?: DateTimeWithAggregatesFilter<"job_salary"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"job_salary"> | Date | string
  }

  export type job_salary_mapWhereInput = {
    AND?: job_salary_mapWhereInput | job_salary_mapWhereInput[]
    OR?: job_salary_mapWhereInput[]
    NOT?: job_salary_mapWhereInput | job_salary_mapWhereInput[]
    job_salary_map_id?: IntFilter<"job_salary_map"> | number
    job_salary_map_uuid?: UuidFilter<"job_salary_map"> | string
    job_id?: IntFilter<"job_salary_map"> | number
    salary_id?: IntFilter<"job_salary_map"> | number
    created_at?: DateTimeFilter<"job_salary_map"> | Date | string
    updated_at?: DateTimeFilter<"job_salary_map"> | Date | string
    job?: XOR<JobScalarRelationFilter, jobWhereInput>
    job_salary?: XOR<Job_salaryScalarRelationFilter, job_salaryWhereInput>
  }

  export type job_salary_mapOrderByWithRelationInput = {
    job_salary_map_id?: SortOrder
    job_salary_map_uuid?: SortOrder
    job_id?: SortOrder
    salary_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    job?: jobOrderByWithRelationInput
    job_salary?: job_salaryOrderByWithRelationInput
  }

  export type job_salary_mapWhereUniqueInput = Prisma.AtLeast<{
    job_salary_map_id?: number
    job_salary_map_uuid?: string
    job_id_salary_id?: job_salary_mapJob_idSalary_idCompoundUniqueInput
    AND?: job_salary_mapWhereInput | job_salary_mapWhereInput[]
    OR?: job_salary_mapWhereInput[]
    NOT?: job_salary_mapWhereInput | job_salary_mapWhereInput[]
    job_id?: IntFilter<"job_salary_map"> | number
    salary_id?: IntFilter<"job_salary_map"> | number
    created_at?: DateTimeFilter<"job_salary_map"> | Date | string
    updated_at?: DateTimeFilter<"job_salary_map"> | Date | string
    job?: XOR<JobScalarRelationFilter, jobWhereInput>
    job_salary?: XOR<Job_salaryScalarRelationFilter, job_salaryWhereInput>
  }, "job_salary_map_id" | "job_salary_map_uuid" | "job_id_salary_id">

  export type job_salary_mapOrderByWithAggregationInput = {
    job_salary_map_id?: SortOrder
    job_salary_map_uuid?: SortOrder
    job_id?: SortOrder
    salary_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: job_salary_mapCountOrderByAggregateInput
    _avg?: job_salary_mapAvgOrderByAggregateInput
    _max?: job_salary_mapMaxOrderByAggregateInput
    _min?: job_salary_mapMinOrderByAggregateInput
    _sum?: job_salary_mapSumOrderByAggregateInput
  }

  export type job_salary_mapScalarWhereWithAggregatesInput = {
    AND?: job_salary_mapScalarWhereWithAggregatesInput | job_salary_mapScalarWhereWithAggregatesInput[]
    OR?: job_salary_mapScalarWhereWithAggregatesInput[]
    NOT?: job_salary_mapScalarWhereWithAggregatesInput | job_salary_mapScalarWhereWithAggregatesInput[]
    job_salary_map_id?: IntWithAggregatesFilter<"job_salary_map"> | number
    job_salary_map_uuid?: UuidWithAggregatesFilter<"job_salary_map"> | string
    job_id?: IntWithAggregatesFilter<"job_salary_map"> | number
    salary_id?: IntWithAggregatesFilter<"job_salary_map"> | number
    created_at?: DateTimeWithAggregatesFilter<"job_salary_map"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"job_salary_map"> | Date | string
  }

  export type job_scheduleWhereInput = {
    AND?: job_scheduleWhereInput | job_scheduleWhereInput[]
    OR?: job_scheduleWhereInput[]
    NOT?: job_scheduleWhereInput | job_scheduleWhereInput[]
    job_schedule_id?: IntFilter<"job_schedule"> | number
    job_schedule_name?: StringFilter<"job_schedule"> | string
    created_at?: DateTimeFilter<"job_schedule"> | Date | string
    updated_at?: DateTimeFilter<"job_schedule"> | Date | string
    job_schedule_map?: Job_schedule_mapListRelationFilter
  }

  export type job_scheduleOrderByWithRelationInput = {
    job_schedule_id?: SortOrder
    job_schedule_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    job_schedule_map?: job_schedule_mapOrderByRelationAggregateInput
  }

  export type job_scheduleWhereUniqueInput = Prisma.AtLeast<{
    job_schedule_id?: number
    AND?: job_scheduleWhereInput | job_scheduleWhereInput[]
    OR?: job_scheduleWhereInput[]
    NOT?: job_scheduleWhereInput | job_scheduleWhereInput[]
    job_schedule_name?: StringFilter<"job_schedule"> | string
    created_at?: DateTimeFilter<"job_schedule"> | Date | string
    updated_at?: DateTimeFilter<"job_schedule"> | Date | string
    job_schedule_map?: Job_schedule_mapListRelationFilter
  }, "job_schedule_id">

  export type job_scheduleOrderByWithAggregationInput = {
    job_schedule_id?: SortOrder
    job_schedule_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: job_scheduleCountOrderByAggregateInput
    _avg?: job_scheduleAvgOrderByAggregateInput
    _max?: job_scheduleMaxOrderByAggregateInput
    _min?: job_scheduleMinOrderByAggregateInput
    _sum?: job_scheduleSumOrderByAggregateInput
  }

  export type job_scheduleScalarWhereWithAggregatesInput = {
    AND?: job_scheduleScalarWhereWithAggregatesInput | job_scheduleScalarWhereWithAggregatesInput[]
    OR?: job_scheduleScalarWhereWithAggregatesInput[]
    NOT?: job_scheduleScalarWhereWithAggregatesInput | job_scheduleScalarWhereWithAggregatesInput[]
    job_schedule_id?: IntWithAggregatesFilter<"job_schedule"> | number
    job_schedule_name?: StringWithAggregatesFilter<"job_schedule"> | string
    created_at?: DateTimeWithAggregatesFilter<"job_schedule"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"job_schedule"> | Date | string
  }

  export type job_schedule_mapWhereInput = {
    AND?: job_schedule_mapWhereInput | job_schedule_mapWhereInput[]
    OR?: job_schedule_mapWhereInput[]
    NOT?: job_schedule_mapWhereInput | job_schedule_mapWhereInput[]
    job_schedule_map_id?: IntFilter<"job_schedule_map"> | number
    job_schedule_map_uuid?: UuidFilter<"job_schedule_map"> | string
    job_id?: IntFilter<"job_schedule_map"> | number
    schedule_id?: IntFilter<"job_schedule_map"> | number
    created_at?: DateTimeFilter<"job_schedule_map"> | Date | string
    updated_at?: DateTimeFilter<"job_schedule_map"> | Date | string
    job?: XOR<JobScalarRelationFilter, jobWhereInput>
    job_schedule?: XOR<Job_scheduleScalarRelationFilter, job_scheduleWhereInput>
  }

  export type job_schedule_mapOrderByWithRelationInput = {
    job_schedule_map_id?: SortOrder
    job_schedule_map_uuid?: SortOrder
    job_id?: SortOrder
    schedule_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    job?: jobOrderByWithRelationInput
    job_schedule?: job_scheduleOrderByWithRelationInput
  }

  export type job_schedule_mapWhereUniqueInput = Prisma.AtLeast<{
    job_schedule_map_id?: number
    job_schedule_map_uuid?: string
    job_id_schedule_id?: job_schedule_mapJob_idSchedule_idCompoundUniqueInput
    AND?: job_schedule_mapWhereInput | job_schedule_mapWhereInput[]
    OR?: job_schedule_mapWhereInput[]
    NOT?: job_schedule_mapWhereInput | job_schedule_mapWhereInput[]
    job_id?: IntFilter<"job_schedule_map"> | number
    schedule_id?: IntFilter<"job_schedule_map"> | number
    created_at?: DateTimeFilter<"job_schedule_map"> | Date | string
    updated_at?: DateTimeFilter<"job_schedule_map"> | Date | string
    job?: XOR<JobScalarRelationFilter, jobWhereInput>
    job_schedule?: XOR<Job_scheduleScalarRelationFilter, job_scheduleWhereInput>
  }, "job_schedule_map_id" | "job_schedule_map_uuid" | "job_id_schedule_id">

  export type job_schedule_mapOrderByWithAggregationInput = {
    job_schedule_map_id?: SortOrder
    job_schedule_map_uuid?: SortOrder
    job_id?: SortOrder
    schedule_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: job_schedule_mapCountOrderByAggregateInput
    _avg?: job_schedule_mapAvgOrderByAggregateInput
    _max?: job_schedule_mapMaxOrderByAggregateInput
    _min?: job_schedule_mapMinOrderByAggregateInput
    _sum?: job_schedule_mapSumOrderByAggregateInput
  }

  export type job_schedule_mapScalarWhereWithAggregatesInput = {
    AND?: job_schedule_mapScalarWhereWithAggregatesInput | job_schedule_mapScalarWhereWithAggregatesInput[]
    OR?: job_schedule_mapScalarWhereWithAggregatesInput[]
    NOT?: job_schedule_mapScalarWhereWithAggregatesInput | job_schedule_mapScalarWhereWithAggregatesInput[]
    job_schedule_map_id?: IntWithAggregatesFilter<"job_schedule_map"> | number
    job_schedule_map_uuid?: UuidWithAggregatesFilter<"job_schedule_map"> | string
    job_id?: IntWithAggregatesFilter<"job_schedule_map"> | number
    schedule_id?: IntWithAggregatesFilter<"job_schedule_map"> | number
    created_at?: DateTimeWithAggregatesFilter<"job_schedule_map"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"job_schedule_map"> | Date | string
  }

  export type job_skillWhereInput = {
    AND?: job_skillWhereInput | job_skillWhereInput[]
    OR?: job_skillWhereInput[]
    NOT?: job_skillWhereInput | job_skillWhereInput[]
    job_skill_id?: IntFilter<"job_skill"> | number
    job_skill_name?: StringFilter<"job_skill"> | string
    created_at?: DateTimeFilter<"job_skill"> | Date | string
    updated_at?: DateTimeFilter<"job_skill"> | Date | string
    job_skill_map?: Job_skill_mapListRelationFilter
  }

  export type job_skillOrderByWithRelationInput = {
    job_skill_id?: SortOrder
    job_skill_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    job_skill_map?: job_skill_mapOrderByRelationAggregateInput
  }

  export type job_skillWhereUniqueInput = Prisma.AtLeast<{
    job_skill_id?: number
    job_skill_name?: string
    AND?: job_skillWhereInput | job_skillWhereInput[]
    OR?: job_skillWhereInput[]
    NOT?: job_skillWhereInput | job_skillWhereInput[]
    created_at?: DateTimeFilter<"job_skill"> | Date | string
    updated_at?: DateTimeFilter<"job_skill"> | Date | string
    job_skill_map?: Job_skill_mapListRelationFilter
  }, "job_skill_id" | "job_skill_name">

  export type job_skillOrderByWithAggregationInput = {
    job_skill_id?: SortOrder
    job_skill_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: job_skillCountOrderByAggregateInput
    _avg?: job_skillAvgOrderByAggregateInput
    _max?: job_skillMaxOrderByAggregateInput
    _min?: job_skillMinOrderByAggregateInput
    _sum?: job_skillSumOrderByAggregateInput
  }

  export type job_skillScalarWhereWithAggregatesInput = {
    AND?: job_skillScalarWhereWithAggregatesInput | job_skillScalarWhereWithAggregatesInput[]
    OR?: job_skillScalarWhereWithAggregatesInput[]
    NOT?: job_skillScalarWhereWithAggregatesInput | job_skillScalarWhereWithAggregatesInput[]
    job_skill_id?: IntWithAggregatesFilter<"job_skill"> | number
    job_skill_name?: StringWithAggregatesFilter<"job_skill"> | string
    created_at?: DateTimeWithAggregatesFilter<"job_skill"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"job_skill"> | Date | string
  }

  export type job_skill_mapWhereInput = {
    AND?: job_skill_mapWhereInput | job_skill_mapWhereInput[]
    OR?: job_skill_mapWhereInput[]
    NOT?: job_skill_mapWhereInput | job_skill_mapWhereInput[]
    job_skill_map_id?: IntFilter<"job_skill_map"> | number
    job_skill_map_uuid?: UuidFilter<"job_skill_map"> | string
    job_id?: IntFilter<"job_skill_map"> | number
    skill_id?: IntFilter<"job_skill_map"> | number
    created_at?: DateTimeFilter<"job_skill_map"> | Date | string
    updated_at?: DateTimeFilter<"job_skill_map"> | Date | string
    job?: XOR<JobScalarRelationFilter, jobWhereInput>
    job_skill?: XOR<Job_skillScalarRelationFilter, job_skillWhereInput>
  }

  export type job_skill_mapOrderByWithRelationInput = {
    job_skill_map_id?: SortOrder
    job_skill_map_uuid?: SortOrder
    job_id?: SortOrder
    skill_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    job?: jobOrderByWithRelationInput
    job_skill?: job_skillOrderByWithRelationInput
  }

  export type job_skill_mapWhereUniqueInput = Prisma.AtLeast<{
    job_skill_map_id?: number
    job_skill_map_uuid?: string
    job_id_skill_id?: job_skill_mapJob_idSkill_idCompoundUniqueInput
    AND?: job_skill_mapWhereInput | job_skill_mapWhereInput[]
    OR?: job_skill_mapWhereInput[]
    NOT?: job_skill_mapWhereInput | job_skill_mapWhereInput[]
    job_id?: IntFilter<"job_skill_map"> | number
    skill_id?: IntFilter<"job_skill_map"> | number
    created_at?: DateTimeFilter<"job_skill_map"> | Date | string
    updated_at?: DateTimeFilter<"job_skill_map"> | Date | string
    job?: XOR<JobScalarRelationFilter, jobWhereInput>
    job_skill?: XOR<Job_skillScalarRelationFilter, job_skillWhereInput>
  }, "job_skill_map_id" | "job_skill_map_uuid" | "job_id_skill_id">

  export type job_skill_mapOrderByWithAggregationInput = {
    job_skill_map_id?: SortOrder
    job_skill_map_uuid?: SortOrder
    job_id?: SortOrder
    skill_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: job_skill_mapCountOrderByAggregateInput
    _avg?: job_skill_mapAvgOrderByAggregateInput
    _max?: job_skill_mapMaxOrderByAggregateInput
    _min?: job_skill_mapMinOrderByAggregateInput
    _sum?: job_skill_mapSumOrderByAggregateInput
  }

  export type job_skill_mapScalarWhereWithAggregatesInput = {
    AND?: job_skill_mapScalarWhereWithAggregatesInput | job_skill_mapScalarWhereWithAggregatesInput[]
    OR?: job_skill_mapScalarWhereWithAggregatesInput[]
    NOT?: job_skill_mapScalarWhereWithAggregatesInput | job_skill_mapScalarWhereWithAggregatesInput[]
    job_skill_map_id?: IntWithAggregatesFilter<"job_skill_map"> | number
    job_skill_map_uuid?: UuidWithAggregatesFilter<"job_skill_map"> | string
    job_id?: IntWithAggregatesFilter<"job_skill_map"> | number
    skill_id?: IntWithAggregatesFilter<"job_skill_map"> | number
    created_at?: DateTimeWithAggregatesFilter<"job_skill_map"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"job_skill_map"> | Date | string
  }

  export type job_sourceWhereInput = {
    AND?: job_sourceWhereInput | job_sourceWhereInput[]
    OR?: job_sourceWhereInput[]
    NOT?: job_sourceWhereInput | job_sourceWhereInput[]
    job_source_id?: IntFilter<"job_source"> | number
    job_source_name?: StringFilter<"job_source"> | string
    created_at?: DateTimeFilter<"job_source"> | Date | string
    updated_at?: DateTimeFilter<"job_source"> | Date | string
    job_source_map?: Job_source_mapListRelationFilter
  }

  export type job_sourceOrderByWithRelationInput = {
    job_source_id?: SortOrder
    job_source_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    job_source_map?: job_source_mapOrderByRelationAggregateInput
  }

  export type job_sourceWhereUniqueInput = Prisma.AtLeast<{
    job_source_id?: number
    AND?: job_sourceWhereInput | job_sourceWhereInput[]
    OR?: job_sourceWhereInput[]
    NOT?: job_sourceWhereInput | job_sourceWhereInput[]
    job_source_name?: StringFilter<"job_source"> | string
    created_at?: DateTimeFilter<"job_source"> | Date | string
    updated_at?: DateTimeFilter<"job_source"> | Date | string
    job_source_map?: Job_source_mapListRelationFilter
  }, "job_source_id">

  export type job_sourceOrderByWithAggregationInput = {
    job_source_id?: SortOrder
    job_source_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: job_sourceCountOrderByAggregateInput
    _avg?: job_sourceAvgOrderByAggregateInput
    _max?: job_sourceMaxOrderByAggregateInput
    _min?: job_sourceMinOrderByAggregateInput
    _sum?: job_sourceSumOrderByAggregateInput
  }

  export type job_sourceScalarWhereWithAggregatesInput = {
    AND?: job_sourceScalarWhereWithAggregatesInput | job_sourceScalarWhereWithAggregatesInput[]
    OR?: job_sourceScalarWhereWithAggregatesInput[]
    NOT?: job_sourceScalarWhereWithAggregatesInput | job_sourceScalarWhereWithAggregatesInput[]
    job_source_id?: IntWithAggregatesFilter<"job_source"> | number
    job_source_name?: StringWithAggregatesFilter<"job_source"> | string
    created_at?: DateTimeWithAggregatesFilter<"job_source"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"job_source"> | Date | string
  }

  export type job_source_mapWhereInput = {
    AND?: job_source_mapWhereInput | job_source_mapWhereInput[]
    OR?: job_source_mapWhereInput[]
    NOT?: job_source_mapWhereInput | job_source_mapWhereInput[]
    job_source_map_id?: IntFilter<"job_source_map"> | number
    job_source_map_uuid?: UuidFilter<"job_source_map"> | string
    job_id?: IntFilter<"job_source_map"> | number
    source_id?: IntFilter<"job_source_map"> | number
    created_at?: DateTimeFilter<"job_source_map"> | Date | string
    updated_at?: DateTimeFilter<"job_source_map"> | Date | string
    job?: XOR<JobScalarRelationFilter, jobWhereInput>
    job_source?: XOR<Job_sourceScalarRelationFilter, job_sourceWhereInput>
  }

  export type job_source_mapOrderByWithRelationInput = {
    job_source_map_id?: SortOrder
    job_source_map_uuid?: SortOrder
    job_id?: SortOrder
    source_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    job?: jobOrderByWithRelationInput
    job_source?: job_sourceOrderByWithRelationInput
  }

  export type job_source_mapWhereUniqueInput = Prisma.AtLeast<{
    job_source_map_id?: number
    job_source_map_uuid?: string
    job_id_source_id?: job_source_mapJob_idSource_idCompoundUniqueInput
    AND?: job_source_mapWhereInput | job_source_mapWhereInput[]
    OR?: job_source_mapWhereInput[]
    NOT?: job_source_mapWhereInput | job_source_mapWhereInput[]
    job_id?: IntFilter<"job_source_map"> | number
    source_id?: IntFilter<"job_source_map"> | number
    created_at?: DateTimeFilter<"job_source_map"> | Date | string
    updated_at?: DateTimeFilter<"job_source_map"> | Date | string
    job?: XOR<JobScalarRelationFilter, jobWhereInput>
    job_source?: XOR<Job_sourceScalarRelationFilter, job_sourceWhereInput>
  }, "job_source_map_id" | "job_source_map_uuid" | "job_id_source_id">

  export type job_source_mapOrderByWithAggregationInput = {
    job_source_map_id?: SortOrder
    job_source_map_uuid?: SortOrder
    job_id?: SortOrder
    source_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: job_source_mapCountOrderByAggregateInput
    _avg?: job_source_mapAvgOrderByAggregateInput
    _max?: job_source_mapMaxOrderByAggregateInput
    _min?: job_source_mapMinOrderByAggregateInput
    _sum?: job_source_mapSumOrderByAggregateInput
  }

  export type job_source_mapScalarWhereWithAggregatesInput = {
    AND?: job_source_mapScalarWhereWithAggregatesInput | job_source_mapScalarWhereWithAggregatesInput[]
    OR?: job_source_mapScalarWhereWithAggregatesInput[]
    NOT?: job_source_mapScalarWhereWithAggregatesInput | job_source_mapScalarWhereWithAggregatesInput[]
    job_source_map_id?: IntWithAggregatesFilter<"job_source_map"> | number
    job_source_map_uuid?: UuidWithAggregatesFilter<"job_source_map"> | string
    job_id?: IntWithAggregatesFilter<"job_source_map"> | number
    source_id?: IntWithAggregatesFilter<"job_source_map"> | number
    created_at?: DateTimeWithAggregatesFilter<"job_source_map"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"job_source_map"> | Date | string
  }

  export type job_typeWhereInput = {
    AND?: job_typeWhereInput | job_typeWhereInput[]
    OR?: job_typeWhereInput[]
    NOT?: job_typeWhereInput | job_typeWhereInput[]
    job_type_id?: IntFilter<"job_type"> | number
    job_type_name?: StringFilter<"job_type"> | string
    created_at?: DateTimeFilter<"job_type"> | Date | string
    updated_at?: DateTimeFilter<"job_type"> | Date | string
    job_type_map?: Job_type_mapListRelationFilter
  }

  export type job_typeOrderByWithRelationInput = {
    job_type_id?: SortOrder
    job_type_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    job_type_map?: job_type_mapOrderByRelationAggregateInput
  }

  export type job_typeWhereUniqueInput = Prisma.AtLeast<{
    job_type_id?: number
    AND?: job_typeWhereInput | job_typeWhereInput[]
    OR?: job_typeWhereInput[]
    NOT?: job_typeWhereInput | job_typeWhereInput[]
    job_type_name?: StringFilter<"job_type"> | string
    created_at?: DateTimeFilter<"job_type"> | Date | string
    updated_at?: DateTimeFilter<"job_type"> | Date | string
    job_type_map?: Job_type_mapListRelationFilter
  }, "job_type_id">

  export type job_typeOrderByWithAggregationInput = {
    job_type_id?: SortOrder
    job_type_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: job_typeCountOrderByAggregateInput
    _avg?: job_typeAvgOrderByAggregateInput
    _max?: job_typeMaxOrderByAggregateInput
    _min?: job_typeMinOrderByAggregateInput
    _sum?: job_typeSumOrderByAggregateInput
  }

  export type job_typeScalarWhereWithAggregatesInput = {
    AND?: job_typeScalarWhereWithAggregatesInput | job_typeScalarWhereWithAggregatesInput[]
    OR?: job_typeScalarWhereWithAggregatesInput[]
    NOT?: job_typeScalarWhereWithAggregatesInput | job_typeScalarWhereWithAggregatesInput[]
    job_type_id?: IntWithAggregatesFilter<"job_type"> | number
    job_type_name?: StringWithAggregatesFilter<"job_type"> | string
    created_at?: DateTimeWithAggregatesFilter<"job_type"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"job_type"> | Date | string
  }

  export type job_type_mapWhereInput = {
    AND?: job_type_mapWhereInput | job_type_mapWhereInput[]
    OR?: job_type_mapWhereInput[]
    NOT?: job_type_mapWhereInput | job_type_mapWhereInput[]
    job_type_map_id?: IntFilter<"job_type_map"> | number
    job_type_map_uuid?: UuidFilter<"job_type_map"> | string
    job_id?: IntFilter<"job_type_map"> | number
    type_id?: IntFilter<"job_type_map"> | number
    created_at?: DateTimeFilter<"job_type_map"> | Date | string
    updated_at?: DateTimeFilter<"job_type_map"> | Date | string
    job?: XOR<JobScalarRelationFilter, jobWhereInput>
    job_type?: XOR<Job_typeScalarRelationFilter, job_typeWhereInput>
  }

  export type job_type_mapOrderByWithRelationInput = {
    job_type_map_id?: SortOrder
    job_type_map_uuid?: SortOrder
    job_id?: SortOrder
    type_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    job?: jobOrderByWithRelationInput
    job_type?: job_typeOrderByWithRelationInput
  }

  export type job_type_mapWhereUniqueInput = Prisma.AtLeast<{
    job_type_map_id?: number
    job_type_map_uuid?: string
    job_id_type_id?: job_type_mapJob_idType_idCompoundUniqueInput
    AND?: job_type_mapWhereInput | job_type_mapWhereInput[]
    OR?: job_type_mapWhereInput[]
    NOT?: job_type_mapWhereInput | job_type_mapWhereInput[]
    job_id?: IntFilter<"job_type_map"> | number
    type_id?: IntFilter<"job_type_map"> | number
    created_at?: DateTimeFilter<"job_type_map"> | Date | string
    updated_at?: DateTimeFilter<"job_type_map"> | Date | string
    job?: XOR<JobScalarRelationFilter, jobWhereInput>
    job_type?: XOR<Job_typeScalarRelationFilter, job_typeWhereInput>
  }, "job_type_map_id" | "job_type_map_uuid" | "job_id_type_id">

  export type job_type_mapOrderByWithAggregationInput = {
    job_type_map_id?: SortOrder
    job_type_map_uuid?: SortOrder
    job_id?: SortOrder
    type_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: job_type_mapCountOrderByAggregateInput
    _avg?: job_type_mapAvgOrderByAggregateInput
    _max?: job_type_mapMaxOrderByAggregateInput
    _min?: job_type_mapMinOrderByAggregateInput
    _sum?: job_type_mapSumOrderByAggregateInput
  }

  export type job_type_mapScalarWhereWithAggregatesInput = {
    AND?: job_type_mapScalarWhereWithAggregatesInput | job_type_mapScalarWhereWithAggregatesInput[]
    OR?: job_type_mapScalarWhereWithAggregatesInput[]
    NOT?: job_type_mapScalarWhereWithAggregatesInput | job_type_mapScalarWhereWithAggregatesInput[]
    job_type_map_id?: IntWithAggregatesFilter<"job_type_map"> | number
    job_type_map_uuid?: UuidWithAggregatesFilter<"job_type_map"> | string
    job_id?: IntWithAggregatesFilter<"job_type_map"> | number
    type_id?: IntWithAggregatesFilter<"job_type_map"> | number
    created_at?: DateTimeWithAggregatesFilter<"job_type_map"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"job_type_map"> | Date | string
  }

  export type cityWhereInput = {
    AND?: cityWhereInput | cityWhereInput[]
    OR?: cityWhereInput[]
    NOT?: cityWhereInput | cityWhereInput[]
    city_id?: IntFilter<"city"> | number
    city_name?: StringFilter<"city"> | string
    state_id?: IntFilter<"city"> | number
    created_at?: DateTimeFilter<"city"> | Date | string
    updated_at?: DateTimeFilter<"city"> | Date | string
    company?: CompanyListRelationFilter
    job?: JobListRelationFilter
    state?: XOR<StateScalarRelationFilter, stateWhereInput>
  }

  export type cityOrderByWithRelationInput = {
    city_id?: SortOrder
    city_name?: SortOrder
    state_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    company?: companyOrderByRelationAggregateInput
    job?: jobOrderByRelationAggregateInput
    state?: stateOrderByWithRelationInput
  }

  export type cityWhereUniqueInput = Prisma.AtLeast<{
    city_id?: number
    city_name_state_id?: cityCity_nameState_idCompoundUniqueInput
    AND?: cityWhereInput | cityWhereInput[]
    OR?: cityWhereInput[]
    NOT?: cityWhereInput | cityWhereInput[]
    city_name?: StringFilter<"city"> | string
    state_id?: IntFilter<"city"> | number
    created_at?: DateTimeFilter<"city"> | Date | string
    updated_at?: DateTimeFilter<"city"> | Date | string
    company?: CompanyListRelationFilter
    job?: JobListRelationFilter
    state?: XOR<StateScalarRelationFilter, stateWhereInput>
  }, "city_id" | "city_name_state_id">

  export type cityOrderByWithAggregationInput = {
    city_id?: SortOrder
    city_name?: SortOrder
    state_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: cityCountOrderByAggregateInput
    _avg?: cityAvgOrderByAggregateInput
    _max?: cityMaxOrderByAggregateInput
    _min?: cityMinOrderByAggregateInput
    _sum?: citySumOrderByAggregateInput
  }

  export type cityScalarWhereWithAggregatesInput = {
    AND?: cityScalarWhereWithAggregatesInput | cityScalarWhereWithAggregatesInput[]
    OR?: cityScalarWhereWithAggregatesInput[]
    NOT?: cityScalarWhereWithAggregatesInput | cityScalarWhereWithAggregatesInput[]
    city_id?: IntWithAggregatesFilter<"city"> | number
    city_name?: StringWithAggregatesFilter<"city"> | string
    state_id?: IntWithAggregatesFilter<"city"> | number
    created_at?: DateTimeWithAggregatesFilter<"city"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"city"> | Date | string
  }

  export type countryWhereInput = {
    AND?: countryWhereInput | countryWhereInput[]
    OR?: countryWhereInput[]
    NOT?: countryWhereInput | countryWhereInput[]
    country_id?: IntFilter<"country"> | number
    country_name?: StringFilter<"country"> | string
    country_code?: StringFilter<"country"> | string
    created_at?: DateTimeFilter<"country"> | Date | string
    updated_at?: DateTimeFilter<"country"> | Date | string
    company?: CompanyListRelationFilter
    job?: JobListRelationFilter
    state?: StateListRelationFilter
  }

  export type countryOrderByWithRelationInput = {
    country_id?: SortOrder
    country_name?: SortOrder
    country_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    company?: companyOrderByRelationAggregateInput
    job?: jobOrderByRelationAggregateInput
    state?: stateOrderByRelationAggregateInput
  }

  export type countryWhereUniqueInput = Prisma.AtLeast<{
    country_id?: number
    country_code?: string
    AND?: countryWhereInput | countryWhereInput[]
    OR?: countryWhereInput[]
    NOT?: countryWhereInput | countryWhereInput[]
    country_name?: StringFilter<"country"> | string
    created_at?: DateTimeFilter<"country"> | Date | string
    updated_at?: DateTimeFilter<"country"> | Date | string
    company?: CompanyListRelationFilter
    job?: JobListRelationFilter
    state?: StateListRelationFilter
  }, "country_id" | "country_code">

  export type countryOrderByWithAggregationInput = {
    country_id?: SortOrder
    country_name?: SortOrder
    country_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: countryCountOrderByAggregateInput
    _avg?: countryAvgOrderByAggregateInput
    _max?: countryMaxOrderByAggregateInput
    _min?: countryMinOrderByAggregateInput
    _sum?: countrySumOrderByAggregateInput
  }

  export type countryScalarWhereWithAggregatesInput = {
    AND?: countryScalarWhereWithAggregatesInput | countryScalarWhereWithAggregatesInput[]
    OR?: countryScalarWhereWithAggregatesInput[]
    NOT?: countryScalarWhereWithAggregatesInput | countryScalarWhereWithAggregatesInput[]
    country_id?: IntWithAggregatesFilter<"country"> | number
    country_name?: StringWithAggregatesFilter<"country"> | string
    country_code?: StringWithAggregatesFilter<"country"> | string
    created_at?: DateTimeWithAggregatesFilter<"country"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"country"> | Date | string
  }

  export type stateWhereInput = {
    AND?: stateWhereInput | stateWhereInput[]
    OR?: stateWhereInput[]
    NOT?: stateWhereInput | stateWhereInput[]
    state_id?: IntFilter<"state"> | number
    state_name?: StringFilter<"state"> | string
    state_code?: StringNullableFilter<"state"> | string | null
    country_id?: IntFilter<"state"> | number
    created_at?: DateTimeFilter<"state"> | Date | string
    updated_at?: DateTimeFilter<"state"> | Date | string
    company?: CompanyListRelationFilter
    job?: JobListRelationFilter
    city?: CityListRelationFilter
    country?: XOR<CountryScalarRelationFilter, countryWhereInput>
  }

  export type stateOrderByWithRelationInput = {
    state_id?: SortOrder
    state_name?: SortOrder
    state_code?: SortOrderInput | SortOrder
    country_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    company?: companyOrderByRelationAggregateInput
    job?: jobOrderByRelationAggregateInput
    city?: cityOrderByRelationAggregateInput
    country?: countryOrderByWithRelationInput
  }

  export type stateWhereUniqueInput = Prisma.AtLeast<{
    state_id?: number
    state_code_country_id?: stateState_codeCountry_idCompoundUniqueInput
    AND?: stateWhereInput | stateWhereInput[]
    OR?: stateWhereInput[]
    NOT?: stateWhereInput | stateWhereInput[]
    state_name?: StringFilter<"state"> | string
    state_code?: StringNullableFilter<"state"> | string | null
    country_id?: IntFilter<"state"> | number
    created_at?: DateTimeFilter<"state"> | Date | string
    updated_at?: DateTimeFilter<"state"> | Date | string
    company?: CompanyListRelationFilter
    job?: JobListRelationFilter
    city?: CityListRelationFilter
    country?: XOR<CountryScalarRelationFilter, countryWhereInput>
  }, "state_id" | "state_code_country_id">

  export type stateOrderByWithAggregationInput = {
    state_id?: SortOrder
    state_name?: SortOrder
    state_code?: SortOrderInput | SortOrder
    country_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: stateCountOrderByAggregateInput
    _avg?: stateAvgOrderByAggregateInput
    _max?: stateMaxOrderByAggregateInput
    _min?: stateMinOrderByAggregateInput
    _sum?: stateSumOrderByAggregateInput
  }

  export type stateScalarWhereWithAggregatesInput = {
    AND?: stateScalarWhereWithAggregatesInput | stateScalarWhereWithAggregatesInput[]
    OR?: stateScalarWhereWithAggregatesInput[]
    NOT?: stateScalarWhereWithAggregatesInput | stateScalarWhereWithAggregatesInput[]
    state_id?: IntWithAggregatesFilter<"state"> | number
    state_name?: StringWithAggregatesFilter<"state"> | string
    state_code?: StringNullableWithAggregatesFilter<"state"> | string | null
    country_id?: IntWithAggregatesFilter<"state"> | number
    created_at?: DateTimeWithAggregatesFilter<"state"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"state"> | Date | string
  }

  export type companyCreateInput = {
    company_uuid?: string
    company_name?: string
    company_description?: string | null
    company_website?: string | null
    establishment_date?: Date | string | null
    company_size?: $Enums.companySizes | null
    is_active?: boolean
    company_email?: string | null
    phone_number?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    city?: cityCreateNestedOneWithoutCompanyInput
    country?: countryCreateNestedOneWithoutCompanyInput
    state?: stateCreateNestedOneWithoutCompanyInput
    company_image?: company_imageCreateNestedManyWithoutCompanyInput
    company_industry?: company_industryCreateNestedManyWithoutCompanyInput
    job?: jobCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateInput = {
    company_id?: number
    company_uuid?: string
    company_name?: string
    company_description?: string | null
    company_website?: string | null
    establishment_date?: Date | string | null
    company_size?: $Enums.companySizes | null
    is_active?: boolean
    company_email?: string | null
    phone_number?: string | null
    company_country_id?: number
    company_state_id?: number
    company_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    company_image?: company_imageUncheckedCreateNestedManyWithoutCompanyInput
    company_industry?: company_industryUncheckedCreateNestedManyWithoutCompanyInput
    job?: jobUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyUpdateInput = {
    company_uuid?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    establishment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_size?: NullableEnumcompanySizesFieldUpdateOperationsInput | $Enums.companySizes | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    company_email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: cityUpdateOneRequiredWithoutCompanyNestedInput
    country?: countryUpdateOneRequiredWithoutCompanyNestedInput
    state?: stateUpdateOneRequiredWithoutCompanyNestedInput
    company_image?: company_imageUpdateManyWithoutCompanyNestedInput
    company_industry?: company_industryUpdateManyWithoutCompanyNestedInput
    job?: jobUpdateManyWithoutCompanyNestedInput
  }

  export type companyUncheckedUpdateInput = {
    company_id?: IntFieldUpdateOperationsInput | number
    company_uuid?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    establishment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_size?: NullableEnumcompanySizesFieldUpdateOperationsInput | $Enums.companySizes | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    company_email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    company_country_id?: IntFieldUpdateOperationsInput | number
    company_state_id?: IntFieldUpdateOperationsInput | number
    company_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_image?: company_imageUncheckedUpdateManyWithoutCompanyNestedInput
    company_industry?: company_industryUncheckedUpdateManyWithoutCompanyNestedInput
    job?: jobUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type companyCreateManyInput = {
    company_id?: number
    company_uuid?: string
    company_name?: string
    company_description?: string | null
    company_website?: string | null
    establishment_date?: Date | string | null
    company_size?: $Enums.companySizes | null
    is_active?: boolean
    company_email?: string | null
    phone_number?: string | null
    company_country_id?: number
    company_state_id?: number
    company_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type companyUpdateManyMutationInput = {
    company_uuid?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    establishment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_size?: NullableEnumcompanySizesFieldUpdateOperationsInput | $Enums.companySizes | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    company_email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type companyUncheckedUpdateManyInput = {
    company_id?: IntFieldUpdateOperationsInput | number
    company_uuid?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    establishment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_size?: NullableEnumcompanySizesFieldUpdateOperationsInput | $Enums.companySizes | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    company_email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    company_country_id?: IntFieldUpdateOperationsInput | number
    company_state_id?: IntFieldUpdateOperationsInput | number
    company_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_imageCreateInput = {
    company_image?: string | null
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    company: companyCreateNestedOneWithoutCompany_imageInput
  }

  export type company_imageUncheckedCreateInput = {
    company_image_id?: number
    company_id: number
    company_image?: string | null
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_imageUpdateInput = {
    company_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUpdateOneRequiredWithoutCompany_imageNestedInput
  }

  export type company_imageUncheckedUpdateInput = {
    company_image_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    company_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_imageCreateManyInput = {
    company_image_id?: number
    company_id: number
    company_image?: string | null
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_imageUpdateManyMutationInput = {
    company_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_imageUncheckedUpdateManyInput = {
    company_image_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    company_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_industryCreateInput = {
    company_industry_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    company: companyCreateNestedOneWithoutCompany_industryInput
    industry_category: industry_categoryCreateNestedOneWithoutCompany_industryInput
  }

  export type company_industryUncheckedCreateInput = {
    company_industry_id?: number
    company_industry_uuid?: string
    company_id: number
    industry_category_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_industryUpdateInput = {
    company_industry_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUpdateOneRequiredWithoutCompany_industryNestedInput
    industry_category?: industry_categoryUpdateOneRequiredWithoutCompany_industryNestedInput
  }

  export type company_industryUncheckedUpdateInput = {
    company_industry_id?: IntFieldUpdateOperationsInput | number
    company_industry_uuid?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
    industry_category_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_industryCreateManyInput = {
    company_industry_id?: number
    company_industry_uuid?: string
    company_id: number
    industry_category_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_industryUpdateManyMutationInput = {
    company_industry_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_industryUncheckedUpdateManyInput = {
    company_industry_id?: IntFieldUpdateOperationsInput | number
    company_industry_uuid?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
    industry_category_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type industry_categoryCreateInput = {
    industry_name: string
    created_at?: Date | string
    updated_at?: Date | string
    company_industry?: company_industryCreateNestedManyWithoutIndustry_categoryInput
  }

  export type industry_categoryUncheckedCreateInput = {
    industry_category_id?: number
    industry_name: string
    created_at?: Date | string
    updated_at?: Date | string
    company_industry?: company_industryUncheckedCreateNestedManyWithoutIndustry_categoryInput
  }

  export type industry_categoryUpdateInput = {
    industry_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_industry?: company_industryUpdateManyWithoutIndustry_categoryNestedInput
  }

  export type industry_categoryUncheckedUpdateInput = {
    industry_category_id?: IntFieldUpdateOperationsInput | number
    industry_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_industry?: company_industryUncheckedUpdateManyWithoutIndustry_categoryNestedInput
  }

  export type industry_categoryCreateManyInput = {
    industry_category_id?: number
    industry_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type industry_categoryUpdateManyMutationInput = {
    industry_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type industry_categoryUncheckedUpdateManyInput = {
    industry_category_id?: IntFieldUpdateOperationsInput | number
    industry_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jobCreateInput = {
    job_uuid?: string
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    city?: cityCreateNestedOneWithoutJobInput
    company: companyCreateNestedOneWithoutJobInput
    country?: countryCreateNestedOneWithoutJobInput
    state?: stateCreateNestedOneWithoutJobInput
    job_category_map?: job_category_mapCreateNestedManyWithoutJobInput
    job_salary_map?: job_salary_mapCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapCreateNestedManyWithoutJobInput
  }

  export type jobUncheckedCreateInput = {
    job_id?: number
    job_uuid?: string
    job_company: number
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    job_country_id?: number
    job_state_id?: number
    job_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    job_category_map?: job_category_mapUncheckedCreateNestedManyWithoutJobInput
    job_salary_map?: job_salary_mapUncheckedCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapUncheckedCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapUncheckedCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapUncheckedCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapUncheckedCreateNestedManyWithoutJobInput
  }

  export type jobUpdateInput = {
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: cityUpdateOneRequiredWithoutJobNestedInput
    company?: companyUpdateOneRequiredWithoutJobNestedInput
    country?: countryUpdateOneRequiredWithoutJobNestedInput
    state?: stateUpdateOneRequiredWithoutJobNestedInput
    job_category_map?: job_category_mapUpdateManyWithoutJobNestedInput
    job_salary_map?: job_salary_mapUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUpdateManyWithoutJobNestedInput
  }

  export type jobUncheckedUpdateInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_company?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    job_country_id?: IntFieldUpdateOperationsInput | number
    job_state_id?: IntFieldUpdateOperationsInput | number
    job_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_category_map?: job_category_mapUncheckedUpdateManyWithoutJobNestedInput
    job_salary_map?: job_salary_mapUncheckedUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUncheckedUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUncheckedUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUncheckedUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUncheckedUpdateManyWithoutJobNestedInput
  }

  export type jobCreateManyInput = {
    job_id?: number
    job_uuid?: string
    job_company: number
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    job_country_id?: number
    job_state_id?: number
    job_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type jobUpdateManyMutationInput = {
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jobUncheckedUpdateManyInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_company?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    job_country_id?: IntFieldUpdateOperationsInput | number
    job_state_id?: IntFieldUpdateOperationsInput | number
    job_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_categoryCreateInput = {
    job_category_name: string
    created_at?: Date | string
    updated_at?: Date | string
    job_category_map?: job_category_mapCreateNestedManyWithoutJob_categoryInput
  }

  export type job_categoryUncheckedCreateInput = {
    job_category_id?: number
    job_category_name: string
    created_at?: Date | string
    updated_at?: Date | string
    job_category_map?: job_category_mapUncheckedCreateNestedManyWithoutJob_categoryInput
  }

  export type job_categoryUpdateInput = {
    job_category_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_category_map?: job_category_mapUpdateManyWithoutJob_categoryNestedInput
  }

  export type job_categoryUncheckedUpdateInput = {
    job_category_id?: IntFieldUpdateOperationsInput | number
    job_category_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_category_map?: job_category_mapUncheckedUpdateManyWithoutJob_categoryNestedInput
  }

  export type job_categoryCreateManyInput = {
    job_category_id?: number
    job_category_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_categoryUpdateManyMutationInput = {
    job_category_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_categoryUncheckedUpdateManyInput = {
    job_category_id?: IntFieldUpdateOperationsInput | number
    job_category_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_category_mapCreateInput = {
    job_category_map_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    job_category?: job_categoryCreateNestedOneWithoutJob_category_mapInput
    job: jobCreateNestedOneWithoutJob_category_mapInput
  }

  export type job_category_mapUncheckedCreateInput = {
    job_category_map_id?: number
    job_category_map_uuid?: string
    job_id: number
    category_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_category_mapUpdateInput = {
    job_category_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_category?: job_categoryUpdateOneRequiredWithoutJob_category_mapNestedInput
    job?: jobUpdateOneRequiredWithoutJob_category_mapNestedInput
  }

  export type job_category_mapUncheckedUpdateInput = {
    job_category_map_id?: IntFieldUpdateOperationsInput | number
    job_category_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_category_mapCreateManyInput = {
    job_category_map_id?: number
    job_category_map_uuid?: string
    job_id: number
    category_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_category_mapUpdateManyMutationInput = {
    job_category_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_category_mapUncheckedUpdateManyInput = {
    job_category_map_id?: IntFieldUpdateOperationsInput | number
    job_category_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_salaryCreateInput = {
    job_salary_name: string
    created_at?: Date | string
    updated_at?: Date | string
    job_salary_map?: job_salary_mapCreateNestedManyWithoutJob_salaryInput
  }

  export type job_salaryUncheckedCreateInput = {
    job_salary_id?: number
    job_salary_name: string
    created_at?: Date | string
    updated_at?: Date | string
    job_salary_map?: job_salary_mapUncheckedCreateNestedManyWithoutJob_salaryInput
  }

  export type job_salaryUpdateInput = {
    job_salary_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_salary_map?: job_salary_mapUpdateManyWithoutJob_salaryNestedInput
  }

  export type job_salaryUncheckedUpdateInput = {
    job_salary_id?: IntFieldUpdateOperationsInput | number
    job_salary_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_salary_map?: job_salary_mapUncheckedUpdateManyWithoutJob_salaryNestedInput
  }

  export type job_salaryCreateManyInput = {
    job_salary_id?: number
    job_salary_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_salaryUpdateManyMutationInput = {
    job_salary_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_salaryUncheckedUpdateManyInput = {
    job_salary_id?: IntFieldUpdateOperationsInput | number
    job_salary_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_salary_mapCreateInput = {
    job_salary_map_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    job: jobCreateNestedOneWithoutJob_salary_mapInput
    job_salary?: job_salaryCreateNestedOneWithoutJob_salary_mapInput
  }

  export type job_salary_mapUncheckedCreateInput = {
    job_salary_map_id?: number
    job_salary_map_uuid?: string
    job_id: number
    salary_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_salary_mapUpdateInput = {
    job_salary_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: jobUpdateOneRequiredWithoutJob_salary_mapNestedInput
    job_salary?: job_salaryUpdateOneRequiredWithoutJob_salary_mapNestedInput
  }

  export type job_salary_mapUncheckedUpdateInput = {
    job_salary_map_id?: IntFieldUpdateOperationsInput | number
    job_salary_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    salary_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_salary_mapCreateManyInput = {
    job_salary_map_id?: number
    job_salary_map_uuid?: string
    job_id: number
    salary_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_salary_mapUpdateManyMutationInput = {
    job_salary_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_salary_mapUncheckedUpdateManyInput = {
    job_salary_map_id?: IntFieldUpdateOperationsInput | number
    job_salary_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    salary_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_scheduleCreateInput = {
    job_schedule_name: string
    created_at?: Date | string
    updated_at?: Date | string
    job_schedule_map?: job_schedule_mapCreateNestedManyWithoutJob_scheduleInput
  }

  export type job_scheduleUncheckedCreateInput = {
    job_schedule_id?: number
    job_schedule_name: string
    created_at?: Date | string
    updated_at?: Date | string
    job_schedule_map?: job_schedule_mapUncheckedCreateNestedManyWithoutJob_scheduleInput
  }

  export type job_scheduleUpdateInput = {
    job_schedule_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_schedule_map?: job_schedule_mapUpdateManyWithoutJob_scheduleNestedInput
  }

  export type job_scheduleUncheckedUpdateInput = {
    job_schedule_id?: IntFieldUpdateOperationsInput | number
    job_schedule_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_schedule_map?: job_schedule_mapUncheckedUpdateManyWithoutJob_scheduleNestedInput
  }

  export type job_scheduleCreateManyInput = {
    job_schedule_id?: number
    job_schedule_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_scheduleUpdateManyMutationInput = {
    job_schedule_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_scheduleUncheckedUpdateManyInput = {
    job_schedule_id?: IntFieldUpdateOperationsInput | number
    job_schedule_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_schedule_mapCreateInput = {
    job_schedule_map_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    job: jobCreateNestedOneWithoutJob_schedule_mapInput
    job_schedule?: job_scheduleCreateNestedOneWithoutJob_schedule_mapInput
  }

  export type job_schedule_mapUncheckedCreateInput = {
    job_schedule_map_id?: number
    job_schedule_map_uuid?: string
    job_id: number
    schedule_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_schedule_mapUpdateInput = {
    job_schedule_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: jobUpdateOneRequiredWithoutJob_schedule_mapNestedInput
    job_schedule?: job_scheduleUpdateOneRequiredWithoutJob_schedule_mapNestedInput
  }

  export type job_schedule_mapUncheckedUpdateInput = {
    job_schedule_map_id?: IntFieldUpdateOperationsInput | number
    job_schedule_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    schedule_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_schedule_mapCreateManyInput = {
    job_schedule_map_id?: number
    job_schedule_map_uuid?: string
    job_id: number
    schedule_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_schedule_mapUpdateManyMutationInput = {
    job_schedule_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_schedule_mapUncheckedUpdateManyInput = {
    job_schedule_map_id?: IntFieldUpdateOperationsInput | number
    job_schedule_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    schedule_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_skillCreateInput = {
    job_skill_name: string
    created_at?: Date | string
    updated_at?: Date | string
    job_skill_map?: job_skill_mapCreateNestedManyWithoutJob_skillInput
  }

  export type job_skillUncheckedCreateInput = {
    job_skill_id?: number
    job_skill_name: string
    created_at?: Date | string
    updated_at?: Date | string
    job_skill_map?: job_skill_mapUncheckedCreateNestedManyWithoutJob_skillInput
  }

  export type job_skillUpdateInput = {
    job_skill_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_skill_map?: job_skill_mapUpdateManyWithoutJob_skillNestedInput
  }

  export type job_skillUncheckedUpdateInput = {
    job_skill_id?: IntFieldUpdateOperationsInput | number
    job_skill_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_skill_map?: job_skill_mapUncheckedUpdateManyWithoutJob_skillNestedInput
  }

  export type job_skillCreateManyInput = {
    job_skill_id?: number
    job_skill_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_skillUpdateManyMutationInput = {
    job_skill_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_skillUncheckedUpdateManyInput = {
    job_skill_id?: IntFieldUpdateOperationsInput | number
    job_skill_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_skill_mapCreateInput = {
    job_skill_map_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    job: jobCreateNestedOneWithoutJob_skill_mapInput
    job_skill?: job_skillCreateNestedOneWithoutJob_skill_mapInput
  }

  export type job_skill_mapUncheckedCreateInput = {
    job_skill_map_id?: number
    job_skill_map_uuid?: string
    job_id: number
    skill_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_skill_mapUpdateInput = {
    job_skill_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: jobUpdateOneRequiredWithoutJob_skill_mapNestedInput
    job_skill?: job_skillUpdateOneRequiredWithoutJob_skill_mapNestedInput
  }

  export type job_skill_mapUncheckedUpdateInput = {
    job_skill_map_id?: IntFieldUpdateOperationsInput | number
    job_skill_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    skill_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_skill_mapCreateManyInput = {
    job_skill_map_id?: number
    job_skill_map_uuid?: string
    job_id: number
    skill_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_skill_mapUpdateManyMutationInput = {
    job_skill_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_skill_mapUncheckedUpdateManyInput = {
    job_skill_map_id?: IntFieldUpdateOperationsInput | number
    job_skill_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    skill_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_sourceCreateInput = {
    job_source_name: string
    created_at?: Date | string
    updated_at?: Date | string
    job_source_map?: job_source_mapCreateNestedManyWithoutJob_sourceInput
  }

  export type job_sourceUncheckedCreateInput = {
    job_source_id?: number
    job_source_name: string
    created_at?: Date | string
    updated_at?: Date | string
    job_source_map?: job_source_mapUncheckedCreateNestedManyWithoutJob_sourceInput
  }

  export type job_sourceUpdateInput = {
    job_source_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_source_map?: job_source_mapUpdateManyWithoutJob_sourceNestedInput
  }

  export type job_sourceUncheckedUpdateInput = {
    job_source_id?: IntFieldUpdateOperationsInput | number
    job_source_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_source_map?: job_source_mapUncheckedUpdateManyWithoutJob_sourceNestedInput
  }

  export type job_sourceCreateManyInput = {
    job_source_id?: number
    job_source_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_sourceUpdateManyMutationInput = {
    job_source_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_sourceUncheckedUpdateManyInput = {
    job_source_id?: IntFieldUpdateOperationsInput | number
    job_source_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_source_mapCreateInput = {
    job_source_map_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    job: jobCreateNestedOneWithoutJob_source_mapInput
    job_source?: job_sourceCreateNestedOneWithoutJob_source_mapInput
  }

  export type job_source_mapUncheckedCreateInput = {
    job_source_map_id?: number
    job_source_map_uuid?: string
    job_id: number
    source_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_source_mapUpdateInput = {
    job_source_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: jobUpdateOneRequiredWithoutJob_source_mapNestedInput
    job_source?: job_sourceUpdateOneRequiredWithoutJob_source_mapNestedInput
  }

  export type job_source_mapUncheckedUpdateInput = {
    job_source_map_id?: IntFieldUpdateOperationsInput | number
    job_source_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    source_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_source_mapCreateManyInput = {
    job_source_map_id?: number
    job_source_map_uuid?: string
    job_id: number
    source_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_source_mapUpdateManyMutationInput = {
    job_source_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_source_mapUncheckedUpdateManyInput = {
    job_source_map_id?: IntFieldUpdateOperationsInput | number
    job_source_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    source_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_typeCreateInput = {
    job_type_name: string
    created_at?: Date | string
    updated_at?: Date | string
    job_type_map?: job_type_mapCreateNestedManyWithoutJob_typeInput
  }

  export type job_typeUncheckedCreateInput = {
    job_type_id?: number
    job_type_name: string
    created_at?: Date | string
    updated_at?: Date | string
    job_type_map?: job_type_mapUncheckedCreateNestedManyWithoutJob_typeInput
  }

  export type job_typeUpdateInput = {
    job_type_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_type_map?: job_type_mapUpdateManyWithoutJob_typeNestedInput
  }

  export type job_typeUncheckedUpdateInput = {
    job_type_id?: IntFieldUpdateOperationsInput | number
    job_type_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_type_map?: job_type_mapUncheckedUpdateManyWithoutJob_typeNestedInput
  }

  export type job_typeCreateManyInput = {
    job_type_id?: number
    job_type_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_typeUpdateManyMutationInput = {
    job_type_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_typeUncheckedUpdateManyInput = {
    job_type_id?: IntFieldUpdateOperationsInput | number
    job_type_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_type_mapCreateInput = {
    job_type_map_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    job: jobCreateNestedOneWithoutJob_type_mapInput
    job_type?: job_typeCreateNestedOneWithoutJob_type_mapInput
  }

  export type job_type_mapUncheckedCreateInput = {
    job_type_map_id?: number
    job_type_map_uuid?: string
    job_id: number
    type_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_type_mapUpdateInput = {
    job_type_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: jobUpdateOneRequiredWithoutJob_type_mapNestedInput
    job_type?: job_typeUpdateOneRequiredWithoutJob_type_mapNestedInput
  }

  export type job_type_mapUncheckedUpdateInput = {
    job_type_map_id?: IntFieldUpdateOperationsInput | number
    job_type_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_type_mapCreateManyInput = {
    job_type_map_id?: number
    job_type_map_uuid?: string
    job_id: number
    type_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_type_mapUpdateManyMutationInput = {
    job_type_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_type_mapUncheckedUpdateManyInput = {
    job_type_map_id?: IntFieldUpdateOperationsInput | number
    job_type_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cityCreateInput = {
    city_name: string
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyCreateNestedManyWithoutCityInput
    job?: jobCreateNestedManyWithoutCityInput
    state?: stateCreateNestedOneWithoutCityInput
  }

  export type cityUncheckedCreateInput = {
    city_id?: number
    city_name: string
    state_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyUncheckedCreateNestedManyWithoutCityInput
    job?: jobUncheckedCreateNestedManyWithoutCityInput
  }

  export type cityUpdateInput = {
    city_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUpdateManyWithoutCityNestedInput
    job?: jobUpdateManyWithoutCityNestedInput
    state?: stateUpdateOneRequiredWithoutCityNestedInput
  }

  export type cityUncheckedUpdateInput = {
    city_id?: IntFieldUpdateOperationsInput | number
    city_name?: StringFieldUpdateOperationsInput | string
    state_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUncheckedUpdateManyWithoutCityNestedInput
    job?: jobUncheckedUpdateManyWithoutCityNestedInput
  }

  export type cityCreateManyInput = {
    city_id?: number
    city_name: string
    state_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type cityUpdateManyMutationInput = {
    city_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cityUncheckedUpdateManyInput = {
    city_id?: IntFieldUpdateOperationsInput | number
    city_name?: StringFieldUpdateOperationsInput | string
    state_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type countryCreateInput = {
    country_name: string
    country_code?: string
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyCreateNestedManyWithoutCountryInput
    job?: jobCreateNestedManyWithoutCountryInput
    state?: stateCreateNestedManyWithoutCountryInput
  }

  export type countryUncheckedCreateInput = {
    country_id?: number
    country_name: string
    country_code?: string
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyUncheckedCreateNestedManyWithoutCountryInput
    job?: jobUncheckedCreateNestedManyWithoutCountryInput
    state?: stateUncheckedCreateNestedManyWithoutCountryInput
  }

  export type countryUpdateInput = {
    country_name?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUpdateManyWithoutCountryNestedInput
    job?: jobUpdateManyWithoutCountryNestedInput
    state?: stateUpdateManyWithoutCountryNestedInput
  }

  export type countryUncheckedUpdateInput = {
    country_id?: IntFieldUpdateOperationsInput | number
    country_name?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUncheckedUpdateManyWithoutCountryNestedInput
    job?: jobUncheckedUpdateManyWithoutCountryNestedInput
    state?: stateUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type countryCreateManyInput = {
    country_id?: number
    country_name: string
    country_code?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type countryUpdateManyMutationInput = {
    country_name?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type countryUncheckedUpdateManyInput = {
    country_id?: IntFieldUpdateOperationsInput | number
    country_name?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type stateCreateInput = {
    state_name: string
    state_code?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyCreateNestedManyWithoutStateInput
    job?: jobCreateNestedManyWithoutStateInput
    city?: cityCreateNestedManyWithoutStateInput
    country?: countryCreateNestedOneWithoutStateInput
  }

  export type stateUncheckedCreateInput = {
    state_id?: number
    state_name: string
    state_code?: string | null
    country_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyUncheckedCreateNestedManyWithoutStateInput
    job?: jobUncheckedCreateNestedManyWithoutStateInput
    city?: cityUncheckedCreateNestedManyWithoutStateInput
  }

  export type stateUpdateInput = {
    state_name?: StringFieldUpdateOperationsInput | string
    state_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUpdateManyWithoutStateNestedInput
    job?: jobUpdateManyWithoutStateNestedInput
    city?: cityUpdateManyWithoutStateNestedInput
    country?: countryUpdateOneRequiredWithoutStateNestedInput
  }

  export type stateUncheckedUpdateInput = {
    state_id?: IntFieldUpdateOperationsInput | number
    state_name?: StringFieldUpdateOperationsInput | string
    state_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUncheckedUpdateManyWithoutStateNestedInput
    job?: jobUncheckedUpdateManyWithoutStateNestedInput
    city?: cityUncheckedUpdateManyWithoutStateNestedInput
  }

  export type stateCreateManyInput = {
    state_id?: number
    state_name: string
    state_code?: string | null
    country_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type stateUpdateManyMutationInput = {
    state_name?: StringFieldUpdateOperationsInput | string
    state_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type stateUncheckedUpdateManyInput = {
    state_id?: IntFieldUpdateOperationsInput | number
    state_name?: StringFieldUpdateOperationsInput | string
    state_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumcompanySizesNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.companySizes | EnumcompanySizesFieldRefInput<$PrismaModel> | null
    in?: $Enums.companySizes[] | ListEnumcompanySizesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.companySizes[] | ListEnumcompanySizesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumcompanySizesNullableFilter<$PrismaModel> | $Enums.companySizes | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CityScalarRelationFilter = {
    is?: cityWhereInput
    isNot?: cityWhereInput
  }

  export type CountryScalarRelationFilter = {
    is?: countryWhereInput
    isNot?: countryWhereInput
  }

  export type StateScalarRelationFilter = {
    is?: stateWhereInput
    isNot?: stateWhereInput
  }

  export type Company_imageListRelationFilter = {
    every?: company_imageWhereInput
    some?: company_imageWhereInput
    none?: company_imageWhereInput
  }

  export type Company_industryListRelationFilter = {
    every?: company_industryWhereInput
    some?: company_industryWhereInput
    none?: company_industryWhereInput
  }

  export type JobListRelationFilter = {
    every?: jobWhereInput
    some?: jobWhereInput
    none?: jobWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type company_imageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type company_industryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type jobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companyCountOrderByAggregateInput = {
    company_id?: SortOrder
    company_uuid?: SortOrder
    company_name?: SortOrder
    company_description?: SortOrder
    company_website?: SortOrder
    establishment_date?: SortOrder
    company_size?: SortOrder
    is_active?: SortOrder
    company_email?: SortOrder
    phone_number?: SortOrder
    company_country_id?: SortOrder
    company_state_id?: SortOrder
    company_city_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type companyAvgOrderByAggregateInput = {
    company_id?: SortOrder
    company_country_id?: SortOrder
    company_state_id?: SortOrder
    company_city_id?: SortOrder
  }

  export type companyMaxOrderByAggregateInput = {
    company_id?: SortOrder
    company_uuid?: SortOrder
    company_name?: SortOrder
    company_description?: SortOrder
    company_website?: SortOrder
    establishment_date?: SortOrder
    company_size?: SortOrder
    is_active?: SortOrder
    company_email?: SortOrder
    phone_number?: SortOrder
    company_country_id?: SortOrder
    company_state_id?: SortOrder
    company_city_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type companyMinOrderByAggregateInput = {
    company_id?: SortOrder
    company_uuid?: SortOrder
    company_name?: SortOrder
    company_description?: SortOrder
    company_website?: SortOrder
    establishment_date?: SortOrder
    company_size?: SortOrder
    is_active?: SortOrder
    company_email?: SortOrder
    phone_number?: SortOrder
    company_country_id?: SortOrder
    company_state_id?: SortOrder
    company_city_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type companySumOrderByAggregateInput = {
    company_id?: SortOrder
    company_country_id?: SortOrder
    company_state_id?: SortOrder
    company_city_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumcompanySizesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.companySizes | EnumcompanySizesFieldRefInput<$PrismaModel> | null
    in?: $Enums.companySizes[] | ListEnumcompanySizesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.companySizes[] | ListEnumcompanySizesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumcompanySizesNullableWithAggregatesFilter<$PrismaModel> | $Enums.companySizes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumcompanySizesNullableFilter<$PrismaModel>
    _max?: NestedEnumcompanySizesNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CompanyScalarRelationFilter = {
    is?: companyWhereInput
    isNot?: companyWhereInput
  }

  export type company_imageCountOrderByAggregateInput = {
    company_image_id?: SortOrder
    company_id?: SortOrder
    company_image?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_imageAvgOrderByAggregateInput = {
    company_image_id?: SortOrder
    company_id?: SortOrder
  }

  export type company_imageMaxOrderByAggregateInput = {
    company_image_id?: SortOrder
    company_id?: SortOrder
    company_image?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_imageMinOrderByAggregateInput = {
    company_image_id?: SortOrder
    company_id?: SortOrder
    company_image?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_imageSumOrderByAggregateInput = {
    company_image_id?: SortOrder
    company_id?: SortOrder
  }

  export type Industry_categoryScalarRelationFilter = {
    is?: industry_categoryWhereInput
    isNot?: industry_categoryWhereInput
  }

  export type company_industryCompany_idIndustry_category_idCompoundUniqueInput = {
    company_id: number
    industry_category_id: number
  }

  export type company_industryCountOrderByAggregateInput = {
    company_industry_id?: SortOrder
    company_industry_uuid?: SortOrder
    company_id?: SortOrder
    industry_category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_industryAvgOrderByAggregateInput = {
    company_industry_id?: SortOrder
    company_id?: SortOrder
    industry_category_id?: SortOrder
  }

  export type company_industryMaxOrderByAggregateInput = {
    company_industry_id?: SortOrder
    company_industry_uuid?: SortOrder
    company_id?: SortOrder
    industry_category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_industryMinOrderByAggregateInput = {
    company_industry_id?: SortOrder
    company_industry_uuid?: SortOrder
    company_id?: SortOrder
    industry_category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_industrySumOrderByAggregateInput = {
    company_industry_id?: SortOrder
    company_id?: SortOrder
    industry_category_id?: SortOrder
  }

  export type industry_categoryCountOrderByAggregateInput = {
    industry_category_id?: SortOrder
    industry_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type industry_categoryAvgOrderByAggregateInput = {
    industry_category_id?: SortOrder
  }

  export type industry_categoryMaxOrderByAggregateInput = {
    industry_category_id?: SortOrder
    industry_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type industry_categoryMinOrderByAggregateInput = {
    industry_category_id?: SortOrder
    industry_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type industry_categorySumOrderByAggregateInput = {
    industry_category_id?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumsalaryFrequencyNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.salaryFrequency | EnumsalaryFrequencyFieldRefInput<$PrismaModel> | null
    in?: $Enums.salaryFrequency[] | ListEnumsalaryFrequencyFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.salaryFrequency[] | ListEnumsalaryFrequencyFieldRefInput<$PrismaModel> | null
    not?: NestedEnumsalaryFrequencyNullableFilter<$PrismaModel> | $Enums.salaryFrequency | null
  }

  export type Job_category_mapListRelationFilter = {
    every?: job_category_mapWhereInput
    some?: job_category_mapWhereInput
    none?: job_category_mapWhereInput
  }

  export type Job_salary_mapListRelationFilter = {
    every?: job_salary_mapWhereInput
    some?: job_salary_mapWhereInput
    none?: job_salary_mapWhereInput
  }

  export type Job_schedule_mapListRelationFilter = {
    every?: job_schedule_mapWhereInput
    some?: job_schedule_mapWhereInput
    none?: job_schedule_mapWhereInput
  }

  export type Job_skill_mapListRelationFilter = {
    every?: job_skill_mapWhereInput
    some?: job_skill_mapWhereInput
    none?: job_skill_mapWhereInput
  }

  export type Job_source_mapListRelationFilter = {
    every?: job_source_mapWhereInput
    some?: job_source_mapWhereInput
    none?: job_source_mapWhereInput
  }

  export type Job_type_mapListRelationFilter = {
    every?: job_type_mapWhereInput
    some?: job_type_mapWhereInput
    none?: job_type_mapWhereInput
  }

  export type job_category_mapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type job_salary_mapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type job_schedule_mapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type job_skill_mapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type job_source_mapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type job_type_mapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type jobCountOrderByAggregateInput = {
    job_id?: SortOrder
    job_uuid?: SortOrder
    job_company?: SortOrder
    job_description?: SortOrder
    job_name?: SortOrder
    job_posted_date?: SortOrder
    apply_link?: SortOrder
    salary_min?: SortOrder
    salary_max?: SortOrder
    salary_currency?: SortOrder
    salary_frequency?: SortOrder
    job_status?: SortOrder
    is_remote?: SortOrder
    job_country_id?: SortOrder
    job_state_id?: SortOrder
    job_city_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type jobAvgOrderByAggregateInput = {
    job_id?: SortOrder
    job_company?: SortOrder
    salary_min?: SortOrder
    salary_max?: SortOrder
    job_country_id?: SortOrder
    job_state_id?: SortOrder
    job_city_id?: SortOrder
  }

  export type jobMaxOrderByAggregateInput = {
    job_id?: SortOrder
    job_uuid?: SortOrder
    job_company?: SortOrder
    job_description?: SortOrder
    job_name?: SortOrder
    job_posted_date?: SortOrder
    apply_link?: SortOrder
    salary_min?: SortOrder
    salary_max?: SortOrder
    salary_currency?: SortOrder
    salary_frequency?: SortOrder
    job_status?: SortOrder
    is_remote?: SortOrder
    job_country_id?: SortOrder
    job_state_id?: SortOrder
    job_city_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type jobMinOrderByAggregateInput = {
    job_id?: SortOrder
    job_uuid?: SortOrder
    job_company?: SortOrder
    job_description?: SortOrder
    job_name?: SortOrder
    job_posted_date?: SortOrder
    apply_link?: SortOrder
    salary_min?: SortOrder
    salary_max?: SortOrder
    salary_currency?: SortOrder
    salary_frequency?: SortOrder
    job_status?: SortOrder
    is_remote?: SortOrder
    job_country_id?: SortOrder
    job_state_id?: SortOrder
    job_city_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type jobSumOrderByAggregateInput = {
    job_id?: SortOrder
    job_company?: SortOrder
    salary_min?: SortOrder
    salary_max?: SortOrder
    job_country_id?: SortOrder
    job_state_id?: SortOrder
    job_city_id?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumsalaryFrequencyNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.salaryFrequency | EnumsalaryFrequencyFieldRefInput<$PrismaModel> | null
    in?: $Enums.salaryFrequency[] | ListEnumsalaryFrequencyFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.salaryFrequency[] | ListEnumsalaryFrequencyFieldRefInput<$PrismaModel> | null
    not?: NestedEnumsalaryFrequencyNullableWithAggregatesFilter<$PrismaModel> | $Enums.salaryFrequency | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumsalaryFrequencyNullableFilter<$PrismaModel>
    _max?: NestedEnumsalaryFrequencyNullableFilter<$PrismaModel>
  }

  export type job_categoryCountOrderByAggregateInput = {
    job_category_id?: SortOrder
    job_category_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_categoryAvgOrderByAggregateInput = {
    job_category_id?: SortOrder
  }

  export type job_categoryMaxOrderByAggregateInput = {
    job_category_id?: SortOrder
    job_category_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_categoryMinOrderByAggregateInput = {
    job_category_id?: SortOrder
    job_category_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_categorySumOrderByAggregateInput = {
    job_category_id?: SortOrder
  }

  export type Job_categoryScalarRelationFilter = {
    is?: job_categoryWhereInput
    isNot?: job_categoryWhereInput
  }

  export type JobScalarRelationFilter = {
    is?: jobWhereInput
    isNot?: jobWhereInput
  }

  export type job_category_mapJob_idCategory_idCompoundUniqueInput = {
    job_id: number
    category_id: number
  }

  export type job_category_mapCountOrderByAggregateInput = {
    job_category_map_id?: SortOrder
    job_category_map_uuid?: SortOrder
    job_id?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_category_mapAvgOrderByAggregateInput = {
    job_category_map_id?: SortOrder
    job_id?: SortOrder
    category_id?: SortOrder
  }

  export type job_category_mapMaxOrderByAggregateInput = {
    job_category_map_id?: SortOrder
    job_category_map_uuid?: SortOrder
    job_id?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_category_mapMinOrderByAggregateInput = {
    job_category_map_id?: SortOrder
    job_category_map_uuid?: SortOrder
    job_id?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_category_mapSumOrderByAggregateInput = {
    job_category_map_id?: SortOrder
    job_id?: SortOrder
    category_id?: SortOrder
  }

  export type job_salaryCountOrderByAggregateInput = {
    job_salary_id?: SortOrder
    job_salary_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_salaryAvgOrderByAggregateInput = {
    job_salary_id?: SortOrder
  }

  export type job_salaryMaxOrderByAggregateInput = {
    job_salary_id?: SortOrder
    job_salary_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_salaryMinOrderByAggregateInput = {
    job_salary_id?: SortOrder
    job_salary_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_salarySumOrderByAggregateInput = {
    job_salary_id?: SortOrder
  }

  export type Job_salaryScalarRelationFilter = {
    is?: job_salaryWhereInput
    isNot?: job_salaryWhereInput
  }

  export type job_salary_mapJob_idSalary_idCompoundUniqueInput = {
    job_id: number
    salary_id: number
  }

  export type job_salary_mapCountOrderByAggregateInput = {
    job_salary_map_id?: SortOrder
    job_salary_map_uuid?: SortOrder
    job_id?: SortOrder
    salary_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_salary_mapAvgOrderByAggregateInput = {
    job_salary_map_id?: SortOrder
    job_id?: SortOrder
    salary_id?: SortOrder
  }

  export type job_salary_mapMaxOrderByAggregateInput = {
    job_salary_map_id?: SortOrder
    job_salary_map_uuid?: SortOrder
    job_id?: SortOrder
    salary_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_salary_mapMinOrderByAggregateInput = {
    job_salary_map_id?: SortOrder
    job_salary_map_uuid?: SortOrder
    job_id?: SortOrder
    salary_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_salary_mapSumOrderByAggregateInput = {
    job_salary_map_id?: SortOrder
    job_id?: SortOrder
    salary_id?: SortOrder
  }

  export type job_scheduleCountOrderByAggregateInput = {
    job_schedule_id?: SortOrder
    job_schedule_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_scheduleAvgOrderByAggregateInput = {
    job_schedule_id?: SortOrder
  }

  export type job_scheduleMaxOrderByAggregateInput = {
    job_schedule_id?: SortOrder
    job_schedule_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_scheduleMinOrderByAggregateInput = {
    job_schedule_id?: SortOrder
    job_schedule_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_scheduleSumOrderByAggregateInput = {
    job_schedule_id?: SortOrder
  }

  export type Job_scheduleScalarRelationFilter = {
    is?: job_scheduleWhereInput
    isNot?: job_scheduleWhereInput
  }

  export type job_schedule_mapJob_idSchedule_idCompoundUniqueInput = {
    job_id: number
    schedule_id: number
  }

  export type job_schedule_mapCountOrderByAggregateInput = {
    job_schedule_map_id?: SortOrder
    job_schedule_map_uuid?: SortOrder
    job_id?: SortOrder
    schedule_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_schedule_mapAvgOrderByAggregateInput = {
    job_schedule_map_id?: SortOrder
    job_id?: SortOrder
    schedule_id?: SortOrder
  }

  export type job_schedule_mapMaxOrderByAggregateInput = {
    job_schedule_map_id?: SortOrder
    job_schedule_map_uuid?: SortOrder
    job_id?: SortOrder
    schedule_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_schedule_mapMinOrderByAggregateInput = {
    job_schedule_map_id?: SortOrder
    job_schedule_map_uuid?: SortOrder
    job_id?: SortOrder
    schedule_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_schedule_mapSumOrderByAggregateInput = {
    job_schedule_map_id?: SortOrder
    job_id?: SortOrder
    schedule_id?: SortOrder
  }

  export type job_skillCountOrderByAggregateInput = {
    job_skill_id?: SortOrder
    job_skill_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_skillAvgOrderByAggregateInput = {
    job_skill_id?: SortOrder
  }

  export type job_skillMaxOrderByAggregateInput = {
    job_skill_id?: SortOrder
    job_skill_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_skillMinOrderByAggregateInput = {
    job_skill_id?: SortOrder
    job_skill_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_skillSumOrderByAggregateInput = {
    job_skill_id?: SortOrder
  }

  export type Job_skillScalarRelationFilter = {
    is?: job_skillWhereInput
    isNot?: job_skillWhereInput
  }

  export type job_skill_mapJob_idSkill_idCompoundUniqueInput = {
    job_id: number
    skill_id: number
  }

  export type job_skill_mapCountOrderByAggregateInput = {
    job_skill_map_id?: SortOrder
    job_skill_map_uuid?: SortOrder
    job_id?: SortOrder
    skill_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_skill_mapAvgOrderByAggregateInput = {
    job_skill_map_id?: SortOrder
    job_id?: SortOrder
    skill_id?: SortOrder
  }

  export type job_skill_mapMaxOrderByAggregateInput = {
    job_skill_map_id?: SortOrder
    job_skill_map_uuid?: SortOrder
    job_id?: SortOrder
    skill_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_skill_mapMinOrderByAggregateInput = {
    job_skill_map_id?: SortOrder
    job_skill_map_uuid?: SortOrder
    job_id?: SortOrder
    skill_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_skill_mapSumOrderByAggregateInput = {
    job_skill_map_id?: SortOrder
    job_id?: SortOrder
    skill_id?: SortOrder
  }

  export type job_sourceCountOrderByAggregateInput = {
    job_source_id?: SortOrder
    job_source_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_sourceAvgOrderByAggregateInput = {
    job_source_id?: SortOrder
  }

  export type job_sourceMaxOrderByAggregateInput = {
    job_source_id?: SortOrder
    job_source_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_sourceMinOrderByAggregateInput = {
    job_source_id?: SortOrder
    job_source_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_sourceSumOrderByAggregateInput = {
    job_source_id?: SortOrder
  }

  export type Job_sourceScalarRelationFilter = {
    is?: job_sourceWhereInput
    isNot?: job_sourceWhereInput
  }

  export type job_source_mapJob_idSource_idCompoundUniqueInput = {
    job_id: number
    source_id: number
  }

  export type job_source_mapCountOrderByAggregateInput = {
    job_source_map_id?: SortOrder
    job_source_map_uuid?: SortOrder
    job_id?: SortOrder
    source_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_source_mapAvgOrderByAggregateInput = {
    job_source_map_id?: SortOrder
    job_id?: SortOrder
    source_id?: SortOrder
  }

  export type job_source_mapMaxOrderByAggregateInput = {
    job_source_map_id?: SortOrder
    job_source_map_uuid?: SortOrder
    job_id?: SortOrder
    source_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_source_mapMinOrderByAggregateInput = {
    job_source_map_id?: SortOrder
    job_source_map_uuid?: SortOrder
    job_id?: SortOrder
    source_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_source_mapSumOrderByAggregateInput = {
    job_source_map_id?: SortOrder
    job_id?: SortOrder
    source_id?: SortOrder
  }

  export type job_typeCountOrderByAggregateInput = {
    job_type_id?: SortOrder
    job_type_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_typeAvgOrderByAggregateInput = {
    job_type_id?: SortOrder
  }

  export type job_typeMaxOrderByAggregateInput = {
    job_type_id?: SortOrder
    job_type_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_typeMinOrderByAggregateInput = {
    job_type_id?: SortOrder
    job_type_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_typeSumOrderByAggregateInput = {
    job_type_id?: SortOrder
  }

  export type Job_typeScalarRelationFilter = {
    is?: job_typeWhereInput
    isNot?: job_typeWhereInput
  }

  export type job_type_mapJob_idType_idCompoundUniqueInput = {
    job_id: number
    type_id: number
  }

  export type job_type_mapCountOrderByAggregateInput = {
    job_type_map_id?: SortOrder
    job_type_map_uuid?: SortOrder
    job_id?: SortOrder
    type_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_type_mapAvgOrderByAggregateInput = {
    job_type_map_id?: SortOrder
    job_id?: SortOrder
    type_id?: SortOrder
  }

  export type job_type_mapMaxOrderByAggregateInput = {
    job_type_map_id?: SortOrder
    job_type_map_uuid?: SortOrder
    job_id?: SortOrder
    type_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_type_mapMinOrderByAggregateInput = {
    job_type_map_id?: SortOrder
    job_type_map_uuid?: SortOrder
    job_id?: SortOrder
    type_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type job_type_mapSumOrderByAggregateInput = {
    job_type_map_id?: SortOrder
    job_id?: SortOrder
    type_id?: SortOrder
  }

  export type CompanyListRelationFilter = {
    every?: companyWhereInput
    some?: companyWhereInput
    none?: companyWhereInput
  }

  export type companyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cityCity_nameState_idCompoundUniqueInput = {
    city_name: string
    state_id: number
  }

  export type cityCountOrderByAggregateInput = {
    city_id?: SortOrder
    city_name?: SortOrder
    state_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type cityAvgOrderByAggregateInput = {
    city_id?: SortOrder
    state_id?: SortOrder
  }

  export type cityMaxOrderByAggregateInput = {
    city_id?: SortOrder
    city_name?: SortOrder
    state_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type cityMinOrderByAggregateInput = {
    city_id?: SortOrder
    city_name?: SortOrder
    state_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type citySumOrderByAggregateInput = {
    city_id?: SortOrder
    state_id?: SortOrder
  }

  export type StateListRelationFilter = {
    every?: stateWhereInput
    some?: stateWhereInput
    none?: stateWhereInput
  }

  export type stateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type countryCountOrderByAggregateInput = {
    country_id?: SortOrder
    country_name?: SortOrder
    country_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type countryAvgOrderByAggregateInput = {
    country_id?: SortOrder
  }

  export type countryMaxOrderByAggregateInput = {
    country_id?: SortOrder
    country_name?: SortOrder
    country_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type countryMinOrderByAggregateInput = {
    country_id?: SortOrder
    country_name?: SortOrder
    country_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type countrySumOrderByAggregateInput = {
    country_id?: SortOrder
  }

  export type CityListRelationFilter = {
    every?: cityWhereInput
    some?: cityWhereInput
    none?: cityWhereInput
  }

  export type cityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type stateState_codeCountry_idCompoundUniqueInput = {
    state_code: string
    country_id: number
  }

  export type stateCountOrderByAggregateInput = {
    state_id?: SortOrder
    state_name?: SortOrder
    state_code?: SortOrder
    country_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type stateAvgOrderByAggregateInput = {
    state_id?: SortOrder
    country_id?: SortOrder
  }

  export type stateMaxOrderByAggregateInput = {
    state_id?: SortOrder
    state_name?: SortOrder
    state_code?: SortOrder
    country_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type stateMinOrderByAggregateInput = {
    state_id?: SortOrder
    state_name?: SortOrder
    state_code?: SortOrder
    country_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type stateSumOrderByAggregateInput = {
    state_id?: SortOrder
    country_id?: SortOrder
  }

  export type cityCreateNestedOneWithoutCompanyInput = {
    create?: XOR<cityCreateWithoutCompanyInput, cityUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: cityCreateOrConnectWithoutCompanyInput
    connect?: cityWhereUniqueInput
  }

  export type countryCreateNestedOneWithoutCompanyInput = {
    create?: XOR<countryCreateWithoutCompanyInput, countryUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: countryCreateOrConnectWithoutCompanyInput
    connect?: countryWhereUniqueInput
  }

  export type stateCreateNestedOneWithoutCompanyInput = {
    create?: XOR<stateCreateWithoutCompanyInput, stateUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: stateCreateOrConnectWithoutCompanyInput
    connect?: stateWhereUniqueInput
  }

  export type company_imageCreateNestedManyWithoutCompanyInput = {
    create?: XOR<company_imageCreateWithoutCompanyInput, company_imageUncheckedCreateWithoutCompanyInput> | company_imageCreateWithoutCompanyInput[] | company_imageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: company_imageCreateOrConnectWithoutCompanyInput | company_imageCreateOrConnectWithoutCompanyInput[]
    createMany?: company_imageCreateManyCompanyInputEnvelope
    connect?: company_imageWhereUniqueInput | company_imageWhereUniqueInput[]
  }

  export type company_industryCreateNestedManyWithoutCompanyInput = {
    create?: XOR<company_industryCreateWithoutCompanyInput, company_industryUncheckedCreateWithoutCompanyInput> | company_industryCreateWithoutCompanyInput[] | company_industryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: company_industryCreateOrConnectWithoutCompanyInput | company_industryCreateOrConnectWithoutCompanyInput[]
    createMany?: company_industryCreateManyCompanyInputEnvelope
    connect?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
  }

  export type jobCreateNestedManyWithoutCompanyInput = {
    create?: XOR<jobCreateWithoutCompanyInput, jobUncheckedCreateWithoutCompanyInput> | jobCreateWithoutCompanyInput[] | jobUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: jobCreateOrConnectWithoutCompanyInput | jobCreateOrConnectWithoutCompanyInput[]
    createMany?: jobCreateManyCompanyInputEnvelope
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
  }

  export type company_imageUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<company_imageCreateWithoutCompanyInput, company_imageUncheckedCreateWithoutCompanyInput> | company_imageCreateWithoutCompanyInput[] | company_imageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: company_imageCreateOrConnectWithoutCompanyInput | company_imageCreateOrConnectWithoutCompanyInput[]
    createMany?: company_imageCreateManyCompanyInputEnvelope
    connect?: company_imageWhereUniqueInput | company_imageWhereUniqueInput[]
  }

  export type company_industryUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<company_industryCreateWithoutCompanyInput, company_industryUncheckedCreateWithoutCompanyInput> | company_industryCreateWithoutCompanyInput[] | company_industryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: company_industryCreateOrConnectWithoutCompanyInput | company_industryCreateOrConnectWithoutCompanyInput[]
    createMany?: company_industryCreateManyCompanyInputEnvelope
    connect?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
  }

  export type jobUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<jobCreateWithoutCompanyInput, jobUncheckedCreateWithoutCompanyInput> | jobCreateWithoutCompanyInput[] | jobUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: jobCreateOrConnectWithoutCompanyInput | jobCreateOrConnectWithoutCompanyInput[]
    createMany?: jobCreateManyCompanyInputEnvelope
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumcompanySizesFieldUpdateOperationsInput = {
    set?: $Enums.companySizes | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type cityUpdateOneRequiredWithoutCompanyNestedInput = {
    create?: XOR<cityCreateWithoutCompanyInput, cityUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: cityCreateOrConnectWithoutCompanyInput
    upsert?: cityUpsertWithoutCompanyInput
    connect?: cityWhereUniqueInput
    update?: XOR<XOR<cityUpdateToOneWithWhereWithoutCompanyInput, cityUpdateWithoutCompanyInput>, cityUncheckedUpdateWithoutCompanyInput>
  }

  export type countryUpdateOneRequiredWithoutCompanyNestedInput = {
    create?: XOR<countryCreateWithoutCompanyInput, countryUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: countryCreateOrConnectWithoutCompanyInput
    upsert?: countryUpsertWithoutCompanyInput
    connect?: countryWhereUniqueInput
    update?: XOR<XOR<countryUpdateToOneWithWhereWithoutCompanyInput, countryUpdateWithoutCompanyInput>, countryUncheckedUpdateWithoutCompanyInput>
  }

  export type stateUpdateOneRequiredWithoutCompanyNestedInput = {
    create?: XOR<stateCreateWithoutCompanyInput, stateUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: stateCreateOrConnectWithoutCompanyInput
    upsert?: stateUpsertWithoutCompanyInput
    connect?: stateWhereUniqueInput
    update?: XOR<XOR<stateUpdateToOneWithWhereWithoutCompanyInput, stateUpdateWithoutCompanyInput>, stateUncheckedUpdateWithoutCompanyInput>
  }

  export type company_imageUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<company_imageCreateWithoutCompanyInput, company_imageUncheckedCreateWithoutCompanyInput> | company_imageCreateWithoutCompanyInput[] | company_imageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: company_imageCreateOrConnectWithoutCompanyInput | company_imageCreateOrConnectWithoutCompanyInput[]
    upsert?: company_imageUpsertWithWhereUniqueWithoutCompanyInput | company_imageUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: company_imageCreateManyCompanyInputEnvelope
    set?: company_imageWhereUniqueInput | company_imageWhereUniqueInput[]
    disconnect?: company_imageWhereUniqueInput | company_imageWhereUniqueInput[]
    delete?: company_imageWhereUniqueInput | company_imageWhereUniqueInput[]
    connect?: company_imageWhereUniqueInput | company_imageWhereUniqueInput[]
    update?: company_imageUpdateWithWhereUniqueWithoutCompanyInput | company_imageUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: company_imageUpdateManyWithWhereWithoutCompanyInput | company_imageUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: company_imageScalarWhereInput | company_imageScalarWhereInput[]
  }

  export type company_industryUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<company_industryCreateWithoutCompanyInput, company_industryUncheckedCreateWithoutCompanyInput> | company_industryCreateWithoutCompanyInput[] | company_industryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: company_industryCreateOrConnectWithoutCompanyInput | company_industryCreateOrConnectWithoutCompanyInput[]
    upsert?: company_industryUpsertWithWhereUniqueWithoutCompanyInput | company_industryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: company_industryCreateManyCompanyInputEnvelope
    set?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
    disconnect?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
    delete?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
    connect?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
    update?: company_industryUpdateWithWhereUniqueWithoutCompanyInput | company_industryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: company_industryUpdateManyWithWhereWithoutCompanyInput | company_industryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: company_industryScalarWhereInput | company_industryScalarWhereInput[]
  }

  export type jobUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<jobCreateWithoutCompanyInput, jobUncheckedCreateWithoutCompanyInput> | jobCreateWithoutCompanyInput[] | jobUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: jobCreateOrConnectWithoutCompanyInput | jobCreateOrConnectWithoutCompanyInput[]
    upsert?: jobUpsertWithWhereUniqueWithoutCompanyInput | jobUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: jobCreateManyCompanyInputEnvelope
    set?: jobWhereUniqueInput | jobWhereUniqueInput[]
    disconnect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    delete?: jobWhereUniqueInput | jobWhereUniqueInput[]
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    update?: jobUpdateWithWhereUniqueWithoutCompanyInput | jobUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: jobUpdateManyWithWhereWithoutCompanyInput | jobUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: jobScalarWhereInput | jobScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type company_imageUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<company_imageCreateWithoutCompanyInput, company_imageUncheckedCreateWithoutCompanyInput> | company_imageCreateWithoutCompanyInput[] | company_imageUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: company_imageCreateOrConnectWithoutCompanyInput | company_imageCreateOrConnectWithoutCompanyInput[]
    upsert?: company_imageUpsertWithWhereUniqueWithoutCompanyInput | company_imageUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: company_imageCreateManyCompanyInputEnvelope
    set?: company_imageWhereUniqueInput | company_imageWhereUniqueInput[]
    disconnect?: company_imageWhereUniqueInput | company_imageWhereUniqueInput[]
    delete?: company_imageWhereUniqueInput | company_imageWhereUniqueInput[]
    connect?: company_imageWhereUniqueInput | company_imageWhereUniqueInput[]
    update?: company_imageUpdateWithWhereUniqueWithoutCompanyInput | company_imageUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: company_imageUpdateManyWithWhereWithoutCompanyInput | company_imageUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: company_imageScalarWhereInput | company_imageScalarWhereInput[]
  }

  export type company_industryUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<company_industryCreateWithoutCompanyInput, company_industryUncheckedCreateWithoutCompanyInput> | company_industryCreateWithoutCompanyInput[] | company_industryUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: company_industryCreateOrConnectWithoutCompanyInput | company_industryCreateOrConnectWithoutCompanyInput[]
    upsert?: company_industryUpsertWithWhereUniqueWithoutCompanyInput | company_industryUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: company_industryCreateManyCompanyInputEnvelope
    set?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
    disconnect?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
    delete?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
    connect?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
    update?: company_industryUpdateWithWhereUniqueWithoutCompanyInput | company_industryUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: company_industryUpdateManyWithWhereWithoutCompanyInput | company_industryUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: company_industryScalarWhereInput | company_industryScalarWhereInput[]
  }

  export type jobUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<jobCreateWithoutCompanyInput, jobUncheckedCreateWithoutCompanyInput> | jobCreateWithoutCompanyInput[] | jobUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: jobCreateOrConnectWithoutCompanyInput | jobCreateOrConnectWithoutCompanyInput[]
    upsert?: jobUpsertWithWhereUniqueWithoutCompanyInput | jobUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: jobCreateManyCompanyInputEnvelope
    set?: jobWhereUniqueInput | jobWhereUniqueInput[]
    disconnect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    delete?: jobWhereUniqueInput | jobWhereUniqueInput[]
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    update?: jobUpdateWithWhereUniqueWithoutCompanyInput | jobUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: jobUpdateManyWithWhereWithoutCompanyInput | jobUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: jobScalarWhereInput | jobScalarWhereInput[]
  }

  export type companyCreateNestedOneWithoutCompany_imageInput = {
    create?: XOR<companyCreateWithoutCompany_imageInput, companyUncheckedCreateWithoutCompany_imageInput>
    connectOrCreate?: companyCreateOrConnectWithoutCompany_imageInput
    connect?: companyWhereUniqueInput
  }

  export type companyUpdateOneRequiredWithoutCompany_imageNestedInput = {
    create?: XOR<companyCreateWithoutCompany_imageInput, companyUncheckedCreateWithoutCompany_imageInput>
    connectOrCreate?: companyCreateOrConnectWithoutCompany_imageInput
    upsert?: companyUpsertWithoutCompany_imageInput
    connect?: companyWhereUniqueInput
    update?: XOR<XOR<companyUpdateToOneWithWhereWithoutCompany_imageInput, companyUpdateWithoutCompany_imageInput>, companyUncheckedUpdateWithoutCompany_imageInput>
  }

  export type companyCreateNestedOneWithoutCompany_industryInput = {
    create?: XOR<companyCreateWithoutCompany_industryInput, companyUncheckedCreateWithoutCompany_industryInput>
    connectOrCreate?: companyCreateOrConnectWithoutCompany_industryInput
    connect?: companyWhereUniqueInput
  }

  export type industry_categoryCreateNestedOneWithoutCompany_industryInput = {
    create?: XOR<industry_categoryCreateWithoutCompany_industryInput, industry_categoryUncheckedCreateWithoutCompany_industryInput>
    connectOrCreate?: industry_categoryCreateOrConnectWithoutCompany_industryInput
    connect?: industry_categoryWhereUniqueInput
  }

  export type companyUpdateOneRequiredWithoutCompany_industryNestedInput = {
    create?: XOR<companyCreateWithoutCompany_industryInput, companyUncheckedCreateWithoutCompany_industryInput>
    connectOrCreate?: companyCreateOrConnectWithoutCompany_industryInput
    upsert?: companyUpsertWithoutCompany_industryInput
    connect?: companyWhereUniqueInput
    update?: XOR<XOR<companyUpdateToOneWithWhereWithoutCompany_industryInput, companyUpdateWithoutCompany_industryInput>, companyUncheckedUpdateWithoutCompany_industryInput>
  }

  export type industry_categoryUpdateOneRequiredWithoutCompany_industryNestedInput = {
    create?: XOR<industry_categoryCreateWithoutCompany_industryInput, industry_categoryUncheckedCreateWithoutCompany_industryInput>
    connectOrCreate?: industry_categoryCreateOrConnectWithoutCompany_industryInput
    upsert?: industry_categoryUpsertWithoutCompany_industryInput
    connect?: industry_categoryWhereUniqueInput
    update?: XOR<XOR<industry_categoryUpdateToOneWithWhereWithoutCompany_industryInput, industry_categoryUpdateWithoutCompany_industryInput>, industry_categoryUncheckedUpdateWithoutCompany_industryInput>
  }

  export type company_industryCreateNestedManyWithoutIndustry_categoryInput = {
    create?: XOR<company_industryCreateWithoutIndustry_categoryInput, company_industryUncheckedCreateWithoutIndustry_categoryInput> | company_industryCreateWithoutIndustry_categoryInput[] | company_industryUncheckedCreateWithoutIndustry_categoryInput[]
    connectOrCreate?: company_industryCreateOrConnectWithoutIndustry_categoryInput | company_industryCreateOrConnectWithoutIndustry_categoryInput[]
    createMany?: company_industryCreateManyIndustry_categoryInputEnvelope
    connect?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
  }

  export type company_industryUncheckedCreateNestedManyWithoutIndustry_categoryInput = {
    create?: XOR<company_industryCreateWithoutIndustry_categoryInput, company_industryUncheckedCreateWithoutIndustry_categoryInput> | company_industryCreateWithoutIndustry_categoryInput[] | company_industryUncheckedCreateWithoutIndustry_categoryInput[]
    connectOrCreate?: company_industryCreateOrConnectWithoutIndustry_categoryInput | company_industryCreateOrConnectWithoutIndustry_categoryInput[]
    createMany?: company_industryCreateManyIndustry_categoryInputEnvelope
    connect?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
  }

  export type company_industryUpdateManyWithoutIndustry_categoryNestedInput = {
    create?: XOR<company_industryCreateWithoutIndustry_categoryInput, company_industryUncheckedCreateWithoutIndustry_categoryInput> | company_industryCreateWithoutIndustry_categoryInput[] | company_industryUncheckedCreateWithoutIndustry_categoryInput[]
    connectOrCreate?: company_industryCreateOrConnectWithoutIndustry_categoryInput | company_industryCreateOrConnectWithoutIndustry_categoryInput[]
    upsert?: company_industryUpsertWithWhereUniqueWithoutIndustry_categoryInput | company_industryUpsertWithWhereUniqueWithoutIndustry_categoryInput[]
    createMany?: company_industryCreateManyIndustry_categoryInputEnvelope
    set?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
    disconnect?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
    delete?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
    connect?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
    update?: company_industryUpdateWithWhereUniqueWithoutIndustry_categoryInput | company_industryUpdateWithWhereUniqueWithoutIndustry_categoryInput[]
    updateMany?: company_industryUpdateManyWithWhereWithoutIndustry_categoryInput | company_industryUpdateManyWithWhereWithoutIndustry_categoryInput[]
    deleteMany?: company_industryScalarWhereInput | company_industryScalarWhereInput[]
  }

  export type company_industryUncheckedUpdateManyWithoutIndustry_categoryNestedInput = {
    create?: XOR<company_industryCreateWithoutIndustry_categoryInput, company_industryUncheckedCreateWithoutIndustry_categoryInput> | company_industryCreateWithoutIndustry_categoryInput[] | company_industryUncheckedCreateWithoutIndustry_categoryInput[]
    connectOrCreate?: company_industryCreateOrConnectWithoutIndustry_categoryInput | company_industryCreateOrConnectWithoutIndustry_categoryInput[]
    upsert?: company_industryUpsertWithWhereUniqueWithoutIndustry_categoryInput | company_industryUpsertWithWhereUniqueWithoutIndustry_categoryInput[]
    createMany?: company_industryCreateManyIndustry_categoryInputEnvelope
    set?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
    disconnect?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
    delete?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
    connect?: company_industryWhereUniqueInput | company_industryWhereUniqueInput[]
    update?: company_industryUpdateWithWhereUniqueWithoutIndustry_categoryInput | company_industryUpdateWithWhereUniqueWithoutIndustry_categoryInput[]
    updateMany?: company_industryUpdateManyWithWhereWithoutIndustry_categoryInput | company_industryUpdateManyWithWhereWithoutIndustry_categoryInput[]
    deleteMany?: company_industryScalarWhereInput | company_industryScalarWhereInput[]
  }

  export type cityCreateNestedOneWithoutJobInput = {
    create?: XOR<cityCreateWithoutJobInput, cityUncheckedCreateWithoutJobInput>
    connectOrCreate?: cityCreateOrConnectWithoutJobInput
    connect?: cityWhereUniqueInput
  }

  export type companyCreateNestedOneWithoutJobInput = {
    create?: XOR<companyCreateWithoutJobInput, companyUncheckedCreateWithoutJobInput>
    connectOrCreate?: companyCreateOrConnectWithoutJobInput
    connect?: companyWhereUniqueInput
  }

  export type countryCreateNestedOneWithoutJobInput = {
    create?: XOR<countryCreateWithoutJobInput, countryUncheckedCreateWithoutJobInput>
    connectOrCreate?: countryCreateOrConnectWithoutJobInput
    connect?: countryWhereUniqueInput
  }

  export type stateCreateNestedOneWithoutJobInput = {
    create?: XOR<stateCreateWithoutJobInput, stateUncheckedCreateWithoutJobInput>
    connectOrCreate?: stateCreateOrConnectWithoutJobInput
    connect?: stateWhereUniqueInput
  }

  export type job_category_mapCreateNestedManyWithoutJobInput = {
    create?: XOR<job_category_mapCreateWithoutJobInput, job_category_mapUncheckedCreateWithoutJobInput> | job_category_mapCreateWithoutJobInput[] | job_category_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_category_mapCreateOrConnectWithoutJobInput | job_category_mapCreateOrConnectWithoutJobInput[]
    createMany?: job_category_mapCreateManyJobInputEnvelope
    connect?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
  }

  export type job_salary_mapCreateNestedManyWithoutJobInput = {
    create?: XOR<job_salary_mapCreateWithoutJobInput, job_salary_mapUncheckedCreateWithoutJobInput> | job_salary_mapCreateWithoutJobInput[] | job_salary_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_salary_mapCreateOrConnectWithoutJobInput | job_salary_mapCreateOrConnectWithoutJobInput[]
    createMany?: job_salary_mapCreateManyJobInputEnvelope
    connect?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
  }

  export type job_schedule_mapCreateNestedManyWithoutJobInput = {
    create?: XOR<job_schedule_mapCreateWithoutJobInput, job_schedule_mapUncheckedCreateWithoutJobInput> | job_schedule_mapCreateWithoutJobInput[] | job_schedule_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_schedule_mapCreateOrConnectWithoutJobInput | job_schedule_mapCreateOrConnectWithoutJobInput[]
    createMany?: job_schedule_mapCreateManyJobInputEnvelope
    connect?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
  }

  export type job_skill_mapCreateNestedManyWithoutJobInput = {
    create?: XOR<job_skill_mapCreateWithoutJobInput, job_skill_mapUncheckedCreateWithoutJobInput> | job_skill_mapCreateWithoutJobInput[] | job_skill_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_skill_mapCreateOrConnectWithoutJobInput | job_skill_mapCreateOrConnectWithoutJobInput[]
    createMany?: job_skill_mapCreateManyJobInputEnvelope
    connect?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
  }

  export type job_source_mapCreateNestedManyWithoutJobInput = {
    create?: XOR<job_source_mapCreateWithoutJobInput, job_source_mapUncheckedCreateWithoutJobInput> | job_source_mapCreateWithoutJobInput[] | job_source_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_source_mapCreateOrConnectWithoutJobInput | job_source_mapCreateOrConnectWithoutJobInput[]
    createMany?: job_source_mapCreateManyJobInputEnvelope
    connect?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
  }

  export type job_type_mapCreateNestedManyWithoutJobInput = {
    create?: XOR<job_type_mapCreateWithoutJobInput, job_type_mapUncheckedCreateWithoutJobInput> | job_type_mapCreateWithoutJobInput[] | job_type_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_type_mapCreateOrConnectWithoutJobInput | job_type_mapCreateOrConnectWithoutJobInput[]
    createMany?: job_type_mapCreateManyJobInputEnvelope
    connect?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
  }

  export type job_category_mapUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<job_category_mapCreateWithoutJobInput, job_category_mapUncheckedCreateWithoutJobInput> | job_category_mapCreateWithoutJobInput[] | job_category_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_category_mapCreateOrConnectWithoutJobInput | job_category_mapCreateOrConnectWithoutJobInput[]
    createMany?: job_category_mapCreateManyJobInputEnvelope
    connect?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
  }

  export type job_salary_mapUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<job_salary_mapCreateWithoutJobInput, job_salary_mapUncheckedCreateWithoutJobInput> | job_salary_mapCreateWithoutJobInput[] | job_salary_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_salary_mapCreateOrConnectWithoutJobInput | job_salary_mapCreateOrConnectWithoutJobInput[]
    createMany?: job_salary_mapCreateManyJobInputEnvelope
    connect?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
  }

  export type job_schedule_mapUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<job_schedule_mapCreateWithoutJobInput, job_schedule_mapUncheckedCreateWithoutJobInput> | job_schedule_mapCreateWithoutJobInput[] | job_schedule_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_schedule_mapCreateOrConnectWithoutJobInput | job_schedule_mapCreateOrConnectWithoutJobInput[]
    createMany?: job_schedule_mapCreateManyJobInputEnvelope
    connect?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
  }

  export type job_skill_mapUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<job_skill_mapCreateWithoutJobInput, job_skill_mapUncheckedCreateWithoutJobInput> | job_skill_mapCreateWithoutJobInput[] | job_skill_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_skill_mapCreateOrConnectWithoutJobInput | job_skill_mapCreateOrConnectWithoutJobInput[]
    createMany?: job_skill_mapCreateManyJobInputEnvelope
    connect?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
  }

  export type job_source_mapUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<job_source_mapCreateWithoutJobInput, job_source_mapUncheckedCreateWithoutJobInput> | job_source_mapCreateWithoutJobInput[] | job_source_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_source_mapCreateOrConnectWithoutJobInput | job_source_mapCreateOrConnectWithoutJobInput[]
    createMany?: job_source_mapCreateManyJobInputEnvelope
    connect?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
  }

  export type job_type_mapUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<job_type_mapCreateWithoutJobInput, job_type_mapUncheckedCreateWithoutJobInput> | job_type_mapCreateWithoutJobInput[] | job_type_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_type_mapCreateOrConnectWithoutJobInput | job_type_mapCreateOrConnectWithoutJobInput[]
    createMany?: job_type_mapCreateManyJobInputEnvelope
    connect?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableEnumsalaryFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.salaryFrequency | null
  }

  export type cityUpdateOneRequiredWithoutJobNestedInput = {
    create?: XOR<cityCreateWithoutJobInput, cityUncheckedCreateWithoutJobInput>
    connectOrCreate?: cityCreateOrConnectWithoutJobInput
    upsert?: cityUpsertWithoutJobInput
    connect?: cityWhereUniqueInput
    update?: XOR<XOR<cityUpdateToOneWithWhereWithoutJobInput, cityUpdateWithoutJobInput>, cityUncheckedUpdateWithoutJobInput>
  }

  export type companyUpdateOneRequiredWithoutJobNestedInput = {
    create?: XOR<companyCreateWithoutJobInput, companyUncheckedCreateWithoutJobInput>
    connectOrCreate?: companyCreateOrConnectWithoutJobInput
    upsert?: companyUpsertWithoutJobInput
    connect?: companyWhereUniqueInput
    update?: XOR<XOR<companyUpdateToOneWithWhereWithoutJobInput, companyUpdateWithoutJobInput>, companyUncheckedUpdateWithoutJobInput>
  }

  export type countryUpdateOneRequiredWithoutJobNestedInput = {
    create?: XOR<countryCreateWithoutJobInput, countryUncheckedCreateWithoutJobInput>
    connectOrCreate?: countryCreateOrConnectWithoutJobInput
    upsert?: countryUpsertWithoutJobInput
    connect?: countryWhereUniqueInput
    update?: XOR<XOR<countryUpdateToOneWithWhereWithoutJobInput, countryUpdateWithoutJobInput>, countryUncheckedUpdateWithoutJobInput>
  }

  export type stateUpdateOneRequiredWithoutJobNestedInput = {
    create?: XOR<stateCreateWithoutJobInput, stateUncheckedCreateWithoutJobInput>
    connectOrCreate?: stateCreateOrConnectWithoutJobInput
    upsert?: stateUpsertWithoutJobInput
    connect?: stateWhereUniqueInput
    update?: XOR<XOR<stateUpdateToOneWithWhereWithoutJobInput, stateUpdateWithoutJobInput>, stateUncheckedUpdateWithoutJobInput>
  }

  export type job_category_mapUpdateManyWithoutJobNestedInput = {
    create?: XOR<job_category_mapCreateWithoutJobInput, job_category_mapUncheckedCreateWithoutJobInput> | job_category_mapCreateWithoutJobInput[] | job_category_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_category_mapCreateOrConnectWithoutJobInput | job_category_mapCreateOrConnectWithoutJobInput[]
    upsert?: job_category_mapUpsertWithWhereUniqueWithoutJobInput | job_category_mapUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: job_category_mapCreateManyJobInputEnvelope
    set?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
    disconnect?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
    delete?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
    connect?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
    update?: job_category_mapUpdateWithWhereUniqueWithoutJobInput | job_category_mapUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: job_category_mapUpdateManyWithWhereWithoutJobInput | job_category_mapUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: job_category_mapScalarWhereInput | job_category_mapScalarWhereInput[]
  }

  export type job_salary_mapUpdateManyWithoutJobNestedInput = {
    create?: XOR<job_salary_mapCreateWithoutJobInput, job_salary_mapUncheckedCreateWithoutJobInput> | job_salary_mapCreateWithoutJobInput[] | job_salary_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_salary_mapCreateOrConnectWithoutJobInput | job_salary_mapCreateOrConnectWithoutJobInput[]
    upsert?: job_salary_mapUpsertWithWhereUniqueWithoutJobInput | job_salary_mapUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: job_salary_mapCreateManyJobInputEnvelope
    set?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
    disconnect?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
    delete?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
    connect?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
    update?: job_salary_mapUpdateWithWhereUniqueWithoutJobInput | job_salary_mapUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: job_salary_mapUpdateManyWithWhereWithoutJobInput | job_salary_mapUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: job_salary_mapScalarWhereInput | job_salary_mapScalarWhereInput[]
  }

  export type job_schedule_mapUpdateManyWithoutJobNestedInput = {
    create?: XOR<job_schedule_mapCreateWithoutJobInput, job_schedule_mapUncheckedCreateWithoutJobInput> | job_schedule_mapCreateWithoutJobInput[] | job_schedule_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_schedule_mapCreateOrConnectWithoutJobInput | job_schedule_mapCreateOrConnectWithoutJobInput[]
    upsert?: job_schedule_mapUpsertWithWhereUniqueWithoutJobInput | job_schedule_mapUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: job_schedule_mapCreateManyJobInputEnvelope
    set?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
    disconnect?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
    delete?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
    connect?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
    update?: job_schedule_mapUpdateWithWhereUniqueWithoutJobInput | job_schedule_mapUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: job_schedule_mapUpdateManyWithWhereWithoutJobInput | job_schedule_mapUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: job_schedule_mapScalarWhereInput | job_schedule_mapScalarWhereInput[]
  }

  export type job_skill_mapUpdateManyWithoutJobNestedInput = {
    create?: XOR<job_skill_mapCreateWithoutJobInput, job_skill_mapUncheckedCreateWithoutJobInput> | job_skill_mapCreateWithoutJobInput[] | job_skill_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_skill_mapCreateOrConnectWithoutJobInput | job_skill_mapCreateOrConnectWithoutJobInput[]
    upsert?: job_skill_mapUpsertWithWhereUniqueWithoutJobInput | job_skill_mapUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: job_skill_mapCreateManyJobInputEnvelope
    set?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
    disconnect?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
    delete?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
    connect?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
    update?: job_skill_mapUpdateWithWhereUniqueWithoutJobInput | job_skill_mapUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: job_skill_mapUpdateManyWithWhereWithoutJobInput | job_skill_mapUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: job_skill_mapScalarWhereInput | job_skill_mapScalarWhereInput[]
  }

  export type job_source_mapUpdateManyWithoutJobNestedInput = {
    create?: XOR<job_source_mapCreateWithoutJobInput, job_source_mapUncheckedCreateWithoutJobInput> | job_source_mapCreateWithoutJobInput[] | job_source_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_source_mapCreateOrConnectWithoutJobInput | job_source_mapCreateOrConnectWithoutJobInput[]
    upsert?: job_source_mapUpsertWithWhereUniqueWithoutJobInput | job_source_mapUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: job_source_mapCreateManyJobInputEnvelope
    set?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
    disconnect?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
    delete?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
    connect?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
    update?: job_source_mapUpdateWithWhereUniqueWithoutJobInput | job_source_mapUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: job_source_mapUpdateManyWithWhereWithoutJobInput | job_source_mapUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: job_source_mapScalarWhereInput | job_source_mapScalarWhereInput[]
  }

  export type job_type_mapUpdateManyWithoutJobNestedInput = {
    create?: XOR<job_type_mapCreateWithoutJobInput, job_type_mapUncheckedCreateWithoutJobInput> | job_type_mapCreateWithoutJobInput[] | job_type_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_type_mapCreateOrConnectWithoutJobInput | job_type_mapCreateOrConnectWithoutJobInput[]
    upsert?: job_type_mapUpsertWithWhereUniqueWithoutJobInput | job_type_mapUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: job_type_mapCreateManyJobInputEnvelope
    set?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
    disconnect?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
    delete?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
    connect?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
    update?: job_type_mapUpdateWithWhereUniqueWithoutJobInput | job_type_mapUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: job_type_mapUpdateManyWithWhereWithoutJobInput | job_type_mapUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: job_type_mapScalarWhereInput | job_type_mapScalarWhereInput[]
  }

  export type job_category_mapUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<job_category_mapCreateWithoutJobInput, job_category_mapUncheckedCreateWithoutJobInput> | job_category_mapCreateWithoutJobInput[] | job_category_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_category_mapCreateOrConnectWithoutJobInput | job_category_mapCreateOrConnectWithoutJobInput[]
    upsert?: job_category_mapUpsertWithWhereUniqueWithoutJobInput | job_category_mapUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: job_category_mapCreateManyJobInputEnvelope
    set?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
    disconnect?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
    delete?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
    connect?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
    update?: job_category_mapUpdateWithWhereUniqueWithoutJobInput | job_category_mapUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: job_category_mapUpdateManyWithWhereWithoutJobInput | job_category_mapUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: job_category_mapScalarWhereInput | job_category_mapScalarWhereInput[]
  }

  export type job_salary_mapUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<job_salary_mapCreateWithoutJobInput, job_salary_mapUncheckedCreateWithoutJobInput> | job_salary_mapCreateWithoutJobInput[] | job_salary_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_salary_mapCreateOrConnectWithoutJobInput | job_salary_mapCreateOrConnectWithoutJobInput[]
    upsert?: job_salary_mapUpsertWithWhereUniqueWithoutJobInput | job_salary_mapUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: job_salary_mapCreateManyJobInputEnvelope
    set?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
    disconnect?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
    delete?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
    connect?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
    update?: job_salary_mapUpdateWithWhereUniqueWithoutJobInput | job_salary_mapUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: job_salary_mapUpdateManyWithWhereWithoutJobInput | job_salary_mapUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: job_salary_mapScalarWhereInput | job_salary_mapScalarWhereInput[]
  }

  export type job_schedule_mapUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<job_schedule_mapCreateWithoutJobInput, job_schedule_mapUncheckedCreateWithoutJobInput> | job_schedule_mapCreateWithoutJobInput[] | job_schedule_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_schedule_mapCreateOrConnectWithoutJobInput | job_schedule_mapCreateOrConnectWithoutJobInput[]
    upsert?: job_schedule_mapUpsertWithWhereUniqueWithoutJobInput | job_schedule_mapUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: job_schedule_mapCreateManyJobInputEnvelope
    set?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
    disconnect?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
    delete?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
    connect?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
    update?: job_schedule_mapUpdateWithWhereUniqueWithoutJobInput | job_schedule_mapUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: job_schedule_mapUpdateManyWithWhereWithoutJobInput | job_schedule_mapUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: job_schedule_mapScalarWhereInput | job_schedule_mapScalarWhereInput[]
  }

  export type job_skill_mapUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<job_skill_mapCreateWithoutJobInput, job_skill_mapUncheckedCreateWithoutJobInput> | job_skill_mapCreateWithoutJobInput[] | job_skill_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_skill_mapCreateOrConnectWithoutJobInput | job_skill_mapCreateOrConnectWithoutJobInput[]
    upsert?: job_skill_mapUpsertWithWhereUniqueWithoutJobInput | job_skill_mapUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: job_skill_mapCreateManyJobInputEnvelope
    set?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
    disconnect?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
    delete?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
    connect?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
    update?: job_skill_mapUpdateWithWhereUniqueWithoutJobInput | job_skill_mapUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: job_skill_mapUpdateManyWithWhereWithoutJobInput | job_skill_mapUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: job_skill_mapScalarWhereInput | job_skill_mapScalarWhereInput[]
  }

  export type job_source_mapUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<job_source_mapCreateWithoutJobInput, job_source_mapUncheckedCreateWithoutJobInput> | job_source_mapCreateWithoutJobInput[] | job_source_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_source_mapCreateOrConnectWithoutJobInput | job_source_mapCreateOrConnectWithoutJobInput[]
    upsert?: job_source_mapUpsertWithWhereUniqueWithoutJobInput | job_source_mapUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: job_source_mapCreateManyJobInputEnvelope
    set?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
    disconnect?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
    delete?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
    connect?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
    update?: job_source_mapUpdateWithWhereUniqueWithoutJobInput | job_source_mapUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: job_source_mapUpdateManyWithWhereWithoutJobInput | job_source_mapUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: job_source_mapScalarWhereInput | job_source_mapScalarWhereInput[]
  }

  export type job_type_mapUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<job_type_mapCreateWithoutJobInput, job_type_mapUncheckedCreateWithoutJobInput> | job_type_mapCreateWithoutJobInput[] | job_type_mapUncheckedCreateWithoutJobInput[]
    connectOrCreate?: job_type_mapCreateOrConnectWithoutJobInput | job_type_mapCreateOrConnectWithoutJobInput[]
    upsert?: job_type_mapUpsertWithWhereUniqueWithoutJobInput | job_type_mapUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: job_type_mapCreateManyJobInputEnvelope
    set?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
    disconnect?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
    delete?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
    connect?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
    update?: job_type_mapUpdateWithWhereUniqueWithoutJobInput | job_type_mapUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: job_type_mapUpdateManyWithWhereWithoutJobInput | job_type_mapUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: job_type_mapScalarWhereInput | job_type_mapScalarWhereInput[]
  }

  export type job_category_mapCreateNestedManyWithoutJob_categoryInput = {
    create?: XOR<job_category_mapCreateWithoutJob_categoryInput, job_category_mapUncheckedCreateWithoutJob_categoryInput> | job_category_mapCreateWithoutJob_categoryInput[] | job_category_mapUncheckedCreateWithoutJob_categoryInput[]
    connectOrCreate?: job_category_mapCreateOrConnectWithoutJob_categoryInput | job_category_mapCreateOrConnectWithoutJob_categoryInput[]
    createMany?: job_category_mapCreateManyJob_categoryInputEnvelope
    connect?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
  }

  export type job_category_mapUncheckedCreateNestedManyWithoutJob_categoryInput = {
    create?: XOR<job_category_mapCreateWithoutJob_categoryInput, job_category_mapUncheckedCreateWithoutJob_categoryInput> | job_category_mapCreateWithoutJob_categoryInput[] | job_category_mapUncheckedCreateWithoutJob_categoryInput[]
    connectOrCreate?: job_category_mapCreateOrConnectWithoutJob_categoryInput | job_category_mapCreateOrConnectWithoutJob_categoryInput[]
    createMany?: job_category_mapCreateManyJob_categoryInputEnvelope
    connect?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
  }

  export type job_category_mapUpdateManyWithoutJob_categoryNestedInput = {
    create?: XOR<job_category_mapCreateWithoutJob_categoryInput, job_category_mapUncheckedCreateWithoutJob_categoryInput> | job_category_mapCreateWithoutJob_categoryInput[] | job_category_mapUncheckedCreateWithoutJob_categoryInput[]
    connectOrCreate?: job_category_mapCreateOrConnectWithoutJob_categoryInput | job_category_mapCreateOrConnectWithoutJob_categoryInput[]
    upsert?: job_category_mapUpsertWithWhereUniqueWithoutJob_categoryInput | job_category_mapUpsertWithWhereUniqueWithoutJob_categoryInput[]
    createMany?: job_category_mapCreateManyJob_categoryInputEnvelope
    set?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
    disconnect?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
    delete?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
    connect?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
    update?: job_category_mapUpdateWithWhereUniqueWithoutJob_categoryInput | job_category_mapUpdateWithWhereUniqueWithoutJob_categoryInput[]
    updateMany?: job_category_mapUpdateManyWithWhereWithoutJob_categoryInput | job_category_mapUpdateManyWithWhereWithoutJob_categoryInput[]
    deleteMany?: job_category_mapScalarWhereInput | job_category_mapScalarWhereInput[]
  }

  export type job_category_mapUncheckedUpdateManyWithoutJob_categoryNestedInput = {
    create?: XOR<job_category_mapCreateWithoutJob_categoryInput, job_category_mapUncheckedCreateWithoutJob_categoryInput> | job_category_mapCreateWithoutJob_categoryInput[] | job_category_mapUncheckedCreateWithoutJob_categoryInput[]
    connectOrCreate?: job_category_mapCreateOrConnectWithoutJob_categoryInput | job_category_mapCreateOrConnectWithoutJob_categoryInput[]
    upsert?: job_category_mapUpsertWithWhereUniqueWithoutJob_categoryInput | job_category_mapUpsertWithWhereUniqueWithoutJob_categoryInput[]
    createMany?: job_category_mapCreateManyJob_categoryInputEnvelope
    set?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
    disconnect?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
    delete?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
    connect?: job_category_mapWhereUniqueInput | job_category_mapWhereUniqueInput[]
    update?: job_category_mapUpdateWithWhereUniqueWithoutJob_categoryInput | job_category_mapUpdateWithWhereUniqueWithoutJob_categoryInput[]
    updateMany?: job_category_mapUpdateManyWithWhereWithoutJob_categoryInput | job_category_mapUpdateManyWithWhereWithoutJob_categoryInput[]
    deleteMany?: job_category_mapScalarWhereInput | job_category_mapScalarWhereInput[]
  }

  export type job_categoryCreateNestedOneWithoutJob_category_mapInput = {
    create?: XOR<job_categoryCreateWithoutJob_category_mapInput, job_categoryUncheckedCreateWithoutJob_category_mapInput>
    connectOrCreate?: job_categoryCreateOrConnectWithoutJob_category_mapInput
    connect?: job_categoryWhereUniqueInput
  }

  export type jobCreateNestedOneWithoutJob_category_mapInput = {
    create?: XOR<jobCreateWithoutJob_category_mapInput, jobUncheckedCreateWithoutJob_category_mapInput>
    connectOrCreate?: jobCreateOrConnectWithoutJob_category_mapInput
    connect?: jobWhereUniqueInput
  }

  export type job_categoryUpdateOneRequiredWithoutJob_category_mapNestedInput = {
    create?: XOR<job_categoryCreateWithoutJob_category_mapInput, job_categoryUncheckedCreateWithoutJob_category_mapInput>
    connectOrCreate?: job_categoryCreateOrConnectWithoutJob_category_mapInput
    upsert?: job_categoryUpsertWithoutJob_category_mapInput
    connect?: job_categoryWhereUniqueInput
    update?: XOR<XOR<job_categoryUpdateToOneWithWhereWithoutJob_category_mapInput, job_categoryUpdateWithoutJob_category_mapInput>, job_categoryUncheckedUpdateWithoutJob_category_mapInput>
  }

  export type jobUpdateOneRequiredWithoutJob_category_mapNestedInput = {
    create?: XOR<jobCreateWithoutJob_category_mapInput, jobUncheckedCreateWithoutJob_category_mapInput>
    connectOrCreate?: jobCreateOrConnectWithoutJob_category_mapInput
    upsert?: jobUpsertWithoutJob_category_mapInput
    connect?: jobWhereUniqueInput
    update?: XOR<XOR<jobUpdateToOneWithWhereWithoutJob_category_mapInput, jobUpdateWithoutJob_category_mapInput>, jobUncheckedUpdateWithoutJob_category_mapInput>
  }

  export type job_salary_mapCreateNestedManyWithoutJob_salaryInput = {
    create?: XOR<job_salary_mapCreateWithoutJob_salaryInput, job_salary_mapUncheckedCreateWithoutJob_salaryInput> | job_salary_mapCreateWithoutJob_salaryInput[] | job_salary_mapUncheckedCreateWithoutJob_salaryInput[]
    connectOrCreate?: job_salary_mapCreateOrConnectWithoutJob_salaryInput | job_salary_mapCreateOrConnectWithoutJob_salaryInput[]
    createMany?: job_salary_mapCreateManyJob_salaryInputEnvelope
    connect?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
  }

  export type job_salary_mapUncheckedCreateNestedManyWithoutJob_salaryInput = {
    create?: XOR<job_salary_mapCreateWithoutJob_salaryInput, job_salary_mapUncheckedCreateWithoutJob_salaryInput> | job_salary_mapCreateWithoutJob_salaryInput[] | job_salary_mapUncheckedCreateWithoutJob_salaryInput[]
    connectOrCreate?: job_salary_mapCreateOrConnectWithoutJob_salaryInput | job_salary_mapCreateOrConnectWithoutJob_salaryInput[]
    createMany?: job_salary_mapCreateManyJob_salaryInputEnvelope
    connect?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
  }

  export type job_salary_mapUpdateManyWithoutJob_salaryNestedInput = {
    create?: XOR<job_salary_mapCreateWithoutJob_salaryInput, job_salary_mapUncheckedCreateWithoutJob_salaryInput> | job_salary_mapCreateWithoutJob_salaryInput[] | job_salary_mapUncheckedCreateWithoutJob_salaryInput[]
    connectOrCreate?: job_salary_mapCreateOrConnectWithoutJob_salaryInput | job_salary_mapCreateOrConnectWithoutJob_salaryInput[]
    upsert?: job_salary_mapUpsertWithWhereUniqueWithoutJob_salaryInput | job_salary_mapUpsertWithWhereUniqueWithoutJob_salaryInput[]
    createMany?: job_salary_mapCreateManyJob_salaryInputEnvelope
    set?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
    disconnect?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
    delete?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
    connect?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
    update?: job_salary_mapUpdateWithWhereUniqueWithoutJob_salaryInput | job_salary_mapUpdateWithWhereUniqueWithoutJob_salaryInput[]
    updateMany?: job_salary_mapUpdateManyWithWhereWithoutJob_salaryInput | job_salary_mapUpdateManyWithWhereWithoutJob_salaryInput[]
    deleteMany?: job_salary_mapScalarWhereInput | job_salary_mapScalarWhereInput[]
  }

  export type job_salary_mapUncheckedUpdateManyWithoutJob_salaryNestedInput = {
    create?: XOR<job_salary_mapCreateWithoutJob_salaryInput, job_salary_mapUncheckedCreateWithoutJob_salaryInput> | job_salary_mapCreateWithoutJob_salaryInput[] | job_salary_mapUncheckedCreateWithoutJob_salaryInput[]
    connectOrCreate?: job_salary_mapCreateOrConnectWithoutJob_salaryInput | job_salary_mapCreateOrConnectWithoutJob_salaryInput[]
    upsert?: job_salary_mapUpsertWithWhereUniqueWithoutJob_salaryInput | job_salary_mapUpsertWithWhereUniqueWithoutJob_salaryInput[]
    createMany?: job_salary_mapCreateManyJob_salaryInputEnvelope
    set?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
    disconnect?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
    delete?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
    connect?: job_salary_mapWhereUniqueInput | job_salary_mapWhereUniqueInput[]
    update?: job_salary_mapUpdateWithWhereUniqueWithoutJob_salaryInput | job_salary_mapUpdateWithWhereUniqueWithoutJob_salaryInput[]
    updateMany?: job_salary_mapUpdateManyWithWhereWithoutJob_salaryInput | job_salary_mapUpdateManyWithWhereWithoutJob_salaryInput[]
    deleteMany?: job_salary_mapScalarWhereInput | job_salary_mapScalarWhereInput[]
  }

  export type jobCreateNestedOneWithoutJob_salary_mapInput = {
    create?: XOR<jobCreateWithoutJob_salary_mapInput, jobUncheckedCreateWithoutJob_salary_mapInput>
    connectOrCreate?: jobCreateOrConnectWithoutJob_salary_mapInput
    connect?: jobWhereUniqueInput
  }

  export type job_salaryCreateNestedOneWithoutJob_salary_mapInput = {
    create?: XOR<job_salaryCreateWithoutJob_salary_mapInput, job_salaryUncheckedCreateWithoutJob_salary_mapInput>
    connectOrCreate?: job_salaryCreateOrConnectWithoutJob_salary_mapInput
    connect?: job_salaryWhereUniqueInput
  }

  export type jobUpdateOneRequiredWithoutJob_salary_mapNestedInput = {
    create?: XOR<jobCreateWithoutJob_salary_mapInput, jobUncheckedCreateWithoutJob_salary_mapInput>
    connectOrCreate?: jobCreateOrConnectWithoutJob_salary_mapInput
    upsert?: jobUpsertWithoutJob_salary_mapInput
    connect?: jobWhereUniqueInput
    update?: XOR<XOR<jobUpdateToOneWithWhereWithoutJob_salary_mapInput, jobUpdateWithoutJob_salary_mapInput>, jobUncheckedUpdateWithoutJob_salary_mapInput>
  }

  export type job_salaryUpdateOneRequiredWithoutJob_salary_mapNestedInput = {
    create?: XOR<job_salaryCreateWithoutJob_salary_mapInput, job_salaryUncheckedCreateWithoutJob_salary_mapInput>
    connectOrCreate?: job_salaryCreateOrConnectWithoutJob_salary_mapInput
    upsert?: job_salaryUpsertWithoutJob_salary_mapInput
    connect?: job_salaryWhereUniqueInput
    update?: XOR<XOR<job_salaryUpdateToOneWithWhereWithoutJob_salary_mapInput, job_salaryUpdateWithoutJob_salary_mapInput>, job_salaryUncheckedUpdateWithoutJob_salary_mapInput>
  }

  export type job_schedule_mapCreateNestedManyWithoutJob_scheduleInput = {
    create?: XOR<job_schedule_mapCreateWithoutJob_scheduleInput, job_schedule_mapUncheckedCreateWithoutJob_scheduleInput> | job_schedule_mapCreateWithoutJob_scheduleInput[] | job_schedule_mapUncheckedCreateWithoutJob_scheduleInput[]
    connectOrCreate?: job_schedule_mapCreateOrConnectWithoutJob_scheduleInput | job_schedule_mapCreateOrConnectWithoutJob_scheduleInput[]
    createMany?: job_schedule_mapCreateManyJob_scheduleInputEnvelope
    connect?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
  }

  export type job_schedule_mapUncheckedCreateNestedManyWithoutJob_scheduleInput = {
    create?: XOR<job_schedule_mapCreateWithoutJob_scheduleInput, job_schedule_mapUncheckedCreateWithoutJob_scheduleInput> | job_schedule_mapCreateWithoutJob_scheduleInput[] | job_schedule_mapUncheckedCreateWithoutJob_scheduleInput[]
    connectOrCreate?: job_schedule_mapCreateOrConnectWithoutJob_scheduleInput | job_schedule_mapCreateOrConnectWithoutJob_scheduleInput[]
    createMany?: job_schedule_mapCreateManyJob_scheduleInputEnvelope
    connect?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
  }

  export type job_schedule_mapUpdateManyWithoutJob_scheduleNestedInput = {
    create?: XOR<job_schedule_mapCreateWithoutJob_scheduleInput, job_schedule_mapUncheckedCreateWithoutJob_scheduleInput> | job_schedule_mapCreateWithoutJob_scheduleInput[] | job_schedule_mapUncheckedCreateWithoutJob_scheduleInput[]
    connectOrCreate?: job_schedule_mapCreateOrConnectWithoutJob_scheduleInput | job_schedule_mapCreateOrConnectWithoutJob_scheduleInput[]
    upsert?: job_schedule_mapUpsertWithWhereUniqueWithoutJob_scheduleInput | job_schedule_mapUpsertWithWhereUniqueWithoutJob_scheduleInput[]
    createMany?: job_schedule_mapCreateManyJob_scheduleInputEnvelope
    set?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
    disconnect?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
    delete?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
    connect?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
    update?: job_schedule_mapUpdateWithWhereUniqueWithoutJob_scheduleInput | job_schedule_mapUpdateWithWhereUniqueWithoutJob_scheduleInput[]
    updateMany?: job_schedule_mapUpdateManyWithWhereWithoutJob_scheduleInput | job_schedule_mapUpdateManyWithWhereWithoutJob_scheduleInput[]
    deleteMany?: job_schedule_mapScalarWhereInput | job_schedule_mapScalarWhereInput[]
  }

  export type job_schedule_mapUncheckedUpdateManyWithoutJob_scheduleNestedInput = {
    create?: XOR<job_schedule_mapCreateWithoutJob_scheduleInput, job_schedule_mapUncheckedCreateWithoutJob_scheduleInput> | job_schedule_mapCreateWithoutJob_scheduleInput[] | job_schedule_mapUncheckedCreateWithoutJob_scheduleInput[]
    connectOrCreate?: job_schedule_mapCreateOrConnectWithoutJob_scheduleInput | job_schedule_mapCreateOrConnectWithoutJob_scheduleInput[]
    upsert?: job_schedule_mapUpsertWithWhereUniqueWithoutJob_scheduleInput | job_schedule_mapUpsertWithWhereUniqueWithoutJob_scheduleInput[]
    createMany?: job_schedule_mapCreateManyJob_scheduleInputEnvelope
    set?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
    disconnect?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
    delete?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
    connect?: job_schedule_mapWhereUniqueInput | job_schedule_mapWhereUniqueInput[]
    update?: job_schedule_mapUpdateWithWhereUniqueWithoutJob_scheduleInput | job_schedule_mapUpdateWithWhereUniqueWithoutJob_scheduleInput[]
    updateMany?: job_schedule_mapUpdateManyWithWhereWithoutJob_scheduleInput | job_schedule_mapUpdateManyWithWhereWithoutJob_scheduleInput[]
    deleteMany?: job_schedule_mapScalarWhereInput | job_schedule_mapScalarWhereInput[]
  }

  export type jobCreateNestedOneWithoutJob_schedule_mapInput = {
    create?: XOR<jobCreateWithoutJob_schedule_mapInput, jobUncheckedCreateWithoutJob_schedule_mapInput>
    connectOrCreate?: jobCreateOrConnectWithoutJob_schedule_mapInput
    connect?: jobWhereUniqueInput
  }

  export type job_scheduleCreateNestedOneWithoutJob_schedule_mapInput = {
    create?: XOR<job_scheduleCreateWithoutJob_schedule_mapInput, job_scheduleUncheckedCreateWithoutJob_schedule_mapInput>
    connectOrCreate?: job_scheduleCreateOrConnectWithoutJob_schedule_mapInput
    connect?: job_scheduleWhereUniqueInput
  }

  export type jobUpdateOneRequiredWithoutJob_schedule_mapNestedInput = {
    create?: XOR<jobCreateWithoutJob_schedule_mapInput, jobUncheckedCreateWithoutJob_schedule_mapInput>
    connectOrCreate?: jobCreateOrConnectWithoutJob_schedule_mapInput
    upsert?: jobUpsertWithoutJob_schedule_mapInput
    connect?: jobWhereUniqueInput
    update?: XOR<XOR<jobUpdateToOneWithWhereWithoutJob_schedule_mapInput, jobUpdateWithoutJob_schedule_mapInput>, jobUncheckedUpdateWithoutJob_schedule_mapInput>
  }

  export type job_scheduleUpdateOneRequiredWithoutJob_schedule_mapNestedInput = {
    create?: XOR<job_scheduleCreateWithoutJob_schedule_mapInput, job_scheduleUncheckedCreateWithoutJob_schedule_mapInput>
    connectOrCreate?: job_scheduleCreateOrConnectWithoutJob_schedule_mapInput
    upsert?: job_scheduleUpsertWithoutJob_schedule_mapInput
    connect?: job_scheduleWhereUniqueInput
    update?: XOR<XOR<job_scheduleUpdateToOneWithWhereWithoutJob_schedule_mapInput, job_scheduleUpdateWithoutJob_schedule_mapInput>, job_scheduleUncheckedUpdateWithoutJob_schedule_mapInput>
  }

  export type job_skill_mapCreateNestedManyWithoutJob_skillInput = {
    create?: XOR<job_skill_mapCreateWithoutJob_skillInput, job_skill_mapUncheckedCreateWithoutJob_skillInput> | job_skill_mapCreateWithoutJob_skillInput[] | job_skill_mapUncheckedCreateWithoutJob_skillInput[]
    connectOrCreate?: job_skill_mapCreateOrConnectWithoutJob_skillInput | job_skill_mapCreateOrConnectWithoutJob_skillInput[]
    createMany?: job_skill_mapCreateManyJob_skillInputEnvelope
    connect?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
  }

  export type job_skill_mapUncheckedCreateNestedManyWithoutJob_skillInput = {
    create?: XOR<job_skill_mapCreateWithoutJob_skillInput, job_skill_mapUncheckedCreateWithoutJob_skillInput> | job_skill_mapCreateWithoutJob_skillInput[] | job_skill_mapUncheckedCreateWithoutJob_skillInput[]
    connectOrCreate?: job_skill_mapCreateOrConnectWithoutJob_skillInput | job_skill_mapCreateOrConnectWithoutJob_skillInput[]
    createMany?: job_skill_mapCreateManyJob_skillInputEnvelope
    connect?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
  }

  export type job_skill_mapUpdateManyWithoutJob_skillNestedInput = {
    create?: XOR<job_skill_mapCreateWithoutJob_skillInput, job_skill_mapUncheckedCreateWithoutJob_skillInput> | job_skill_mapCreateWithoutJob_skillInput[] | job_skill_mapUncheckedCreateWithoutJob_skillInput[]
    connectOrCreate?: job_skill_mapCreateOrConnectWithoutJob_skillInput | job_skill_mapCreateOrConnectWithoutJob_skillInput[]
    upsert?: job_skill_mapUpsertWithWhereUniqueWithoutJob_skillInput | job_skill_mapUpsertWithWhereUniqueWithoutJob_skillInput[]
    createMany?: job_skill_mapCreateManyJob_skillInputEnvelope
    set?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
    disconnect?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
    delete?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
    connect?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
    update?: job_skill_mapUpdateWithWhereUniqueWithoutJob_skillInput | job_skill_mapUpdateWithWhereUniqueWithoutJob_skillInput[]
    updateMany?: job_skill_mapUpdateManyWithWhereWithoutJob_skillInput | job_skill_mapUpdateManyWithWhereWithoutJob_skillInput[]
    deleteMany?: job_skill_mapScalarWhereInput | job_skill_mapScalarWhereInput[]
  }

  export type job_skill_mapUncheckedUpdateManyWithoutJob_skillNestedInput = {
    create?: XOR<job_skill_mapCreateWithoutJob_skillInput, job_skill_mapUncheckedCreateWithoutJob_skillInput> | job_skill_mapCreateWithoutJob_skillInput[] | job_skill_mapUncheckedCreateWithoutJob_skillInput[]
    connectOrCreate?: job_skill_mapCreateOrConnectWithoutJob_skillInput | job_skill_mapCreateOrConnectWithoutJob_skillInput[]
    upsert?: job_skill_mapUpsertWithWhereUniqueWithoutJob_skillInput | job_skill_mapUpsertWithWhereUniqueWithoutJob_skillInput[]
    createMany?: job_skill_mapCreateManyJob_skillInputEnvelope
    set?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
    disconnect?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
    delete?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
    connect?: job_skill_mapWhereUniqueInput | job_skill_mapWhereUniqueInput[]
    update?: job_skill_mapUpdateWithWhereUniqueWithoutJob_skillInput | job_skill_mapUpdateWithWhereUniqueWithoutJob_skillInput[]
    updateMany?: job_skill_mapUpdateManyWithWhereWithoutJob_skillInput | job_skill_mapUpdateManyWithWhereWithoutJob_skillInput[]
    deleteMany?: job_skill_mapScalarWhereInput | job_skill_mapScalarWhereInput[]
  }

  export type jobCreateNestedOneWithoutJob_skill_mapInput = {
    create?: XOR<jobCreateWithoutJob_skill_mapInput, jobUncheckedCreateWithoutJob_skill_mapInput>
    connectOrCreate?: jobCreateOrConnectWithoutJob_skill_mapInput
    connect?: jobWhereUniqueInput
  }

  export type job_skillCreateNestedOneWithoutJob_skill_mapInput = {
    create?: XOR<job_skillCreateWithoutJob_skill_mapInput, job_skillUncheckedCreateWithoutJob_skill_mapInput>
    connectOrCreate?: job_skillCreateOrConnectWithoutJob_skill_mapInput
    connect?: job_skillWhereUniqueInput
  }

  export type jobUpdateOneRequiredWithoutJob_skill_mapNestedInput = {
    create?: XOR<jobCreateWithoutJob_skill_mapInput, jobUncheckedCreateWithoutJob_skill_mapInput>
    connectOrCreate?: jobCreateOrConnectWithoutJob_skill_mapInput
    upsert?: jobUpsertWithoutJob_skill_mapInput
    connect?: jobWhereUniqueInput
    update?: XOR<XOR<jobUpdateToOneWithWhereWithoutJob_skill_mapInput, jobUpdateWithoutJob_skill_mapInput>, jobUncheckedUpdateWithoutJob_skill_mapInput>
  }

  export type job_skillUpdateOneRequiredWithoutJob_skill_mapNestedInput = {
    create?: XOR<job_skillCreateWithoutJob_skill_mapInput, job_skillUncheckedCreateWithoutJob_skill_mapInput>
    connectOrCreate?: job_skillCreateOrConnectWithoutJob_skill_mapInput
    upsert?: job_skillUpsertWithoutJob_skill_mapInput
    connect?: job_skillWhereUniqueInput
    update?: XOR<XOR<job_skillUpdateToOneWithWhereWithoutJob_skill_mapInput, job_skillUpdateWithoutJob_skill_mapInput>, job_skillUncheckedUpdateWithoutJob_skill_mapInput>
  }

  export type job_source_mapCreateNestedManyWithoutJob_sourceInput = {
    create?: XOR<job_source_mapCreateWithoutJob_sourceInput, job_source_mapUncheckedCreateWithoutJob_sourceInput> | job_source_mapCreateWithoutJob_sourceInput[] | job_source_mapUncheckedCreateWithoutJob_sourceInput[]
    connectOrCreate?: job_source_mapCreateOrConnectWithoutJob_sourceInput | job_source_mapCreateOrConnectWithoutJob_sourceInput[]
    createMany?: job_source_mapCreateManyJob_sourceInputEnvelope
    connect?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
  }

  export type job_source_mapUncheckedCreateNestedManyWithoutJob_sourceInput = {
    create?: XOR<job_source_mapCreateWithoutJob_sourceInput, job_source_mapUncheckedCreateWithoutJob_sourceInput> | job_source_mapCreateWithoutJob_sourceInput[] | job_source_mapUncheckedCreateWithoutJob_sourceInput[]
    connectOrCreate?: job_source_mapCreateOrConnectWithoutJob_sourceInput | job_source_mapCreateOrConnectWithoutJob_sourceInput[]
    createMany?: job_source_mapCreateManyJob_sourceInputEnvelope
    connect?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
  }

  export type job_source_mapUpdateManyWithoutJob_sourceNestedInput = {
    create?: XOR<job_source_mapCreateWithoutJob_sourceInput, job_source_mapUncheckedCreateWithoutJob_sourceInput> | job_source_mapCreateWithoutJob_sourceInput[] | job_source_mapUncheckedCreateWithoutJob_sourceInput[]
    connectOrCreate?: job_source_mapCreateOrConnectWithoutJob_sourceInput | job_source_mapCreateOrConnectWithoutJob_sourceInput[]
    upsert?: job_source_mapUpsertWithWhereUniqueWithoutJob_sourceInput | job_source_mapUpsertWithWhereUniqueWithoutJob_sourceInput[]
    createMany?: job_source_mapCreateManyJob_sourceInputEnvelope
    set?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
    disconnect?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
    delete?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
    connect?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
    update?: job_source_mapUpdateWithWhereUniqueWithoutJob_sourceInput | job_source_mapUpdateWithWhereUniqueWithoutJob_sourceInput[]
    updateMany?: job_source_mapUpdateManyWithWhereWithoutJob_sourceInput | job_source_mapUpdateManyWithWhereWithoutJob_sourceInput[]
    deleteMany?: job_source_mapScalarWhereInput | job_source_mapScalarWhereInput[]
  }

  export type job_source_mapUncheckedUpdateManyWithoutJob_sourceNestedInput = {
    create?: XOR<job_source_mapCreateWithoutJob_sourceInput, job_source_mapUncheckedCreateWithoutJob_sourceInput> | job_source_mapCreateWithoutJob_sourceInput[] | job_source_mapUncheckedCreateWithoutJob_sourceInput[]
    connectOrCreate?: job_source_mapCreateOrConnectWithoutJob_sourceInput | job_source_mapCreateOrConnectWithoutJob_sourceInput[]
    upsert?: job_source_mapUpsertWithWhereUniqueWithoutJob_sourceInput | job_source_mapUpsertWithWhereUniqueWithoutJob_sourceInput[]
    createMany?: job_source_mapCreateManyJob_sourceInputEnvelope
    set?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
    disconnect?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
    delete?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
    connect?: job_source_mapWhereUniqueInput | job_source_mapWhereUniqueInput[]
    update?: job_source_mapUpdateWithWhereUniqueWithoutJob_sourceInput | job_source_mapUpdateWithWhereUniqueWithoutJob_sourceInput[]
    updateMany?: job_source_mapUpdateManyWithWhereWithoutJob_sourceInput | job_source_mapUpdateManyWithWhereWithoutJob_sourceInput[]
    deleteMany?: job_source_mapScalarWhereInput | job_source_mapScalarWhereInput[]
  }

  export type jobCreateNestedOneWithoutJob_source_mapInput = {
    create?: XOR<jobCreateWithoutJob_source_mapInput, jobUncheckedCreateWithoutJob_source_mapInput>
    connectOrCreate?: jobCreateOrConnectWithoutJob_source_mapInput
    connect?: jobWhereUniqueInput
  }

  export type job_sourceCreateNestedOneWithoutJob_source_mapInput = {
    create?: XOR<job_sourceCreateWithoutJob_source_mapInput, job_sourceUncheckedCreateWithoutJob_source_mapInput>
    connectOrCreate?: job_sourceCreateOrConnectWithoutJob_source_mapInput
    connect?: job_sourceWhereUniqueInput
  }

  export type jobUpdateOneRequiredWithoutJob_source_mapNestedInput = {
    create?: XOR<jobCreateWithoutJob_source_mapInput, jobUncheckedCreateWithoutJob_source_mapInput>
    connectOrCreate?: jobCreateOrConnectWithoutJob_source_mapInput
    upsert?: jobUpsertWithoutJob_source_mapInput
    connect?: jobWhereUniqueInput
    update?: XOR<XOR<jobUpdateToOneWithWhereWithoutJob_source_mapInput, jobUpdateWithoutJob_source_mapInput>, jobUncheckedUpdateWithoutJob_source_mapInput>
  }

  export type job_sourceUpdateOneRequiredWithoutJob_source_mapNestedInput = {
    create?: XOR<job_sourceCreateWithoutJob_source_mapInput, job_sourceUncheckedCreateWithoutJob_source_mapInput>
    connectOrCreate?: job_sourceCreateOrConnectWithoutJob_source_mapInput
    upsert?: job_sourceUpsertWithoutJob_source_mapInput
    connect?: job_sourceWhereUniqueInput
    update?: XOR<XOR<job_sourceUpdateToOneWithWhereWithoutJob_source_mapInput, job_sourceUpdateWithoutJob_source_mapInput>, job_sourceUncheckedUpdateWithoutJob_source_mapInput>
  }

  export type job_type_mapCreateNestedManyWithoutJob_typeInput = {
    create?: XOR<job_type_mapCreateWithoutJob_typeInput, job_type_mapUncheckedCreateWithoutJob_typeInput> | job_type_mapCreateWithoutJob_typeInput[] | job_type_mapUncheckedCreateWithoutJob_typeInput[]
    connectOrCreate?: job_type_mapCreateOrConnectWithoutJob_typeInput | job_type_mapCreateOrConnectWithoutJob_typeInput[]
    createMany?: job_type_mapCreateManyJob_typeInputEnvelope
    connect?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
  }

  export type job_type_mapUncheckedCreateNestedManyWithoutJob_typeInput = {
    create?: XOR<job_type_mapCreateWithoutJob_typeInput, job_type_mapUncheckedCreateWithoutJob_typeInput> | job_type_mapCreateWithoutJob_typeInput[] | job_type_mapUncheckedCreateWithoutJob_typeInput[]
    connectOrCreate?: job_type_mapCreateOrConnectWithoutJob_typeInput | job_type_mapCreateOrConnectWithoutJob_typeInput[]
    createMany?: job_type_mapCreateManyJob_typeInputEnvelope
    connect?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
  }

  export type job_type_mapUpdateManyWithoutJob_typeNestedInput = {
    create?: XOR<job_type_mapCreateWithoutJob_typeInput, job_type_mapUncheckedCreateWithoutJob_typeInput> | job_type_mapCreateWithoutJob_typeInput[] | job_type_mapUncheckedCreateWithoutJob_typeInput[]
    connectOrCreate?: job_type_mapCreateOrConnectWithoutJob_typeInput | job_type_mapCreateOrConnectWithoutJob_typeInput[]
    upsert?: job_type_mapUpsertWithWhereUniqueWithoutJob_typeInput | job_type_mapUpsertWithWhereUniqueWithoutJob_typeInput[]
    createMany?: job_type_mapCreateManyJob_typeInputEnvelope
    set?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
    disconnect?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
    delete?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
    connect?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
    update?: job_type_mapUpdateWithWhereUniqueWithoutJob_typeInput | job_type_mapUpdateWithWhereUniqueWithoutJob_typeInput[]
    updateMany?: job_type_mapUpdateManyWithWhereWithoutJob_typeInput | job_type_mapUpdateManyWithWhereWithoutJob_typeInput[]
    deleteMany?: job_type_mapScalarWhereInput | job_type_mapScalarWhereInput[]
  }

  export type job_type_mapUncheckedUpdateManyWithoutJob_typeNestedInput = {
    create?: XOR<job_type_mapCreateWithoutJob_typeInput, job_type_mapUncheckedCreateWithoutJob_typeInput> | job_type_mapCreateWithoutJob_typeInput[] | job_type_mapUncheckedCreateWithoutJob_typeInput[]
    connectOrCreate?: job_type_mapCreateOrConnectWithoutJob_typeInput | job_type_mapCreateOrConnectWithoutJob_typeInput[]
    upsert?: job_type_mapUpsertWithWhereUniqueWithoutJob_typeInput | job_type_mapUpsertWithWhereUniqueWithoutJob_typeInput[]
    createMany?: job_type_mapCreateManyJob_typeInputEnvelope
    set?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
    disconnect?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
    delete?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
    connect?: job_type_mapWhereUniqueInput | job_type_mapWhereUniqueInput[]
    update?: job_type_mapUpdateWithWhereUniqueWithoutJob_typeInput | job_type_mapUpdateWithWhereUniqueWithoutJob_typeInput[]
    updateMany?: job_type_mapUpdateManyWithWhereWithoutJob_typeInput | job_type_mapUpdateManyWithWhereWithoutJob_typeInput[]
    deleteMany?: job_type_mapScalarWhereInput | job_type_mapScalarWhereInput[]
  }

  export type jobCreateNestedOneWithoutJob_type_mapInput = {
    create?: XOR<jobCreateWithoutJob_type_mapInput, jobUncheckedCreateWithoutJob_type_mapInput>
    connectOrCreate?: jobCreateOrConnectWithoutJob_type_mapInput
    connect?: jobWhereUniqueInput
  }

  export type job_typeCreateNestedOneWithoutJob_type_mapInput = {
    create?: XOR<job_typeCreateWithoutJob_type_mapInput, job_typeUncheckedCreateWithoutJob_type_mapInput>
    connectOrCreate?: job_typeCreateOrConnectWithoutJob_type_mapInput
    connect?: job_typeWhereUniqueInput
  }

  export type jobUpdateOneRequiredWithoutJob_type_mapNestedInput = {
    create?: XOR<jobCreateWithoutJob_type_mapInput, jobUncheckedCreateWithoutJob_type_mapInput>
    connectOrCreate?: jobCreateOrConnectWithoutJob_type_mapInput
    upsert?: jobUpsertWithoutJob_type_mapInput
    connect?: jobWhereUniqueInput
    update?: XOR<XOR<jobUpdateToOneWithWhereWithoutJob_type_mapInput, jobUpdateWithoutJob_type_mapInput>, jobUncheckedUpdateWithoutJob_type_mapInput>
  }

  export type job_typeUpdateOneRequiredWithoutJob_type_mapNestedInput = {
    create?: XOR<job_typeCreateWithoutJob_type_mapInput, job_typeUncheckedCreateWithoutJob_type_mapInput>
    connectOrCreate?: job_typeCreateOrConnectWithoutJob_type_mapInput
    upsert?: job_typeUpsertWithoutJob_type_mapInput
    connect?: job_typeWhereUniqueInput
    update?: XOR<XOR<job_typeUpdateToOneWithWhereWithoutJob_type_mapInput, job_typeUpdateWithoutJob_type_mapInput>, job_typeUncheckedUpdateWithoutJob_type_mapInput>
  }

  export type companyCreateNestedManyWithoutCityInput = {
    create?: XOR<companyCreateWithoutCityInput, companyUncheckedCreateWithoutCityInput> | companyCreateWithoutCityInput[] | companyUncheckedCreateWithoutCityInput[]
    connectOrCreate?: companyCreateOrConnectWithoutCityInput | companyCreateOrConnectWithoutCityInput[]
    createMany?: companyCreateManyCityInputEnvelope
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
  }

  export type jobCreateNestedManyWithoutCityInput = {
    create?: XOR<jobCreateWithoutCityInput, jobUncheckedCreateWithoutCityInput> | jobCreateWithoutCityInput[] | jobUncheckedCreateWithoutCityInput[]
    connectOrCreate?: jobCreateOrConnectWithoutCityInput | jobCreateOrConnectWithoutCityInput[]
    createMany?: jobCreateManyCityInputEnvelope
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
  }

  export type stateCreateNestedOneWithoutCityInput = {
    create?: XOR<stateCreateWithoutCityInput, stateUncheckedCreateWithoutCityInput>
    connectOrCreate?: stateCreateOrConnectWithoutCityInput
    connect?: stateWhereUniqueInput
  }

  export type companyUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<companyCreateWithoutCityInput, companyUncheckedCreateWithoutCityInput> | companyCreateWithoutCityInput[] | companyUncheckedCreateWithoutCityInput[]
    connectOrCreate?: companyCreateOrConnectWithoutCityInput | companyCreateOrConnectWithoutCityInput[]
    createMany?: companyCreateManyCityInputEnvelope
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
  }

  export type jobUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<jobCreateWithoutCityInput, jobUncheckedCreateWithoutCityInput> | jobCreateWithoutCityInput[] | jobUncheckedCreateWithoutCityInput[]
    connectOrCreate?: jobCreateOrConnectWithoutCityInput | jobCreateOrConnectWithoutCityInput[]
    createMany?: jobCreateManyCityInputEnvelope
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
  }

  export type companyUpdateManyWithoutCityNestedInput = {
    create?: XOR<companyCreateWithoutCityInput, companyUncheckedCreateWithoutCityInput> | companyCreateWithoutCityInput[] | companyUncheckedCreateWithoutCityInput[]
    connectOrCreate?: companyCreateOrConnectWithoutCityInput | companyCreateOrConnectWithoutCityInput[]
    upsert?: companyUpsertWithWhereUniqueWithoutCityInput | companyUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: companyCreateManyCityInputEnvelope
    set?: companyWhereUniqueInput | companyWhereUniqueInput[]
    disconnect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    delete?: companyWhereUniqueInput | companyWhereUniqueInput[]
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    update?: companyUpdateWithWhereUniqueWithoutCityInput | companyUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: companyUpdateManyWithWhereWithoutCityInput | companyUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: companyScalarWhereInput | companyScalarWhereInput[]
  }

  export type jobUpdateManyWithoutCityNestedInput = {
    create?: XOR<jobCreateWithoutCityInput, jobUncheckedCreateWithoutCityInput> | jobCreateWithoutCityInput[] | jobUncheckedCreateWithoutCityInput[]
    connectOrCreate?: jobCreateOrConnectWithoutCityInput | jobCreateOrConnectWithoutCityInput[]
    upsert?: jobUpsertWithWhereUniqueWithoutCityInput | jobUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: jobCreateManyCityInputEnvelope
    set?: jobWhereUniqueInput | jobWhereUniqueInput[]
    disconnect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    delete?: jobWhereUniqueInput | jobWhereUniqueInput[]
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    update?: jobUpdateWithWhereUniqueWithoutCityInput | jobUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: jobUpdateManyWithWhereWithoutCityInput | jobUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: jobScalarWhereInput | jobScalarWhereInput[]
  }

  export type stateUpdateOneRequiredWithoutCityNestedInput = {
    create?: XOR<stateCreateWithoutCityInput, stateUncheckedCreateWithoutCityInput>
    connectOrCreate?: stateCreateOrConnectWithoutCityInput
    upsert?: stateUpsertWithoutCityInput
    connect?: stateWhereUniqueInput
    update?: XOR<XOR<stateUpdateToOneWithWhereWithoutCityInput, stateUpdateWithoutCityInput>, stateUncheckedUpdateWithoutCityInput>
  }

  export type companyUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<companyCreateWithoutCityInput, companyUncheckedCreateWithoutCityInput> | companyCreateWithoutCityInput[] | companyUncheckedCreateWithoutCityInput[]
    connectOrCreate?: companyCreateOrConnectWithoutCityInput | companyCreateOrConnectWithoutCityInput[]
    upsert?: companyUpsertWithWhereUniqueWithoutCityInput | companyUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: companyCreateManyCityInputEnvelope
    set?: companyWhereUniqueInput | companyWhereUniqueInput[]
    disconnect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    delete?: companyWhereUniqueInput | companyWhereUniqueInput[]
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    update?: companyUpdateWithWhereUniqueWithoutCityInput | companyUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: companyUpdateManyWithWhereWithoutCityInput | companyUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: companyScalarWhereInput | companyScalarWhereInput[]
  }

  export type jobUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<jobCreateWithoutCityInput, jobUncheckedCreateWithoutCityInput> | jobCreateWithoutCityInput[] | jobUncheckedCreateWithoutCityInput[]
    connectOrCreate?: jobCreateOrConnectWithoutCityInput | jobCreateOrConnectWithoutCityInput[]
    upsert?: jobUpsertWithWhereUniqueWithoutCityInput | jobUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: jobCreateManyCityInputEnvelope
    set?: jobWhereUniqueInput | jobWhereUniqueInput[]
    disconnect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    delete?: jobWhereUniqueInput | jobWhereUniqueInput[]
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    update?: jobUpdateWithWhereUniqueWithoutCityInput | jobUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: jobUpdateManyWithWhereWithoutCityInput | jobUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: jobScalarWhereInput | jobScalarWhereInput[]
  }

  export type companyCreateNestedManyWithoutCountryInput = {
    create?: XOR<companyCreateWithoutCountryInput, companyUncheckedCreateWithoutCountryInput> | companyCreateWithoutCountryInput[] | companyUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: companyCreateOrConnectWithoutCountryInput | companyCreateOrConnectWithoutCountryInput[]
    createMany?: companyCreateManyCountryInputEnvelope
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
  }

  export type jobCreateNestedManyWithoutCountryInput = {
    create?: XOR<jobCreateWithoutCountryInput, jobUncheckedCreateWithoutCountryInput> | jobCreateWithoutCountryInput[] | jobUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: jobCreateOrConnectWithoutCountryInput | jobCreateOrConnectWithoutCountryInput[]
    createMany?: jobCreateManyCountryInputEnvelope
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
  }

  export type stateCreateNestedManyWithoutCountryInput = {
    create?: XOR<stateCreateWithoutCountryInput, stateUncheckedCreateWithoutCountryInput> | stateCreateWithoutCountryInput[] | stateUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: stateCreateOrConnectWithoutCountryInput | stateCreateOrConnectWithoutCountryInput[]
    createMany?: stateCreateManyCountryInputEnvelope
    connect?: stateWhereUniqueInput | stateWhereUniqueInput[]
  }

  export type companyUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<companyCreateWithoutCountryInput, companyUncheckedCreateWithoutCountryInput> | companyCreateWithoutCountryInput[] | companyUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: companyCreateOrConnectWithoutCountryInput | companyCreateOrConnectWithoutCountryInput[]
    createMany?: companyCreateManyCountryInputEnvelope
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
  }

  export type jobUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<jobCreateWithoutCountryInput, jobUncheckedCreateWithoutCountryInput> | jobCreateWithoutCountryInput[] | jobUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: jobCreateOrConnectWithoutCountryInput | jobCreateOrConnectWithoutCountryInput[]
    createMany?: jobCreateManyCountryInputEnvelope
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
  }

  export type stateUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<stateCreateWithoutCountryInput, stateUncheckedCreateWithoutCountryInput> | stateCreateWithoutCountryInput[] | stateUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: stateCreateOrConnectWithoutCountryInput | stateCreateOrConnectWithoutCountryInput[]
    createMany?: stateCreateManyCountryInputEnvelope
    connect?: stateWhereUniqueInput | stateWhereUniqueInput[]
  }

  export type companyUpdateManyWithoutCountryNestedInput = {
    create?: XOR<companyCreateWithoutCountryInput, companyUncheckedCreateWithoutCountryInput> | companyCreateWithoutCountryInput[] | companyUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: companyCreateOrConnectWithoutCountryInput | companyCreateOrConnectWithoutCountryInput[]
    upsert?: companyUpsertWithWhereUniqueWithoutCountryInput | companyUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: companyCreateManyCountryInputEnvelope
    set?: companyWhereUniqueInput | companyWhereUniqueInput[]
    disconnect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    delete?: companyWhereUniqueInput | companyWhereUniqueInput[]
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    update?: companyUpdateWithWhereUniqueWithoutCountryInput | companyUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: companyUpdateManyWithWhereWithoutCountryInput | companyUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: companyScalarWhereInput | companyScalarWhereInput[]
  }

  export type jobUpdateManyWithoutCountryNestedInput = {
    create?: XOR<jobCreateWithoutCountryInput, jobUncheckedCreateWithoutCountryInput> | jobCreateWithoutCountryInput[] | jobUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: jobCreateOrConnectWithoutCountryInput | jobCreateOrConnectWithoutCountryInput[]
    upsert?: jobUpsertWithWhereUniqueWithoutCountryInput | jobUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: jobCreateManyCountryInputEnvelope
    set?: jobWhereUniqueInput | jobWhereUniqueInput[]
    disconnect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    delete?: jobWhereUniqueInput | jobWhereUniqueInput[]
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    update?: jobUpdateWithWhereUniqueWithoutCountryInput | jobUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: jobUpdateManyWithWhereWithoutCountryInput | jobUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: jobScalarWhereInput | jobScalarWhereInput[]
  }

  export type stateUpdateManyWithoutCountryNestedInput = {
    create?: XOR<stateCreateWithoutCountryInput, stateUncheckedCreateWithoutCountryInput> | stateCreateWithoutCountryInput[] | stateUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: stateCreateOrConnectWithoutCountryInput | stateCreateOrConnectWithoutCountryInput[]
    upsert?: stateUpsertWithWhereUniqueWithoutCountryInput | stateUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: stateCreateManyCountryInputEnvelope
    set?: stateWhereUniqueInput | stateWhereUniqueInput[]
    disconnect?: stateWhereUniqueInput | stateWhereUniqueInput[]
    delete?: stateWhereUniqueInput | stateWhereUniqueInput[]
    connect?: stateWhereUniqueInput | stateWhereUniqueInput[]
    update?: stateUpdateWithWhereUniqueWithoutCountryInput | stateUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: stateUpdateManyWithWhereWithoutCountryInput | stateUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: stateScalarWhereInput | stateScalarWhereInput[]
  }

  export type companyUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<companyCreateWithoutCountryInput, companyUncheckedCreateWithoutCountryInput> | companyCreateWithoutCountryInput[] | companyUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: companyCreateOrConnectWithoutCountryInput | companyCreateOrConnectWithoutCountryInput[]
    upsert?: companyUpsertWithWhereUniqueWithoutCountryInput | companyUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: companyCreateManyCountryInputEnvelope
    set?: companyWhereUniqueInput | companyWhereUniqueInput[]
    disconnect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    delete?: companyWhereUniqueInput | companyWhereUniqueInput[]
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    update?: companyUpdateWithWhereUniqueWithoutCountryInput | companyUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: companyUpdateManyWithWhereWithoutCountryInput | companyUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: companyScalarWhereInput | companyScalarWhereInput[]
  }

  export type jobUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<jobCreateWithoutCountryInput, jobUncheckedCreateWithoutCountryInput> | jobCreateWithoutCountryInput[] | jobUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: jobCreateOrConnectWithoutCountryInput | jobCreateOrConnectWithoutCountryInput[]
    upsert?: jobUpsertWithWhereUniqueWithoutCountryInput | jobUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: jobCreateManyCountryInputEnvelope
    set?: jobWhereUniqueInput | jobWhereUniqueInput[]
    disconnect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    delete?: jobWhereUniqueInput | jobWhereUniqueInput[]
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    update?: jobUpdateWithWhereUniqueWithoutCountryInput | jobUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: jobUpdateManyWithWhereWithoutCountryInput | jobUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: jobScalarWhereInput | jobScalarWhereInput[]
  }

  export type stateUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<stateCreateWithoutCountryInput, stateUncheckedCreateWithoutCountryInput> | stateCreateWithoutCountryInput[] | stateUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: stateCreateOrConnectWithoutCountryInput | stateCreateOrConnectWithoutCountryInput[]
    upsert?: stateUpsertWithWhereUniqueWithoutCountryInput | stateUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: stateCreateManyCountryInputEnvelope
    set?: stateWhereUniqueInput | stateWhereUniqueInput[]
    disconnect?: stateWhereUniqueInput | stateWhereUniqueInput[]
    delete?: stateWhereUniqueInput | stateWhereUniqueInput[]
    connect?: stateWhereUniqueInput | stateWhereUniqueInput[]
    update?: stateUpdateWithWhereUniqueWithoutCountryInput | stateUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: stateUpdateManyWithWhereWithoutCountryInput | stateUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: stateScalarWhereInput | stateScalarWhereInput[]
  }

  export type companyCreateNestedManyWithoutStateInput = {
    create?: XOR<companyCreateWithoutStateInput, companyUncheckedCreateWithoutStateInput> | companyCreateWithoutStateInput[] | companyUncheckedCreateWithoutStateInput[]
    connectOrCreate?: companyCreateOrConnectWithoutStateInput | companyCreateOrConnectWithoutStateInput[]
    createMany?: companyCreateManyStateInputEnvelope
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
  }

  export type jobCreateNestedManyWithoutStateInput = {
    create?: XOR<jobCreateWithoutStateInput, jobUncheckedCreateWithoutStateInput> | jobCreateWithoutStateInput[] | jobUncheckedCreateWithoutStateInput[]
    connectOrCreate?: jobCreateOrConnectWithoutStateInput | jobCreateOrConnectWithoutStateInput[]
    createMany?: jobCreateManyStateInputEnvelope
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
  }

  export type cityCreateNestedManyWithoutStateInput = {
    create?: XOR<cityCreateWithoutStateInput, cityUncheckedCreateWithoutStateInput> | cityCreateWithoutStateInput[] | cityUncheckedCreateWithoutStateInput[]
    connectOrCreate?: cityCreateOrConnectWithoutStateInput | cityCreateOrConnectWithoutStateInput[]
    createMany?: cityCreateManyStateInputEnvelope
    connect?: cityWhereUniqueInput | cityWhereUniqueInput[]
  }

  export type countryCreateNestedOneWithoutStateInput = {
    create?: XOR<countryCreateWithoutStateInput, countryUncheckedCreateWithoutStateInput>
    connectOrCreate?: countryCreateOrConnectWithoutStateInput
    connect?: countryWhereUniqueInput
  }

  export type companyUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<companyCreateWithoutStateInput, companyUncheckedCreateWithoutStateInput> | companyCreateWithoutStateInput[] | companyUncheckedCreateWithoutStateInput[]
    connectOrCreate?: companyCreateOrConnectWithoutStateInput | companyCreateOrConnectWithoutStateInput[]
    createMany?: companyCreateManyStateInputEnvelope
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
  }

  export type jobUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<jobCreateWithoutStateInput, jobUncheckedCreateWithoutStateInput> | jobCreateWithoutStateInput[] | jobUncheckedCreateWithoutStateInput[]
    connectOrCreate?: jobCreateOrConnectWithoutStateInput | jobCreateOrConnectWithoutStateInput[]
    createMany?: jobCreateManyStateInputEnvelope
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
  }

  export type cityUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<cityCreateWithoutStateInput, cityUncheckedCreateWithoutStateInput> | cityCreateWithoutStateInput[] | cityUncheckedCreateWithoutStateInput[]
    connectOrCreate?: cityCreateOrConnectWithoutStateInput | cityCreateOrConnectWithoutStateInput[]
    createMany?: cityCreateManyStateInputEnvelope
    connect?: cityWhereUniqueInput | cityWhereUniqueInput[]
  }

  export type companyUpdateManyWithoutStateNestedInput = {
    create?: XOR<companyCreateWithoutStateInput, companyUncheckedCreateWithoutStateInput> | companyCreateWithoutStateInput[] | companyUncheckedCreateWithoutStateInput[]
    connectOrCreate?: companyCreateOrConnectWithoutStateInput | companyCreateOrConnectWithoutStateInput[]
    upsert?: companyUpsertWithWhereUniqueWithoutStateInput | companyUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: companyCreateManyStateInputEnvelope
    set?: companyWhereUniqueInput | companyWhereUniqueInput[]
    disconnect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    delete?: companyWhereUniqueInput | companyWhereUniqueInput[]
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    update?: companyUpdateWithWhereUniqueWithoutStateInput | companyUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: companyUpdateManyWithWhereWithoutStateInput | companyUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: companyScalarWhereInput | companyScalarWhereInput[]
  }

  export type jobUpdateManyWithoutStateNestedInput = {
    create?: XOR<jobCreateWithoutStateInput, jobUncheckedCreateWithoutStateInput> | jobCreateWithoutStateInput[] | jobUncheckedCreateWithoutStateInput[]
    connectOrCreate?: jobCreateOrConnectWithoutStateInput | jobCreateOrConnectWithoutStateInput[]
    upsert?: jobUpsertWithWhereUniqueWithoutStateInput | jobUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: jobCreateManyStateInputEnvelope
    set?: jobWhereUniqueInput | jobWhereUniqueInput[]
    disconnect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    delete?: jobWhereUniqueInput | jobWhereUniqueInput[]
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    update?: jobUpdateWithWhereUniqueWithoutStateInput | jobUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: jobUpdateManyWithWhereWithoutStateInput | jobUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: jobScalarWhereInput | jobScalarWhereInput[]
  }

  export type cityUpdateManyWithoutStateNestedInput = {
    create?: XOR<cityCreateWithoutStateInput, cityUncheckedCreateWithoutStateInput> | cityCreateWithoutStateInput[] | cityUncheckedCreateWithoutStateInput[]
    connectOrCreate?: cityCreateOrConnectWithoutStateInput | cityCreateOrConnectWithoutStateInput[]
    upsert?: cityUpsertWithWhereUniqueWithoutStateInput | cityUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: cityCreateManyStateInputEnvelope
    set?: cityWhereUniqueInput | cityWhereUniqueInput[]
    disconnect?: cityWhereUniqueInput | cityWhereUniqueInput[]
    delete?: cityWhereUniqueInput | cityWhereUniqueInput[]
    connect?: cityWhereUniqueInput | cityWhereUniqueInput[]
    update?: cityUpdateWithWhereUniqueWithoutStateInput | cityUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: cityUpdateManyWithWhereWithoutStateInput | cityUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: cityScalarWhereInput | cityScalarWhereInput[]
  }

  export type countryUpdateOneRequiredWithoutStateNestedInput = {
    create?: XOR<countryCreateWithoutStateInput, countryUncheckedCreateWithoutStateInput>
    connectOrCreate?: countryCreateOrConnectWithoutStateInput
    upsert?: countryUpsertWithoutStateInput
    connect?: countryWhereUniqueInput
    update?: XOR<XOR<countryUpdateToOneWithWhereWithoutStateInput, countryUpdateWithoutStateInput>, countryUncheckedUpdateWithoutStateInput>
  }

  export type companyUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<companyCreateWithoutStateInput, companyUncheckedCreateWithoutStateInput> | companyCreateWithoutStateInput[] | companyUncheckedCreateWithoutStateInput[]
    connectOrCreate?: companyCreateOrConnectWithoutStateInput | companyCreateOrConnectWithoutStateInput[]
    upsert?: companyUpsertWithWhereUniqueWithoutStateInput | companyUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: companyCreateManyStateInputEnvelope
    set?: companyWhereUniqueInput | companyWhereUniqueInput[]
    disconnect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    delete?: companyWhereUniqueInput | companyWhereUniqueInput[]
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    update?: companyUpdateWithWhereUniqueWithoutStateInput | companyUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: companyUpdateManyWithWhereWithoutStateInput | companyUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: companyScalarWhereInput | companyScalarWhereInput[]
  }

  export type jobUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<jobCreateWithoutStateInput, jobUncheckedCreateWithoutStateInput> | jobCreateWithoutStateInput[] | jobUncheckedCreateWithoutStateInput[]
    connectOrCreate?: jobCreateOrConnectWithoutStateInput | jobCreateOrConnectWithoutStateInput[]
    upsert?: jobUpsertWithWhereUniqueWithoutStateInput | jobUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: jobCreateManyStateInputEnvelope
    set?: jobWhereUniqueInput | jobWhereUniqueInput[]
    disconnect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    delete?: jobWhereUniqueInput | jobWhereUniqueInput[]
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    update?: jobUpdateWithWhereUniqueWithoutStateInput | jobUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: jobUpdateManyWithWhereWithoutStateInput | jobUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: jobScalarWhereInput | jobScalarWhereInput[]
  }

  export type cityUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<cityCreateWithoutStateInput, cityUncheckedCreateWithoutStateInput> | cityCreateWithoutStateInput[] | cityUncheckedCreateWithoutStateInput[]
    connectOrCreate?: cityCreateOrConnectWithoutStateInput | cityCreateOrConnectWithoutStateInput[]
    upsert?: cityUpsertWithWhereUniqueWithoutStateInput | cityUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: cityCreateManyStateInputEnvelope
    set?: cityWhereUniqueInput | cityWhereUniqueInput[]
    disconnect?: cityWhereUniqueInput | cityWhereUniqueInput[]
    delete?: cityWhereUniqueInput | cityWhereUniqueInput[]
    connect?: cityWhereUniqueInput | cityWhereUniqueInput[]
    update?: cityUpdateWithWhereUniqueWithoutStateInput | cityUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: cityUpdateManyWithWhereWithoutStateInput | cityUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: cityScalarWhereInput | cityScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumcompanySizesNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.companySizes | EnumcompanySizesFieldRefInput<$PrismaModel> | null
    in?: $Enums.companySizes[] | ListEnumcompanySizesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.companySizes[] | ListEnumcompanySizesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumcompanySizesNullableFilter<$PrismaModel> | $Enums.companySizes | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumcompanySizesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.companySizes | EnumcompanySizesFieldRefInput<$PrismaModel> | null
    in?: $Enums.companySizes[] | ListEnumcompanySizesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.companySizes[] | ListEnumcompanySizesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumcompanySizesNullableWithAggregatesFilter<$PrismaModel> | $Enums.companySizes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumcompanySizesNullableFilter<$PrismaModel>
    _max?: NestedEnumcompanySizesNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumsalaryFrequencyNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.salaryFrequency | EnumsalaryFrequencyFieldRefInput<$PrismaModel> | null
    in?: $Enums.salaryFrequency[] | ListEnumsalaryFrequencyFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.salaryFrequency[] | ListEnumsalaryFrequencyFieldRefInput<$PrismaModel> | null
    not?: NestedEnumsalaryFrequencyNullableFilter<$PrismaModel> | $Enums.salaryFrequency | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumsalaryFrequencyNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.salaryFrequency | EnumsalaryFrequencyFieldRefInput<$PrismaModel> | null
    in?: $Enums.salaryFrequency[] | ListEnumsalaryFrequencyFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.salaryFrequency[] | ListEnumsalaryFrequencyFieldRefInput<$PrismaModel> | null
    not?: NestedEnumsalaryFrequencyNullableWithAggregatesFilter<$PrismaModel> | $Enums.salaryFrequency | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumsalaryFrequencyNullableFilter<$PrismaModel>
    _max?: NestedEnumsalaryFrequencyNullableFilter<$PrismaModel>
  }

  export type cityCreateWithoutCompanyInput = {
    city_name: string
    created_at?: Date | string
    updated_at?: Date | string
    job?: jobCreateNestedManyWithoutCityInput
    state?: stateCreateNestedOneWithoutCityInput
  }

  export type cityUncheckedCreateWithoutCompanyInput = {
    city_id?: number
    city_name: string
    state_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    job?: jobUncheckedCreateNestedManyWithoutCityInput
  }

  export type cityCreateOrConnectWithoutCompanyInput = {
    where: cityWhereUniqueInput
    create: XOR<cityCreateWithoutCompanyInput, cityUncheckedCreateWithoutCompanyInput>
  }

  export type countryCreateWithoutCompanyInput = {
    country_name: string
    country_code?: string
    created_at?: Date | string
    updated_at?: Date | string
    job?: jobCreateNestedManyWithoutCountryInput
    state?: stateCreateNestedManyWithoutCountryInput
  }

  export type countryUncheckedCreateWithoutCompanyInput = {
    country_id?: number
    country_name: string
    country_code?: string
    created_at?: Date | string
    updated_at?: Date | string
    job?: jobUncheckedCreateNestedManyWithoutCountryInput
    state?: stateUncheckedCreateNestedManyWithoutCountryInput
  }

  export type countryCreateOrConnectWithoutCompanyInput = {
    where: countryWhereUniqueInput
    create: XOR<countryCreateWithoutCompanyInput, countryUncheckedCreateWithoutCompanyInput>
  }

  export type stateCreateWithoutCompanyInput = {
    state_name: string
    state_code?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    job?: jobCreateNestedManyWithoutStateInput
    city?: cityCreateNestedManyWithoutStateInput
    country?: countryCreateNestedOneWithoutStateInput
  }

  export type stateUncheckedCreateWithoutCompanyInput = {
    state_id?: number
    state_name: string
    state_code?: string | null
    country_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    job?: jobUncheckedCreateNestedManyWithoutStateInput
    city?: cityUncheckedCreateNestedManyWithoutStateInput
  }

  export type stateCreateOrConnectWithoutCompanyInput = {
    where: stateWhereUniqueInput
    create: XOR<stateCreateWithoutCompanyInput, stateUncheckedCreateWithoutCompanyInput>
  }

  export type company_imageCreateWithoutCompanyInput = {
    company_image?: string | null
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_imageUncheckedCreateWithoutCompanyInput = {
    company_image_id?: number
    company_image?: string | null
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_imageCreateOrConnectWithoutCompanyInput = {
    where: company_imageWhereUniqueInput
    create: XOR<company_imageCreateWithoutCompanyInput, company_imageUncheckedCreateWithoutCompanyInput>
  }

  export type company_imageCreateManyCompanyInputEnvelope = {
    data: company_imageCreateManyCompanyInput | company_imageCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type company_industryCreateWithoutCompanyInput = {
    company_industry_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    industry_category: industry_categoryCreateNestedOneWithoutCompany_industryInput
  }

  export type company_industryUncheckedCreateWithoutCompanyInput = {
    company_industry_id?: number
    company_industry_uuid?: string
    industry_category_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_industryCreateOrConnectWithoutCompanyInput = {
    where: company_industryWhereUniqueInput
    create: XOR<company_industryCreateWithoutCompanyInput, company_industryUncheckedCreateWithoutCompanyInput>
  }

  export type company_industryCreateManyCompanyInputEnvelope = {
    data: company_industryCreateManyCompanyInput | company_industryCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type jobCreateWithoutCompanyInput = {
    job_uuid?: string
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    city?: cityCreateNestedOneWithoutJobInput
    country?: countryCreateNestedOneWithoutJobInput
    state?: stateCreateNestedOneWithoutJobInput
    job_category_map?: job_category_mapCreateNestedManyWithoutJobInput
    job_salary_map?: job_salary_mapCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapCreateNestedManyWithoutJobInput
  }

  export type jobUncheckedCreateWithoutCompanyInput = {
    job_id?: number
    job_uuid?: string
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    job_country_id?: number
    job_state_id?: number
    job_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    job_category_map?: job_category_mapUncheckedCreateNestedManyWithoutJobInput
    job_salary_map?: job_salary_mapUncheckedCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapUncheckedCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapUncheckedCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapUncheckedCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapUncheckedCreateNestedManyWithoutJobInput
  }

  export type jobCreateOrConnectWithoutCompanyInput = {
    where: jobWhereUniqueInput
    create: XOR<jobCreateWithoutCompanyInput, jobUncheckedCreateWithoutCompanyInput>
  }

  export type jobCreateManyCompanyInputEnvelope = {
    data: jobCreateManyCompanyInput | jobCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type cityUpsertWithoutCompanyInput = {
    update: XOR<cityUpdateWithoutCompanyInput, cityUncheckedUpdateWithoutCompanyInput>
    create: XOR<cityCreateWithoutCompanyInput, cityUncheckedCreateWithoutCompanyInput>
    where?: cityWhereInput
  }

  export type cityUpdateToOneWithWhereWithoutCompanyInput = {
    where?: cityWhereInput
    data: XOR<cityUpdateWithoutCompanyInput, cityUncheckedUpdateWithoutCompanyInput>
  }

  export type cityUpdateWithoutCompanyInput = {
    city_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: jobUpdateManyWithoutCityNestedInput
    state?: stateUpdateOneRequiredWithoutCityNestedInput
  }

  export type cityUncheckedUpdateWithoutCompanyInput = {
    city_id?: IntFieldUpdateOperationsInput | number
    city_name?: StringFieldUpdateOperationsInput | string
    state_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: jobUncheckedUpdateManyWithoutCityNestedInput
  }

  export type countryUpsertWithoutCompanyInput = {
    update: XOR<countryUpdateWithoutCompanyInput, countryUncheckedUpdateWithoutCompanyInput>
    create: XOR<countryCreateWithoutCompanyInput, countryUncheckedCreateWithoutCompanyInput>
    where?: countryWhereInput
  }

  export type countryUpdateToOneWithWhereWithoutCompanyInput = {
    where?: countryWhereInput
    data: XOR<countryUpdateWithoutCompanyInput, countryUncheckedUpdateWithoutCompanyInput>
  }

  export type countryUpdateWithoutCompanyInput = {
    country_name?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: jobUpdateManyWithoutCountryNestedInput
    state?: stateUpdateManyWithoutCountryNestedInput
  }

  export type countryUncheckedUpdateWithoutCompanyInput = {
    country_id?: IntFieldUpdateOperationsInput | number
    country_name?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: jobUncheckedUpdateManyWithoutCountryNestedInput
    state?: stateUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type stateUpsertWithoutCompanyInput = {
    update: XOR<stateUpdateWithoutCompanyInput, stateUncheckedUpdateWithoutCompanyInput>
    create: XOR<stateCreateWithoutCompanyInput, stateUncheckedCreateWithoutCompanyInput>
    where?: stateWhereInput
  }

  export type stateUpdateToOneWithWhereWithoutCompanyInput = {
    where?: stateWhereInput
    data: XOR<stateUpdateWithoutCompanyInput, stateUncheckedUpdateWithoutCompanyInput>
  }

  export type stateUpdateWithoutCompanyInput = {
    state_name?: StringFieldUpdateOperationsInput | string
    state_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: jobUpdateManyWithoutStateNestedInput
    city?: cityUpdateManyWithoutStateNestedInput
    country?: countryUpdateOneRequiredWithoutStateNestedInput
  }

  export type stateUncheckedUpdateWithoutCompanyInput = {
    state_id?: IntFieldUpdateOperationsInput | number
    state_name?: StringFieldUpdateOperationsInput | string
    state_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: jobUncheckedUpdateManyWithoutStateNestedInput
    city?: cityUncheckedUpdateManyWithoutStateNestedInput
  }

  export type company_imageUpsertWithWhereUniqueWithoutCompanyInput = {
    where: company_imageWhereUniqueInput
    update: XOR<company_imageUpdateWithoutCompanyInput, company_imageUncheckedUpdateWithoutCompanyInput>
    create: XOR<company_imageCreateWithoutCompanyInput, company_imageUncheckedCreateWithoutCompanyInput>
  }

  export type company_imageUpdateWithWhereUniqueWithoutCompanyInput = {
    where: company_imageWhereUniqueInput
    data: XOR<company_imageUpdateWithoutCompanyInput, company_imageUncheckedUpdateWithoutCompanyInput>
  }

  export type company_imageUpdateManyWithWhereWithoutCompanyInput = {
    where: company_imageScalarWhereInput
    data: XOR<company_imageUpdateManyMutationInput, company_imageUncheckedUpdateManyWithoutCompanyInput>
  }

  export type company_imageScalarWhereInput = {
    AND?: company_imageScalarWhereInput | company_imageScalarWhereInput[]
    OR?: company_imageScalarWhereInput[]
    NOT?: company_imageScalarWhereInput | company_imageScalarWhereInput[]
    company_image_id?: IntFilter<"company_image"> | number
    company_id?: IntFilter<"company_image"> | number
    company_image?: StringNullableFilter<"company_image"> | string | null
    is_primary?: BoolFilter<"company_image"> | boolean
    created_at?: DateTimeFilter<"company_image"> | Date | string
    updated_at?: DateTimeFilter<"company_image"> | Date | string
  }

  export type company_industryUpsertWithWhereUniqueWithoutCompanyInput = {
    where: company_industryWhereUniqueInput
    update: XOR<company_industryUpdateWithoutCompanyInput, company_industryUncheckedUpdateWithoutCompanyInput>
    create: XOR<company_industryCreateWithoutCompanyInput, company_industryUncheckedCreateWithoutCompanyInput>
  }

  export type company_industryUpdateWithWhereUniqueWithoutCompanyInput = {
    where: company_industryWhereUniqueInput
    data: XOR<company_industryUpdateWithoutCompanyInput, company_industryUncheckedUpdateWithoutCompanyInput>
  }

  export type company_industryUpdateManyWithWhereWithoutCompanyInput = {
    where: company_industryScalarWhereInput
    data: XOR<company_industryUpdateManyMutationInput, company_industryUncheckedUpdateManyWithoutCompanyInput>
  }

  export type company_industryScalarWhereInput = {
    AND?: company_industryScalarWhereInput | company_industryScalarWhereInput[]
    OR?: company_industryScalarWhereInput[]
    NOT?: company_industryScalarWhereInput | company_industryScalarWhereInput[]
    company_industry_id?: IntFilter<"company_industry"> | number
    company_industry_uuid?: UuidFilter<"company_industry"> | string
    company_id?: IntFilter<"company_industry"> | number
    industry_category_id?: IntFilter<"company_industry"> | number
    created_at?: DateTimeFilter<"company_industry"> | Date | string
    updated_at?: DateTimeFilter<"company_industry"> | Date | string
  }

  export type jobUpsertWithWhereUniqueWithoutCompanyInput = {
    where: jobWhereUniqueInput
    update: XOR<jobUpdateWithoutCompanyInput, jobUncheckedUpdateWithoutCompanyInput>
    create: XOR<jobCreateWithoutCompanyInput, jobUncheckedCreateWithoutCompanyInput>
  }

  export type jobUpdateWithWhereUniqueWithoutCompanyInput = {
    where: jobWhereUniqueInput
    data: XOR<jobUpdateWithoutCompanyInput, jobUncheckedUpdateWithoutCompanyInput>
  }

  export type jobUpdateManyWithWhereWithoutCompanyInput = {
    where: jobScalarWhereInput
    data: XOR<jobUpdateManyMutationInput, jobUncheckedUpdateManyWithoutCompanyInput>
  }

  export type jobScalarWhereInput = {
    AND?: jobScalarWhereInput | jobScalarWhereInput[]
    OR?: jobScalarWhereInput[]
    NOT?: jobScalarWhereInput | jobScalarWhereInput[]
    job_id?: IntFilter<"job"> | number
    job_uuid?: UuidFilter<"job"> | string
    job_company?: IntFilter<"job"> | number
    job_description?: StringNullableFilter<"job"> | string | null
    job_name?: StringFilter<"job"> | string
    job_posted_date?: DateTimeFilter<"job"> | Date | string
    apply_link?: StringFilter<"job"> | string
    salary_min?: DecimalNullableFilter<"job"> | Decimal | DecimalJsLike | number | string | null
    salary_max?: DecimalNullableFilter<"job"> | Decimal | DecimalJsLike | number | string | null
    salary_currency?: StringNullableFilter<"job"> | string | null
    salary_frequency?: EnumsalaryFrequencyNullableFilter<"job"> | $Enums.salaryFrequency | null
    job_status?: BoolFilter<"job"> | boolean
    is_remote?: BoolFilter<"job"> | boolean
    job_country_id?: IntFilter<"job"> | number
    job_state_id?: IntFilter<"job"> | number
    job_city_id?: IntFilter<"job"> | number
    created_at?: DateTimeFilter<"job"> | Date | string
    updated_at?: DateTimeFilter<"job"> | Date | string
  }

  export type companyCreateWithoutCompany_imageInput = {
    company_uuid?: string
    company_name?: string
    company_description?: string | null
    company_website?: string | null
    establishment_date?: Date | string | null
    company_size?: $Enums.companySizes | null
    is_active?: boolean
    company_email?: string | null
    phone_number?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    city?: cityCreateNestedOneWithoutCompanyInput
    country?: countryCreateNestedOneWithoutCompanyInput
    state?: stateCreateNestedOneWithoutCompanyInput
    company_industry?: company_industryCreateNestedManyWithoutCompanyInput
    job?: jobCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutCompany_imageInput = {
    company_id?: number
    company_uuid?: string
    company_name?: string
    company_description?: string | null
    company_website?: string | null
    establishment_date?: Date | string | null
    company_size?: $Enums.companySizes | null
    is_active?: boolean
    company_email?: string | null
    phone_number?: string | null
    company_country_id?: number
    company_state_id?: number
    company_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    company_industry?: company_industryUncheckedCreateNestedManyWithoutCompanyInput
    job?: jobUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutCompany_imageInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutCompany_imageInput, companyUncheckedCreateWithoutCompany_imageInput>
  }

  export type companyUpsertWithoutCompany_imageInput = {
    update: XOR<companyUpdateWithoutCompany_imageInput, companyUncheckedUpdateWithoutCompany_imageInput>
    create: XOR<companyCreateWithoutCompany_imageInput, companyUncheckedCreateWithoutCompany_imageInput>
    where?: companyWhereInput
  }

  export type companyUpdateToOneWithWhereWithoutCompany_imageInput = {
    where?: companyWhereInput
    data: XOR<companyUpdateWithoutCompany_imageInput, companyUncheckedUpdateWithoutCompany_imageInput>
  }

  export type companyUpdateWithoutCompany_imageInput = {
    company_uuid?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    establishment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_size?: NullableEnumcompanySizesFieldUpdateOperationsInput | $Enums.companySizes | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    company_email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: cityUpdateOneRequiredWithoutCompanyNestedInput
    country?: countryUpdateOneRequiredWithoutCompanyNestedInput
    state?: stateUpdateOneRequiredWithoutCompanyNestedInput
    company_industry?: company_industryUpdateManyWithoutCompanyNestedInput
    job?: jobUpdateManyWithoutCompanyNestedInput
  }

  export type companyUncheckedUpdateWithoutCompany_imageInput = {
    company_id?: IntFieldUpdateOperationsInput | number
    company_uuid?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    establishment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_size?: NullableEnumcompanySizesFieldUpdateOperationsInput | $Enums.companySizes | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    company_email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    company_country_id?: IntFieldUpdateOperationsInput | number
    company_state_id?: IntFieldUpdateOperationsInput | number
    company_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_industry?: company_industryUncheckedUpdateManyWithoutCompanyNestedInput
    job?: jobUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type companyCreateWithoutCompany_industryInput = {
    company_uuid?: string
    company_name?: string
    company_description?: string | null
    company_website?: string | null
    establishment_date?: Date | string | null
    company_size?: $Enums.companySizes | null
    is_active?: boolean
    company_email?: string | null
    phone_number?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    city?: cityCreateNestedOneWithoutCompanyInput
    country?: countryCreateNestedOneWithoutCompanyInput
    state?: stateCreateNestedOneWithoutCompanyInput
    company_image?: company_imageCreateNestedManyWithoutCompanyInput
    job?: jobCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutCompany_industryInput = {
    company_id?: number
    company_uuid?: string
    company_name?: string
    company_description?: string | null
    company_website?: string | null
    establishment_date?: Date | string | null
    company_size?: $Enums.companySizes | null
    is_active?: boolean
    company_email?: string | null
    phone_number?: string | null
    company_country_id?: number
    company_state_id?: number
    company_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    company_image?: company_imageUncheckedCreateNestedManyWithoutCompanyInput
    job?: jobUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutCompany_industryInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutCompany_industryInput, companyUncheckedCreateWithoutCompany_industryInput>
  }

  export type industry_categoryCreateWithoutCompany_industryInput = {
    industry_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type industry_categoryUncheckedCreateWithoutCompany_industryInput = {
    industry_category_id?: number
    industry_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type industry_categoryCreateOrConnectWithoutCompany_industryInput = {
    where: industry_categoryWhereUniqueInput
    create: XOR<industry_categoryCreateWithoutCompany_industryInput, industry_categoryUncheckedCreateWithoutCompany_industryInput>
  }

  export type companyUpsertWithoutCompany_industryInput = {
    update: XOR<companyUpdateWithoutCompany_industryInput, companyUncheckedUpdateWithoutCompany_industryInput>
    create: XOR<companyCreateWithoutCompany_industryInput, companyUncheckedCreateWithoutCompany_industryInput>
    where?: companyWhereInput
  }

  export type companyUpdateToOneWithWhereWithoutCompany_industryInput = {
    where?: companyWhereInput
    data: XOR<companyUpdateWithoutCompany_industryInput, companyUncheckedUpdateWithoutCompany_industryInput>
  }

  export type companyUpdateWithoutCompany_industryInput = {
    company_uuid?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    establishment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_size?: NullableEnumcompanySizesFieldUpdateOperationsInput | $Enums.companySizes | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    company_email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: cityUpdateOneRequiredWithoutCompanyNestedInput
    country?: countryUpdateOneRequiredWithoutCompanyNestedInput
    state?: stateUpdateOneRequiredWithoutCompanyNestedInput
    company_image?: company_imageUpdateManyWithoutCompanyNestedInput
    job?: jobUpdateManyWithoutCompanyNestedInput
  }

  export type companyUncheckedUpdateWithoutCompany_industryInput = {
    company_id?: IntFieldUpdateOperationsInput | number
    company_uuid?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    establishment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_size?: NullableEnumcompanySizesFieldUpdateOperationsInput | $Enums.companySizes | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    company_email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    company_country_id?: IntFieldUpdateOperationsInput | number
    company_state_id?: IntFieldUpdateOperationsInput | number
    company_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_image?: company_imageUncheckedUpdateManyWithoutCompanyNestedInput
    job?: jobUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type industry_categoryUpsertWithoutCompany_industryInput = {
    update: XOR<industry_categoryUpdateWithoutCompany_industryInput, industry_categoryUncheckedUpdateWithoutCompany_industryInput>
    create: XOR<industry_categoryCreateWithoutCompany_industryInput, industry_categoryUncheckedCreateWithoutCompany_industryInput>
    where?: industry_categoryWhereInput
  }

  export type industry_categoryUpdateToOneWithWhereWithoutCompany_industryInput = {
    where?: industry_categoryWhereInput
    data: XOR<industry_categoryUpdateWithoutCompany_industryInput, industry_categoryUncheckedUpdateWithoutCompany_industryInput>
  }

  export type industry_categoryUpdateWithoutCompany_industryInput = {
    industry_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type industry_categoryUncheckedUpdateWithoutCompany_industryInput = {
    industry_category_id?: IntFieldUpdateOperationsInput | number
    industry_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_industryCreateWithoutIndustry_categoryInput = {
    company_industry_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    company: companyCreateNestedOneWithoutCompany_industryInput
  }

  export type company_industryUncheckedCreateWithoutIndustry_categoryInput = {
    company_industry_id?: number
    company_industry_uuid?: string
    company_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_industryCreateOrConnectWithoutIndustry_categoryInput = {
    where: company_industryWhereUniqueInput
    create: XOR<company_industryCreateWithoutIndustry_categoryInput, company_industryUncheckedCreateWithoutIndustry_categoryInput>
  }

  export type company_industryCreateManyIndustry_categoryInputEnvelope = {
    data: company_industryCreateManyIndustry_categoryInput | company_industryCreateManyIndustry_categoryInput[]
    skipDuplicates?: boolean
  }

  export type company_industryUpsertWithWhereUniqueWithoutIndustry_categoryInput = {
    where: company_industryWhereUniqueInput
    update: XOR<company_industryUpdateWithoutIndustry_categoryInput, company_industryUncheckedUpdateWithoutIndustry_categoryInput>
    create: XOR<company_industryCreateWithoutIndustry_categoryInput, company_industryUncheckedCreateWithoutIndustry_categoryInput>
  }

  export type company_industryUpdateWithWhereUniqueWithoutIndustry_categoryInput = {
    where: company_industryWhereUniqueInput
    data: XOR<company_industryUpdateWithoutIndustry_categoryInput, company_industryUncheckedUpdateWithoutIndustry_categoryInput>
  }

  export type company_industryUpdateManyWithWhereWithoutIndustry_categoryInput = {
    where: company_industryScalarWhereInput
    data: XOR<company_industryUpdateManyMutationInput, company_industryUncheckedUpdateManyWithoutIndustry_categoryInput>
  }

  export type cityCreateWithoutJobInput = {
    city_name: string
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyCreateNestedManyWithoutCityInput
    state?: stateCreateNestedOneWithoutCityInput
  }

  export type cityUncheckedCreateWithoutJobInput = {
    city_id?: number
    city_name: string
    state_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyUncheckedCreateNestedManyWithoutCityInput
  }

  export type cityCreateOrConnectWithoutJobInput = {
    where: cityWhereUniqueInput
    create: XOR<cityCreateWithoutJobInput, cityUncheckedCreateWithoutJobInput>
  }

  export type companyCreateWithoutJobInput = {
    company_uuid?: string
    company_name?: string
    company_description?: string | null
    company_website?: string | null
    establishment_date?: Date | string | null
    company_size?: $Enums.companySizes | null
    is_active?: boolean
    company_email?: string | null
    phone_number?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    city?: cityCreateNestedOneWithoutCompanyInput
    country?: countryCreateNestedOneWithoutCompanyInput
    state?: stateCreateNestedOneWithoutCompanyInput
    company_image?: company_imageCreateNestedManyWithoutCompanyInput
    company_industry?: company_industryCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutJobInput = {
    company_id?: number
    company_uuid?: string
    company_name?: string
    company_description?: string | null
    company_website?: string | null
    establishment_date?: Date | string | null
    company_size?: $Enums.companySizes | null
    is_active?: boolean
    company_email?: string | null
    phone_number?: string | null
    company_country_id?: number
    company_state_id?: number
    company_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    company_image?: company_imageUncheckedCreateNestedManyWithoutCompanyInput
    company_industry?: company_industryUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutJobInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutJobInput, companyUncheckedCreateWithoutJobInput>
  }

  export type countryCreateWithoutJobInput = {
    country_name: string
    country_code?: string
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyCreateNestedManyWithoutCountryInput
    state?: stateCreateNestedManyWithoutCountryInput
  }

  export type countryUncheckedCreateWithoutJobInput = {
    country_id?: number
    country_name: string
    country_code?: string
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyUncheckedCreateNestedManyWithoutCountryInput
    state?: stateUncheckedCreateNestedManyWithoutCountryInput
  }

  export type countryCreateOrConnectWithoutJobInput = {
    where: countryWhereUniqueInput
    create: XOR<countryCreateWithoutJobInput, countryUncheckedCreateWithoutJobInput>
  }

  export type stateCreateWithoutJobInput = {
    state_name: string
    state_code?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyCreateNestedManyWithoutStateInput
    city?: cityCreateNestedManyWithoutStateInput
    country?: countryCreateNestedOneWithoutStateInput
  }

  export type stateUncheckedCreateWithoutJobInput = {
    state_id?: number
    state_name: string
    state_code?: string | null
    country_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyUncheckedCreateNestedManyWithoutStateInput
    city?: cityUncheckedCreateNestedManyWithoutStateInput
  }

  export type stateCreateOrConnectWithoutJobInput = {
    where: stateWhereUniqueInput
    create: XOR<stateCreateWithoutJobInput, stateUncheckedCreateWithoutJobInput>
  }

  export type job_category_mapCreateWithoutJobInput = {
    job_category_map_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    job_category?: job_categoryCreateNestedOneWithoutJob_category_mapInput
  }

  export type job_category_mapUncheckedCreateWithoutJobInput = {
    job_category_map_id?: number
    job_category_map_uuid?: string
    category_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_category_mapCreateOrConnectWithoutJobInput = {
    where: job_category_mapWhereUniqueInput
    create: XOR<job_category_mapCreateWithoutJobInput, job_category_mapUncheckedCreateWithoutJobInput>
  }

  export type job_category_mapCreateManyJobInputEnvelope = {
    data: job_category_mapCreateManyJobInput | job_category_mapCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type job_salary_mapCreateWithoutJobInput = {
    job_salary_map_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    job_salary?: job_salaryCreateNestedOneWithoutJob_salary_mapInput
  }

  export type job_salary_mapUncheckedCreateWithoutJobInput = {
    job_salary_map_id?: number
    job_salary_map_uuid?: string
    salary_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_salary_mapCreateOrConnectWithoutJobInput = {
    where: job_salary_mapWhereUniqueInput
    create: XOR<job_salary_mapCreateWithoutJobInput, job_salary_mapUncheckedCreateWithoutJobInput>
  }

  export type job_salary_mapCreateManyJobInputEnvelope = {
    data: job_salary_mapCreateManyJobInput | job_salary_mapCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type job_schedule_mapCreateWithoutJobInput = {
    job_schedule_map_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    job_schedule?: job_scheduleCreateNestedOneWithoutJob_schedule_mapInput
  }

  export type job_schedule_mapUncheckedCreateWithoutJobInput = {
    job_schedule_map_id?: number
    job_schedule_map_uuid?: string
    schedule_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_schedule_mapCreateOrConnectWithoutJobInput = {
    where: job_schedule_mapWhereUniqueInput
    create: XOR<job_schedule_mapCreateWithoutJobInput, job_schedule_mapUncheckedCreateWithoutJobInput>
  }

  export type job_schedule_mapCreateManyJobInputEnvelope = {
    data: job_schedule_mapCreateManyJobInput | job_schedule_mapCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type job_skill_mapCreateWithoutJobInput = {
    job_skill_map_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    job_skill?: job_skillCreateNestedOneWithoutJob_skill_mapInput
  }

  export type job_skill_mapUncheckedCreateWithoutJobInput = {
    job_skill_map_id?: number
    job_skill_map_uuid?: string
    skill_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_skill_mapCreateOrConnectWithoutJobInput = {
    where: job_skill_mapWhereUniqueInput
    create: XOR<job_skill_mapCreateWithoutJobInput, job_skill_mapUncheckedCreateWithoutJobInput>
  }

  export type job_skill_mapCreateManyJobInputEnvelope = {
    data: job_skill_mapCreateManyJobInput | job_skill_mapCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type job_source_mapCreateWithoutJobInput = {
    job_source_map_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    job_source?: job_sourceCreateNestedOneWithoutJob_source_mapInput
  }

  export type job_source_mapUncheckedCreateWithoutJobInput = {
    job_source_map_id?: number
    job_source_map_uuid?: string
    source_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_source_mapCreateOrConnectWithoutJobInput = {
    where: job_source_mapWhereUniqueInput
    create: XOR<job_source_mapCreateWithoutJobInput, job_source_mapUncheckedCreateWithoutJobInput>
  }

  export type job_source_mapCreateManyJobInputEnvelope = {
    data: job_source_mapCreateManyJobInput | job_source_mapCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type job_type_mapCreateWithoutJobInput = {
    job_type_map_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    job_type?: job_typeCreateNestedOneWithoutJob_type_mapInput
  }

  export type job_type_mapUncheckedCreateWithoutJobInput = {
    job_type_map_id?: number
    job_type_map_uuid?: string
    type_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_type_mapCreateOrConnectWithoutJobInput = {
    where: job_type_mapWhereUniqueInput
    create: XOR<job_type_mapCreateWithoutJobInput, job_type_mapUncheckedCreateWithoutJobInput>
  }

  export type job_type_mapCreateManyJobInputEnvelope = {
    data: job_type_mapCreateManyJobInput | job_type_mapCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type cityUpsertWithoutJobInput = {
    update: XOR<cityUpdateWithoutJobInput, cityUncheckedUpdateWithoutJobInput>
    create: XOR<cityCreateWithoutJobInput, cityUncheckedCreateWithoutJobInput>
    where?: cityWhereInput
  }

  export type cityUpdateToOneWithWhereWithoutJobInput = {
    where?: cityWhereInput
    data: XOR<cityUpdateWithoutJobInput, cityUncheckedUpdateWithoutJobInput>
  }

  export type cityUpdateWithoutJobInput = {
    city_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUpdateManyWithoutCityNestedInput
    state?: stateUpdateOneRequiredWithoutCityNestedInput
  }

  export type cityUncheckedUpdateWithoutJobInput = {
    city_id?: IntFieldUpdateOperationsInput | number
    city_name?: StringFieldUpdateOperationsInput | string
    state_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUncheckedUpdateManyWithoutCityNestedInput
  }

  export type companyUpsertWithoutJobInput = {
    update: XOR<companyUpdateWithoutJobInput, companyUncheckedUpdateWithoutJobInput>
    create: XOR<companyCreateWithoutJobInput, companyUncheckedCreateWithoutJobInput>
    where?: companyWhereInput
  }

  export type companyUpdateToOneWithWhereWithoutJobInput = {
    where?: companyWhereInput
    data: XOR<companyUpdateWithoutJobInput, companyUncheckedUpdateWithoutJobInput>
  }

  export type companyUpdateWithoutJobInput = {
    company_uuid?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    establishment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_size?: NullableEnumcompanySizesFieldUpdateOperationsInput | $Enums.companySizes | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    company_email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: cityUpdateOneRequiredWithoutCompanyNestedInput
    country?: countryUpdateOneRequiredWithoutCompanyNestedInput
    state?: stateUpdateOneRequiredWithoutCompanyNestedInput
    company_image?: company_imageUpdateManyWithoutCompanyNestedInput
    company_industry?: company_industryUpdateManyWithoutCompanyNestedInput
  }

  export type companyUncheckedUpdateWithoutJobInput = {
    company_id?: IntFieldUpdateOperationsInput | number
    company_uuid?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    establishment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_size?: NullableEnumcompanySizesFieldUpdateOperationsInput | $Enums.companySizes | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    company_email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    company_country_id?: IntFieldUpdateOperationsInput | number
    company_state_id?: IntFieldUpdateOperationsInput | number
    company_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_image?: company_imageUncheckedUpdateManyWithoutCompanyNestedInput
    company_industry?: company_industryUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type countryUpsertWithoutJobInput = {
    update: XOR<countryUpdateWithoutJobInput, countryUncheckedUpdateWithoutJobInput>
    create: XOR<countryCreateWithoutJobInput, countryUncheckedCreateWithoutJobInput>
    where?: countryWhereInput
  }

  export type countryUpdateToOneWithWhereWithoutJobInput = {
    where?: countryWhereInput
    data: XOR<countryUpdateWithoutJobInput, countryUncheckedUpdateWithoutJobInput>
  }

  export type countryUpdateWithoutJobInput = {
    country_name?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUpdateManyWithoutCountryNestedInput
    state?: stateUpdateManyWithoutCountryNestedInput
  }

  export type countryUncheckedUpdateWithoutJobInput = {
    country_id?: IntFieldUpdateOperationsInput | number
    country_name?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUncheckedUpdateManyWithoutCountryNestedInput
    state?: stateUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type stateUpsertWithoutJobInput = {
    update: XOR<stateUpdateWithoutJobInput, stateUncheckedUpdateWithoutJobInput>
    create: XOR<stateCreateWithoutJobInput, stateUncheckedCreateWithoutJobInput>
    where?: stateWhereInput
  }

  export type stateUpdateToOneWithWhereWithoutJobInput = {
    where?: stateWhereInput
    data: XOR<stateUpdateWithoutJobInput, stateUncheckedUpdateWithoutJobInput>
  }

  export type stateUpdateWithoutJobInput = {
    state_name?: StringFieldUpdateOperationsInput | string
    state_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUpdateManyWithoutStateNestedInput
    city?: cityUpdateManyWithoutStateNestedInput
    country?: countryUpdateOneRequiredWithoutStateNestedInput
  }

  export type stateUncheckedUpdateWithoutJobInput = {
    state_id?: IntFieldUpdateOperationsInput | number
    state_name?: StringFieldUpdateOperationsInput | string
    state_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUncheckedUpdateManyWithoutStateNestedInput
    city?: cityUncheckedUpdateManyWithoutStateNestedInput
  }

  export type job_category_mapUpsertWithWhereUniqueWithoutJobInput = {
    where: job_category_mapWhereUniqueInput
    update: XOR<job_category_mapUpdateWithoutJobInput, job_category_mapUncheckedUpdateWithoutJobInput>
    create: XOR<job_category_mapCreateWithoutJobInput, job_category_mapUncheckedCreateWithoutJobInput>
  }

  export type job_category_mapUpdateWithWhereUniqueWithoutJobInput = {
    where: job_category_mapWhereUniqueInput
    data: XOR<job_category_mapUpdateWithoutJobInput, job_category_mapUncheckedUpdateWithoutJobInput>
  }

  export type job_category_mapUpdateManyWithWhereWithoutJobInput = {
    where: job_category_mapScalarWhereInput
    data: XOR<job_category_mapUpdateManyMutationInput, job_category_mapUncheckedUpdateManyWithoutJobInput>
  }

  export type job_category_mapScalarWhereInput = {
    AND?: job_category_mapScalarWhereInput | job_category_mapScalarWhereInput[]
    OR?: job_category_mapScalarWhereInput[]
    NOT?: job_category_mapScalarWhereInput | job_category_mapScalarWhereInput[]
    job_category_map_id?: IntFilter<"job_category_map"> | number
    job_category_map_uuid?: UuidFilter<"job_category_map"> | string
    job_id?: IntFilter<"job_category_map"> | number
    category_id?: IntFilter<"job_category_map"> | number
    created_at?: DateTimeFilter<"job_category_map"> | Date | string
    updated_at?: DateTimeFilter<"job_category_map"> | Date | string
  }

  export type job_salary_mapUpsertWithWhereUniqueWithoutJobInput = {
    where: job_salary_mapWhereUniqueInput
    update: XOR<job_salary_mapUpdateWithoutJobInput, job_salary_mapUncheckedUpdateWithoutJobInput>
    create: XOR<job_salary_mapCreateWithoutJobInput, job_salary_mapUncheckedCreateWithoutJobInput>
  }

  export type job_salary_mapUpdateWithWhereUniqueWithoutJobInput = {
    where: job_salary_mapWhereUniqueInput
    data: XOR<job_salary_mapUpdateWithoutJobInput, job_salary_mapUncheckedUpdateWithoutJobInput>
  }

  export type job_salary_mapUpdateManyWithWhereWithoutJobInput = {
    where: job_salary_mapScalarWhereInput
    data: XOR<job_salary_mapUpdateManyMutationInput, job_salary_mapUncheckedUpdateManyWithoutJobInput>
  }

  export type job_salary_mapScalarWhereInput = {
    AND?: job_salary_mapScalarWhereInput | job_salary_mapScalarWhereInput[]
    OR?: job_salary_mapScalarWhereInput[]
    NOT?: job_salary_mapScalarWhereInput | job_salary_mapScalarWhereInput[]
    job_salary_map_id?: IntFilter<"job_salary_map"> | number
    job_salary_map_uuid?: UuidFilter<"job_salary_map"> | string
    job_id?: IntFilter<"job_salary_map"> | number
    salary_id?: IntFilter<"job_salary_map"> | number
    created_at?: DateTimeFilter<"job_salary_map"> | Date | string
    updated_at?: DateTimeFilter<"job_salary_map"> | Date | string
  }

  export type job_schedule_mapUpsertWithWhereUniqueWithoutJobInput = {
    where: job_schedule_mapWhereUniqueInput
    update: XOR<job_schedule_mapUpdateWithoutJobInput, job_schedule_mapUncheckedUpdateWithoutJobInput>
    create: XOR<job_schedule_mapCreateWithoutJobInput, job_schedule_mapUncheckedCreateWithoutJobInput>
  }

  export type job_schedule_mapUpdateWithWhereUniqueWithoutJobInput = {
    where: job_schedule_mapWhereUniqueInput
    data: XOR<job_schedule_mapUpdateWithoutJobInput, job_schedule_mapUncheckedUpdateWithoutJobInput>
  }

  export type job_schedule_mapUpdateManyWithWhereWithoutJobInput = {
    where: job_schedule_mapScalarWhereInput
    data: XOR<job_schedule_mapUpdateManyMutationInput, job_schedule_mapUncheckedUpdateManyWithoutJobInput>
  }

  export type job_schedule_mapScalarWhereInput = {
    AND?: job_schedule_mapScalarWhereInput | job_schedule_mapScalarWhereInput[]
    OR?: job_schedule_mapScalarWhereInput[]
    NOT?: job_schedule_mapScalarWhereInput | job_schedule_mapScalarWhereInput[]
    job_schedule_map_id?: IntFilter<"job_schedule_map"> | number
    job_schedule_map_uuid?: UuidFilter<"job_schedule_map"> | string
    job_id?: IntFilter<"job_schedule_map"> | number
    schedule_id?: IntFilter<"job_schedule_map"> | number
    created_at?: DateTimeFilter<"job_schedule_map"> | Date | string
    updated_at?: DateTimeFilter<"job_schedule_map"> | Date | string
  }

  export type job_skill_mapUpsertWithWhereUniqueWithoutJobInput = {
    where: job_skill_mapWhereUniqueInput
    update: XOR<job_skill_mapUpdateWithoutJobInput, job_skill_mapUncheckedUpdateWithoutJobInput>
    create: XOR<job_skill_mapCreateWithoutJobInput, job_skill_mapUncheckedCreateWithoutJobInput>
  }

  export type job_skill_mapUpdateWithWhereUniqueWithoutJobInput = {
    where: job_skill_mapWhereUniqueInput
    data: XOR<job_skill_mapUpdateWithoutJobInput, job_skill_mapUncheckedUpdateWithoutJobInput>
  }

  export type job_skill_mapUpdateManyWithWhereWithoutJobInput = {
    where: job_skill_mapScalarWhereInput
    data: XOR<job_skill_mapUpdateManyMutationInput, job_skill_mapUncheckedUpdateManyWithoutJobInput>
  }

  export type job_skill_mapScalarWhereInput = {
    AND?: job_skill_mapScalarWhereInput | job_skill_mapScalarWhereInput[]
    OR?: job_skill_mapScalarWhereInput[]
    NOT?: job_skill_mapScalarWhereInput | job_skill_mapScalarWhereInput[]
    job_skill_map_id?: IntFilter<"job_skill_map"> | number
    job_skill_map_uuid?: UuidFilter<"job_skill_map"> | string
    job_id?: IntFilter<"job_skill_map"> | number
    skill_id?: IntFilter<"job_skill_map"> | number
    created_at?: DateTimeFilter<"job_skill_map"> | Date | string
    updated_at?: DateTimeFilter<"job_skill_map"> | Date | string
  }

  export type job_source_mapUpsertWithWhereUniqueWithoutJobInput = {
    where: job_source_mapWhereUniqueInput
    update: XOR<job_source_mapUpdateWithoutJobInput, job_source_mapUncheckedUpdateWithoutJobInput>
    create: XOR<job_source_mapCreateWithoutJobInput, job_source_mapUncheckedCreateWithoutJobInput>
  }

  export type job_source_mapUpdateWithWhereUniqueWithoutJobInput = {
    where: job_source_mapWhereUniqueInput
    data: XOR<job_source_mapUpdateWithoutJobInput, job_source_mapUncheckedUpdateWithoutJobInput>
  }

  export type job_source_mapUpdateManyWithWhereWithoutJobInput = {
    where: job_source_mapScalarWhereInput
    data: XOR<job_source_mapUpdateManyMutationInput, job_source_mapUncheckedUpdateManyWithoutJobInput>
  }

  export type job_source_mapScalarWhereInput = {
    AND?: job_source_mapScalarWhereInput | job_source_mapScalarWhereInput[]
    OR?: job_source_mapScalarWhereInput[]
    NOT?: job_source_mapScalarWhereInput | job_source_mapScalarWhereInput[]
    job_source_map_id?: IntFilter<"job_source_map"> | number
    job_source_map_uuid?: UuidFilter<"job_source_map"> | string
    job_id?: IntFilter<"job_source_map"> | number
    source_id?: IntFilter<"job_source_map"> | number
    created_at?: DateTimeFilter<"job_source_map"> | Date | string
    updated_at?: DateTimeFilter<"job_source_map"> | Date | string
  }

  export type job_type_mapUpsertWithWhereUniqueWithoutJobInput = {
    where: job_type_mapWhereUniqueInput
    update: XOR<job_type_mapUpdateWithoutJobInput, job_type_mapUncheckedUpdateWithoutJobInput>
    create: XOR<job_type_mapCreateWithoutJobInput, job_type_mapUncheckedCreateWithoutJobInput>
  }

  export type job_type_mapUpdateWithWhereUniqueWithoutJobInput = {
    where: job_type_mapWhereUniqueInput
    data: XOR<job_type_mapUpdateWithoutJobInput, job_type_mapUncheckedUpdateWithoutJobInput>
  }

  export type job_type_mapUpdateManyWithWhereWithoutJobInput = {
    where: job_type_mapScalarWhereInput
    data: XOR<job_type_mapUpdateManyMutationInput, job_type_mapUncheckedUpdateManyWithoutJobInput>
  }

  export type job_type_mapScalarWhereInput = {
    AND?: job_type_mapScalarWhereInput | job_type_mapScalarWhereInput[]
    OR?: job_type_mapScalarWhereInput[]
    NOT?: job_type_mapScalarWhereInput | job_type_mapScalarWhereInput[]
    job_type_map_id?: IntFilter<"job_type_map"> | number
    job_type_map_uuid?: UuidFilter<"job_type_map"> | string
    job_id?: IntFilter<"job_type_map"> | number
    type_id?: IntFilter<"job_type_map"> | number
    created_at?: DateTimeFilter<"job_type_map"> | Date | string
    updated_at?: DateTimeFilter<"job_type_map"> | Date | string
  }

  export type job_category_mapCreateWithoutJob_categoryInput = {
    job_category_map_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    job: jobCreateNestedOneWithoutJob_category_mapInput
  }

  export type job_category_mapUncheckedCreateWithoutJob_categoryInput = {
    job_category_map_id?: number
    job_category_map_uuid?: string
    job_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_category_mapCreateOrConnectWithoutJob_categoryInput = {
    where: job_category_mapWhereUniqueInput
    create: XOR<job_category_mapCreateWithoutJob_categoryInput, job_category_mapUncheckedCreateWithoutJob_categoryInput>
  }

  export type job_category_mapCreateManyJob_categoryInputEnvelope = {
    data: job_category_mapCreateManyJob_categoryInput | job_category_mapCreateManyJob_categoryInput[]
    skipDuplicates?: boolean
  }

  export type job_category_mapUpsertWithWhereUniqueWithoutJob_categoryInput = {
    where: job_category_mapWhereUniqueInput
    update: XOR<job_category_mapUpdateWithoutJob_categoryInput, job_category_mapUncheckedUpdateWithoutJob_categoryInput>
    create: XOR<job_category_mapCreateWithoutJob_categoryInput, job_category_mapUncheckedCreateWithoutJob_categoryInput>
  }

  export type job_category_mapUpdateWithWhereUniqueWithoutJob_categoryInput = {
    where: job_category_mapWhereUniqueInput
    data: XOR<job_category_mapUpdateWithoutJob_categoryInput, job_category_mapUncheckedUpdateWithoutJob_categoryInput>
  }

  export type job_category_mapUpdateManyWithWhereWithoutJob_categoryInput = {
    where: job_category_mapScalarWhereInput
    data: XOR<job_category_mapUpdateManyMutationInput, job_category_mapUncheckedUpdateManyWithoutJob_categoryInput>
  }

  export type job_categoryCreateWithoutJob_category_mapInput = {
    job_category_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_categoryUncheckedCreateWithoutJob_category_mapInput = {
    job_category_id?: number
    job_category_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_categoryCreateOrConnectWithoutJob_category_mapInput = {
    where: job_categoryWhereUniqueInput
    create: XOR<job_categoryCreateWithoutJob_category_mapInput, job_categoryUncheckedCreateWithoutJob_category_mapInput>
  }

  export type jobCreateWithoutJob_category_mapInput = {
    job_uuid?: string
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    city?: cityCreateNestedOneWithoutJobInput
    company: companyCreateNestedOneWithoutJobInput
    country?: countryCreateNestedOneWithoutJobInput
    state?: stateCreateNestedOneWithoutJobInput
    job_salary_map?: job_salary_mapCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapCreateNestedManyWithoutJobInput
  }

  export type jobUncheckedCreateWithoutJob_category_mapInput = {
    job_id?: number
    job_uuid?: string
    job_company: number
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    job_country_id?: number
    job_state_id?: number
    job_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    job_salary_map?: job_salary_mapUncheckedCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapUncheckedCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapUncheckedCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapUncheckedCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapUncheckedCreateNestedManyWithoutJobInput
  }

  export type jobCreateOrConnectWithoutJob_category_mapInput = {
    where: jobWhereUniqueInput
    create: XOR<jobCreateWithoutJob_category_mapInput, jobUncheckedCreateWithoutJob_category_mapInput>
  }

  export type job_categoryUpsertWithoutJob_category_mapInput = {
    update: XOR<job_categoryUpdateWithoutJob_category_mapInput, job_categoryUncheckedUpdateWithoutJob_category_mapInput>
    create: XOR<job_categoryCreateWithoutJob_category_mapInput, job_categoryUncheckedCreateWithoutJob_category_mapInput>
    where?: job_categoryWhereInput
  }

  export type job_categoryUpdateToOneWithWhereWithoutJob_category_mapInput = {
    where?: job_categoryWhereInput
    data: XOR<job_categoryUpdateWithoutJob_category_mapInput, job_categoryUncheckedUpdateWithoutJob_category_mapInput>
  }

  export type job_categoryUpdateWithoutJob_category_mapInput = {
    job_category_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_categoryUncheckedUpdateWithoutJob_category_mapInput = {
    job_category_id?: IntFieldUpdateOperationsInput | number
    job_category_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jobUpsertWithoutJob_category_mapInput = {
    update: XOR<jobUpdateWithoutJob_category_mapInput, jobUncheckedUpdateWithoutJob_category_mapInput>
    create: XOR<jobCreateWithoutJob_category_mapInput, jobUncheckedCreateWithoutJob_category_mapInput>
    where?: jobWhereInput
  }

  export type jobUpdateToOneWithWhereWithoutJob_category_mapInput = {
    where?: jobWhereInput
    data: XOR<jobUpdateWithoutJob_category_mapInput, jobUncheckedUpdateWithoutJob_category_mapInput>
  }

  export type jobUpdateWithoutJob_category_mapInput = {
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: cityUpdateOneRequiredWithoutJobNestedInput
    company?: companyUpdateOneRequiredWithoutJobNestedInput
    country?: countryUpdateOneRequiredWithoutJobNestedInput
    state?: stateUpdateOneRequiredWithoutJobNestedInput
    job_salary_map?: job_salary_mapUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUpdateManyWithoutJobNestedInput
  }

  export type jobUncheckedUpdateWithoutJob_category_mapInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_company?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    job_country_id?: IntFieldUpdateOperationsInput | number
    job_state_id?: IntFieldUpdateOperationsInput | number
    job_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_salary_map?: job_salary_mapUncheckedUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUncheckedUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUncheckedUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUncheckedUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUncheckedUpdateManyWithoutJobNestedInput
  }

  export type job_salary_mapCreateWithoutJob_salaryInput = {
    job_salary_map_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    job: jobCreateNestedOneWithoutJob_salary_mapInput
  }

  export type job_salary_mapUncheckedCreateWithoutJob_salaryInput = {
    job_salary_map_id?: number
    job_salary_map_uuid?: string
    job_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_salary_mapCreateOrConnectWithoutJob_salaryInput = {
    where: job_salary_mapWhereUniqueInput
    create: XOR<job_salary_mapCreateWithoutJob_salaryInput, job_salary_mapUncheckedCreateWithoutJob_salaryInput>
  }

  export type job_salary_mapCreateManyJob_salaryInputEnvelope = {
    data: job_salary_mapCreateManyJob_salaryInput | job_salary_mapCreateManyJob_salaryInput[]
    skipDuplicates?: boolean
  }

  export type job_salary_mapUpsertWithWhereUniqueWithoutJob_salaryInput = {
    where: job_salary_mapWhereUniqueInput
    update: XOR<job_salary_mapUpdateWithoutJob_salaryInput, job_salary_mapUncheckedUpdateWithoutJob_salaryInput>
    create: XOR<job_salary_mapCreateWithoutJob_salaryInput, job_salary_mapUncheckedCreateWithoutJob_salaryInput>
  }

  export type job_salary_mapUpdateWithWhereUniqueWithoutJob_salaryInput = {
    where: job_salary_mapWhereUniqueInput
    data: XOR<job_salary_mapUpdateWithoutJob_salaryInput, job_salary_mapUncheckedUpdateWithoutJob_salaryInput>
  }

  export type job_salary_mapUpdateManyWithWhereWithoutJob_salaryInput = {
    where: job_salary_mapScalarWhereInput
    data: XOR<job_salary_mapUpdateManyMutationInput, job_salary_mapUncheckedUpdateManyWithoutJob_salaryInput>
  }

  export type jobCreateWithoutJob_salary_mapInput = {
    job_uuid?: string
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    city?: cityCreateNestedOneWithoutJobInput
    company: companyCreateNestedOneWithoutJobInput
    country?: countryCreateNestedOneWithoutJobInput
    state?: stateCreateNestedOneWithoutJobInput
    job_category_map?: job_category_mapCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapCreateNestedManyWithoutJobInput
  }

  export type jobUncheckedCreateWithoutJob_salary_mapInput = {
    job_id?: number
    job_uuid?: string
    job_company: number
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    job_country_id?: number
    job_state_id?: number
    job_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    job_category_map?: job_category_mapUncheckedCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapUncheckedCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapUncheckedCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapUncheckedCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapUncheckedCreateNestedManyWithoutJobInput
  }

  export type jobCreateOrConnectWithoutJob_salary_mapInput = {
    where: jobWhereUniqueInput
    create: XOR<jobCreateWithoutJob_salary_mapInput, jobUncheckedCreateWithoutJob_salary_mapInput>
  }

  export type job_salaryCreateWithoutJob_salary_mapInput = {
    job_salary_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_salaryUncheckedCreateWithoutJob_salary_mapInput = {
    job_salary_id?: number
    job_salary_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_salaryCreateOrConnectWithoutJob_salary_mapInput = {
    where: job_salaryWhereUniqueInput
    create: XOR<job_salaryCreateWithoutJob_salary_mapInput, job_salaryUncheckedCreateWithoutJob_salary_mapInput>
  }

  export type jobUpsertWithoutJob_salary_mapInput = {
    update: XOR<jobUpdateWithoutJob_salary_mapInput, jobUncheckedUpdateWithoutJob_salary_mapInput>
    create: XOR<jobCreateWithoutJob_salary_mapInput, jobUncheckedCreateWithoutJob_salary_mapInput>
    where?: jobWhereInput
  }

  export type jobUpdateToOneWithWhereWithoutJob_salary_mapInput = {
    where?: jobWhereInput
    data: XOR<jobUpdateWithoutJob_salary_mapInput, jobUncheckedUpdateWithoutJob_salary_mapInput>
  }

  export type jobUpdateWithoutJob_salary_mapInput = {
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: cityUpdateOneRequiredWithoutJobNestedInput
    company?: companyUpdateOneRequiredWithoutJobNestedInput
    country?: countryUpdateOneRequiredWithoutJobNestedInput
    state?: stateUpdateOneRequiredWithoutJobNestedInput
    job_category_map?: job_category_mapUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUpdateManyWithoutJobNestedInput
  }

  export type jobUncheckedUpdateWithoutJob_salary_mapInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_company?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    job_country_id?: IntFieldUpdateOperationsInput | number
    job_state_id?: IntFieldUpdateOperationsInput | number
    job_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_category_map?: job_category_mapUncheckedUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUncheckedUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUncheckedUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUncheckedUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUncheckedUpdateManyWithoutJobNestedInput
  }

  export type job_salaryUpsertWithoutJob_salary_mapInput = {
    update: XOR<job_salaryUpdateWithoutJob_salary_mapInput, job_salaryUncheckedUpdateWithoutJob_salary_mapInput>
    create: XOR<job_salaryCreateWithoutJob_salary_mapInput, job_salaryUncheckedCreateWithoutJob_salary_mapInput>
    where?: job_salaryWhereInput
  }

  export type job_salaryUpdateToOneWithWhereWithoutJob_salary_mapInput = {
    where?: job_salaryWhereInput
    data: XOR<job_salaryUpdateWithoutJob_salary_mapInput, job_salaryUncheckedUpdateWithoutJob_salary_mapInput>
  }

  export type job_salaryUpdateWithoutJob_salary_mapInput = {
    job_salary_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_salaryUncheckedUpdateWithoutJob_salary_mapInput = {
    job_salary_id?: IntFieldUpdateOperationsInput | number
    job_salary_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_schedule_mapCreateWithoutJob_scheduleInput = {
    job_schedule_map_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    job: jobCreateNestedOneWithoutJob_schedule_mapInput
  }

  export type job_schedule_mapUncheckedCreateWithoutJob_scheduleInput = {
    job_schedule_map_id?: number
    job_schedule_map_uuid?: string
    job_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_schedule_mapCreateOrConnectWithoutJob_scheduleInput = {
    where: job_schedule_mapWhereUniqueInput
    create: XOR<job_schedule_mapCreateWithoutJob_scheduleInput, job_schedule_mapUncheckedCreateWithoutJob_scheduleInput>
  }

  export type job_schedule_mapCreateManyJob_scheduleInputEnvelope = {
    data: job_schedule_mapCreateManyJob_scheduleInput | job_schedule_mapCreateManyJob_scheduleInput[]
    skipDuplicates?: boolean
  }

  export type job_schedule_mapUpsertWithWhereUniqueWithoutJob_scheduleInput = {
    where: job_schedule_mapWhereUniqueInput
    update: XOR<job_schedule_mapUpdateWithoutJob_scheduleInput, job_schedule_mapUncheckedUpdateWithoutJob_scheduleInput>
    create: XOR<job_schedule_mapCreateWithoutJob_scheduleInput, job_schedule_mapUncheckedCreateWithoutJob_scheduleInput>
  }

  export type job_schedule_mapUpdateWithWhereUniqueWithoutJob_scheduleInput = {
    where: job_schedule_mapWhereUniqueInput
    data: XOR<job_schedule_mapUpdateWithoutJob_scheduleInput, job_schedule_mapUncheckedUpdateWithoutJob_scheduleInput>
  }

  export type job_schedule_mapUpdateManyWithWhereWithoutJob_scheduleInput = {
    where: job_schedule_mapScalarWhereInput
    data: XOR<job_schedule_mapUpdateManyMutationInput, job_schedule_mapUncheckedUpdateManyWithoutJob_scheduleInput>
  }

  export type jobCreateWithoutJob_schedule_mapInput = {
    job_uuid?: string
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    city?: cityCreateNestedOneWithoutJobInput
    company: companyCreateNestedOneWithoutJobInput
    country?: countryCreateNestedOneWithoutJobInput
    state?: stateCreateNestedOneWithoutJobInput
    job_category_map?: job_category_mapCreateNestedManyWithoutJobInput
    job_salary_map?: job_salary_mapCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapCreateNestedManyWithoutJobInput
  }

  export type jobUncheckedCreateWithoutJob_schedule_mapInput = {
    job_id?: number
    job_uuid?: string
    job_company: number
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    job_country_id?: number
    job_state_id?: number
    job_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    job_category_map?: job_category_mapUncheckedCreateNestedManyWithoutJobInput
    job_salary_map?: job_salary_mapUncheckedCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapUncheckedCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapUncheckedCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapUncheckedCreateNestedManyWithoutJobInput
  }

  export type jobCreateOrConnectWithoutJob_schedule_mapInput = {
    where: jobWhereUniqueInput
    create: XOR<jobCreateWithoutJob_schedule_mapInput, jobUncheckedCreateWithoutJob_schedule_mapInput>
  }

  export type job_scheduleCreateWithoutJob_schedule_mapInput = {
    job_schedule_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_scheduleUncheckedCreateWithoutJob_schedule_mapInput = {
    job_schedule_id?: number
    job_schedule_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_scheduleCreateOrConnectWithoutJob_schedule_mapInput = {
    where: job_scheduleWhereUniqueInput
    create: XOR<job_scheduleCreateWithoutJob_schedule_mapInput, job_scheduleUncheckedCreateWithoutJob_schedule_mapInput>
  }

  export type jobUpsertWithoutJob_schedule_mapInput = {
    update: XOR<jobUpdateWithoutJob_schedule_mapInput, jobUncheckedUpdateWithoutJob_schedule_mapInput>
    create: XOR<jobCreateWithoutJob_schedule_mapInput, jobUncheckedCreateWithoutJob_schedule_mapInput>
    where?: jobWhereInput
  }

  export type jobUpdateToOneWithWhereWithoutJob_schedule_mapInput = {
    where?: jobWhereInput
    data: XOR<jobUpdateWithoutJob_schedule_mapInput, jobUncheckedUpdateWithoutJob_schedule_mapInput>
  }

  export type jobUpdateWithoutJob_schedule_mapInput = {
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: cityUpdateOneRequiredWithoutJobNestedInput
    company?: companyUpdateOneRequiredWithoutJobNestedInput
    country?: countryUpdateOneRequiredWithoutJobNestedInput
    state?: stateUpdateOneRequiredWithoutJobNestedInput
    job_category_map?: job_category_mapUpdateManyWithoutJobNestedInput
    job_salary_map?: job_salary_mapUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUpdateManyWithoutJobNestedInput
  }

  export type jobUncheckedUpdateWithoutJob_schedule_mapInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_company?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    job_country_id?: IntFieldUpdateOperationsInput | number
    job_state_id?: IntFieldUpdateOperationsInput | number
    job_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_category_map?: job_category_mapUncheckedUpdateManyWithoutJobNestedInput
    job_salary_map?: job_salary_mapUncheckedUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUncheckedUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUncheckedUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUncheckedUpdateManyWithoutJobNestedInput
  }

  export type job_scheduleUpsertWithoutJob_schedule_mapInput = {
    update: XOR<job_scheduleUpdateWithoutJob_schedule_mapInput, job_scheduleUncheckedUpdateWithoutJob_schedule_mapInput>
    create: XOR<job_scheduleCreateWithoutJob_schedule_mapInput, job_scheduleUncheckedCreateWithoutJob_schedule_mapInput>
    where?: job_scheduleWhereInput
  }

  export type job_scheduleUpdateToOneWithWhereWithoutJob_schedule_mapInput = {
    where?: job_scheduleWhereInput
    data: XOR<job_scheduleUpdateWithoutJob_schedule_mapInput, job_scheduleUncheckedUpdateWithoutJob_schedule_mapInput>
  }

  export type job_scheduleUpdateWithoutJob_schedule_mapInput = {
    job_schedule_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_scheduleUncheckedUpdateWithoutJob_schedule_mapInput = {
    job_schedule_id?: IntFieldUpdateOperationsInput | number
    job_schedule_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_skill_mapCreateWithoutJob_skillInput = {
    job_skill_map_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    job: jobCreateNestedOneWithoutJob_skill_mapInput
  }

  export type job_skill_mapUncheckedCreateWithoutJob_skillInput = {
    job_skill_map_id?: number
    job_skill_map_uuid?: string
    job_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_skill_mapCreateOrConnectWithoutJob_skillInput = {
    where: job_skill_mapWhereUniqueInput
    create: XOR<job_skill_mapCreateWithoutJob_skillInput, job_skill_mapUncheckedCreateWithoutJob_skillInput>
  }

  export type job_skill_mapCreateManyJob_skillInputEnvelope = {
    data: job_skill_mapCreateManyJob_skillInput | job_skill_mapCreateManyJob_skillInput[]
    skipDuplicates?: boolean
  }

  export type job_skill_mapUpsertWithWhereUniqueWithoutJob_skillInput = {
    where: job_skill_mapWhereUniqueInput
    update: XOR<job_skill_mapUpdateWithoutJob_skillInput, job_skill_mapUncheckedUpdateWithoutJob_skillInput>
    create: XOR<job_skill_mapCreateWithoutJob_skillInput, job_skill_mapUncheckedCreateWithoutJob_skillInput>
  }

  export type job_skill_mapUpdateWithWhereUniqueWithoutJob_skillInput = {
    where: job_skill_mapWhereUniqueInput
    data: XOR<job_skill_mapUpdateWithoutJob_skillInput, job_skill_mapUncheckedUpdateWithoutJob_skillInput>
  }

  export type job_skill_mapUpdateManyWithWhereWithoutJob_skillInput = {
    where: job_skill_mapScalarWhereInput
    data: XOR<job_skill_mapUpdateManyMutationInput, job_skill_mapUncheckedUpdateManyWithoutJob_skillInput>
  }

  export type jobCreateWithoutJob_skill_mapInput = {
    job_uuid?: string
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    city?: cityCreateNestedOneWithoutJobInput
    company: companyCreateNestedOneWithoutJobInput
    country?: countryCreateNestedOneWithoutJobInput
    state?: stateCreateNestedOneWithoutJobInput
    job_category_map?: job_category_mapCreateNestedManyWithoutJobInput
    job_salary_map?: job_salary_mapCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapCreateNestedManyWithoutJobInput
  }

  export type jobUncheckedCreateWithoutJob_skill_mapInput = {
    job_id?: number
    job_uuid?: string
    job_company: number
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    job_country_id?: number
    job_state_id?: number
    job_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    job_category_map?: job_category_mapUncheckedCreateNestedManyWithoutJobInput
    job_salary_map?: job_salary_mapUncheckedCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapUncheckedCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapUncheckedCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapUncheckedCreateNestedManyWithoutJobInput
  }

  export type jobCreateOrConnectWithoutJob_skill_mapInput = {
    where: jobWhereUniqueInput
    create: XOR<jobCreateWithoutJob_skill_mapInput, jobUncheckedCreateWithoutJob_skill_mapInput>
  }

  export type job_skillCreateWithoutJob_skill_mapInput = {
    job_skill_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_skillUncheckedCreateWithoutJob_skill_mapInput = {
    job_skill_id?: number
    job_skill_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_skillCreateOrConnectWithoutJob_skill_mapInput = {
    where: job_skillWhereUniqueInput
    create: XOR<job_skillCreateWithoutJob_skill_mapInput, job_skillUncheckedCreateWithoutJob_skill_mapInput>
  }

  export type jobUpsertWithoutJob_skill_mapInput = {
    update: XOR<jobUpdateWithoutJob_skill_mapInput, jobUncheckedUpdateWithoutJob_skill_mapInput>
    create: XOR<jobCreateWithoutJob_skill_mapInput, jobUncheckedCreateWithoutJob_skill_mapInput>
    where?: jobWhereInput
  }

  export type jobUpdateToOneWithWhereWithoutJob_skill_mapInput = {
    where?: jobWhereInput
    data: XOR<jobUpdateWithoutJob_skill_mapInput, jobUncheckedUpdateWithoutJob_skill_mapInput>
  }

  export type jobUpdateWithoutJob_skill_mapInput = {
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: cityUpdateOneRequiredWithoutJobNestedInput
    company?: companyUpdateOneRequiredWithoutJobNestedInput
    country?: countryUpdateOneRequiredWithoutJobNestedInput
    state?: stateUpdateOneRequiredWithoutJobNestedInput
    job_category_map?: job_category_mapUpdateManyWithoutJobNestedInput
    job_salary_map?: job_salary_mapUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUpdateManyWithoutJobNestedInput
  }

  export type jobUncheckedUpdateWithoutJob_skill_mapInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_company?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    job_country_id?: IntFieldUpdateOperationsInput | number
    job_state_id?: IntFieldUpdateOperationsInput | number
    job_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_category_map?: job_category_mapUncheckedUpdateManyWithoutJobNestedInput
    job_salary_map?: job_salary_mapUncheckedUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUncheckedUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUncheckedUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUncheckedUpdateManyWithoutJobNestedInput
  }

  export type job_skillUpsertWithoutJob_skill_mapInput = {
    update: XOR<job_skillUpdateWithoutJob_skill_mapInput, job_skillUncheckedUpdateWithoutJob_skill_mapInput>
    create: XOR<job_skillCreateWithoutJob_skill_mapInput, job_skillUncheckedCreateWithoutJob_skill_mapInput>
    where?: job_skillWhereInput
  }

  export type job_skillUpdateToOneWithWhereWithoutJob_skill_mapInput = {
    where?: job_skillWhereInput
    data: XOR<job_skillUpdateWithoutJob_skill_mapInput, job_skillUncheckedUpdateWithoutJob_skill_mapInput>
  }

  export type job_skillUpdateWithoutJob_skill_mapInput = {
    job_skill_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_skillUncheckedUpdateWithoutJob_skill_mapInput = {
    job_skill_id?: IntFieldUpdateOperationsInput | number
    job_skill_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_source_mapCreateWithoutJob_sourceInput = {
    job_source_map_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    job: jobCreateNestedOneWithoutJob_source_mapInput
  }

  export type job_source_mapUncheckedCreateWithoutJob_sourceInput = {
    job_source_map_id?: number
    job_source_map_uuid?: string
    job_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_source_mapCreateOrConnectWithoutJob_sourceInput = {
    where: job_source_mapWhereUniqueInput
    create: XOR<job_source_mapCreateWithoutJob_sourceInput, job_source_mapUncheckedCreateWithoutJob_sourceInput>
  }

  export type job_source_mapCreateManyJob_sourceInputEnvelope = {
    data: job_source_mapCreateManyJob_sourceInput | job_source_mapCreateManyJob_sourceInput[]
    skipDuplicates?: boolean
  }

  export type job_source_mapUpsertWithWhereUniqueWithoutJob_sourceInput = {
    where: job_source_mapWhereUniqueInput
    update: XOR<job_source_mapUpdateWithoutJob_sourceInput, job_source_mapUncheckedUpdateWithoutJob_sourceInput>
    create: XOR<job_source_mapCreateWithoutJob_sourceInput, job_source_mapUncheckedCreateWithoutJob_sourceInput>
  }

  export type job_source_mapUpdateWithWhereUniqueWithoutJob_sourceInput = {
    where: job_source_mapWhereUniqueInput
    data: XOR<job_source_mapUpdateWithoutJob_sourceInput, job_source_mapUncheckedUpdateWithoutJob_sourceInput>
  }

  export type job_source_mapUpdateManyWithWhereWithoutJob_sourceInput = {
    where: job_source_mapScalarWhereInput
    data: XOR<job_source_mapUpdateManyMutationInput, job_source_mapUncheckedUpdateManyWithoutJob_sourceInput>
  }

  export type jobCreateWithoutJob_source_mapInput = {
    job_uuid?: string
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    city?: cityCreateNestedOneWithoutJobInput
    company: companyCreateNestedOneWithoutJobInput
    country?: countryCreateNestedOneWithoutJobInput
    state?: stateCreateNestedOneWithoutJobInput
    job_category_map?: job_category_mapCreateNestedManyWithoutJobInput
    job_salary_map?: job_salary_mapCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapCreateNestedManyWithoutJobInput
  }

  export type jobUncheckedCreateWithoutJob_source_mapInput = {
    job_id?: number
    job_uuid?: string
    job_company: number
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    job_country_id?: number
    job_state_id?: number
    job_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    job_category_map?: job_category_mapUncheckedCreateNestedManyWithoutJobInput
    job_salary_map?: job_salary_mapUncheckedCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapUncheckedCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapUncheckedCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapUncheckedCreateNestedManyWithoutJobInput
  }

  export type jobCreateOrConnectWithoutJob_source_mapInput = {
    where: jobWhereUniqueInput
    create: XOR<jobCreateWithoutJob_source_mapInput, jobUncheckedCreateWithoutJob_source_mapInput>
  }

  export type job_sourceCreateWithoutJob_source_mapInput = {
    job_source_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_sourceUncheckedCreateWithoutJob_source_mapInput = {
    job_source_id?: number
    job_source_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_sourceCreateOrConnectWithoutJob_source_mapInput = {
    where: job_sourceWhereUniqueInput
    create: XOR<job_sourceCreateWithoutJob_source_mapInput, job_sourceUncheckedCreateWithoutJob_source_mapInput>
  }

  export type jobUpsertWithoutJob_source_mapInput = {
    update: XOR<jobUpdateWithoutJob_source_mapInput, jobUncheckedUpdateWithoutJob_source_mapInput>
    create: XOR<jobCreateWithoutJob_source_mapInput, jobUncheckedCreateWithoutJob_source_mapInput>
    where?: jobWhereInput
  }

  export type jobUpdateToOneWithWhereWithoutJob_source_mapInput = {
    where?: jobWhereInput
    data: XOR<jobUpdateWithoutJob_source_mapInput, jobUncheckedUpdateWithoutJob_source_mapInput>
  }

  export type jobUpdateWithoutJob_source_mapInput = {
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: cityUpdateOneRequiredWithoutJobNestedInput
    company?: companyUpdateOneRequiredWithoutJobNestedInput
    country?: countryUpdateOneRequiredWithoutJobNestedInput
    state?: stateUpdateOneRequiredWithoutJobNestedInput
    job_category_map?: job_category_mapUpdateManyWithoutJobNestedInput
    job_salary_map?: job_salary_mapUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUpdateManyWithoutJobNestedInput
  }

  export type jobUncheckedUpdateWithoutJob_source_mapInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_company?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    job_country_id?: IntFieldUpdateOperationsInput | number
    job_state_id?: IntFieldUpdateOperationsInput | number
    job_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_category_map?: job_category_mapUncheckedUpdateManyWithoutJobNestedInput
    job_salary_map?: job_salary_mapUncheckedUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUncheckedUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUncheckedUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUncheckedUpdateManyWithoutJobNestedInput
  }

  export type job_sourceUpsertWithoutJob_source_mapInput = {
    update: XOR<job_sourceUpdateWithoutJob_source_mapInput, job_sourceUncheckedUpdateWithoutJob_source_mapInput>
    create: XOR<job_sourceCreateWithoutJob_source_mapInput, job_sourceUncheckedCreateWithoutJob_source_mapInput>
    where?: job_sourceWhereInput
  }

  export type job_sourceUpdateToOneWithWhereWithoutJob_source_mapInput = {
    where?: job_sourceWhereInput
    data: XOR<job_sourceUpdateWithoutJob_source_mapInput, job_sourceUncheckedUpdateWithoutJob_source_mapInput>
  }

  export type job_sourceUpdateWithoutJob_source_mapInput = {
    job_source_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_sourceUncheckedUpdateWithoutJob_source_mapInput = {
    job_source_id?: IntFieldUpdateOperationsInput | number
    job_source_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_type_mapCreateWithoutJob_typeInput = {
    job_type_map_uuid?: string
    created_at?: Date | string
    updated_at?: Date | string
    job: jobCreateNestedOneWithoutJob_type_mapInput
  }

  export type job_type_mapUncheckedCreateWithoutJob_typeInput = {
    job_type_map_id?: number
    job_type_map_uuid?: string
    job_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_type_mapCreateOrConnectWithoutJob_typeInput = {
    where: job_type_mapWhereUniqueInput
    create: XOR<job_type_mapCreateWithoutJob_typeInput, job_type_mapUncheckedCreateWithoutJob_typeInput>
  }

  export type job_type_mapCreateManyJob_typeInputEnvelope = {
    data: job_type_mapCreateManyJob_typeInput | job_type_mapCreateManyJob_typeInput[]
    skipDuplicates?: boolean
  }

  export type job_type_mapUpsertWithWhereUniqueWithoutJob_typeInput = {
    where: job_type_mapWhereUniqueInput
    update: XOR<job_type_mapUpdateWithoutJob_typeInput, job_type_mapUncheckedUpdateWithoutJob_typeInput>
    create: XOR<job_type_mapCreateWithoutJob_typeInput, job_type_mapUncheckedCreateWithoutJob_typeInput>
  }

  export type job_type_mapUpdateWithWhereUniqueWithoutJob_typeInput = {
    where: job_type_mapWhereUniqueInput
    data: XOR<job_type_mapUpdateWithoutJob_typeInput, job_type_mapUncheckedUpdateWithoutJob_typeInput>
  }

  export type job_type_mapUpdateManyWithWhereWithoutJob_typeInput = {
    where: job_type_mapScalarWhereInput
    data: XOR<job_type_mapUpdateManyMutationInput, job_type_mapUncheckedUpdateManyWithoutJob_typeInput>
  }

  export type jobCreateWithoutJob_type_mapInput = {
    job_uuid?: string
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    city?: cityCreateNestedOneWithoutJobInput
    company: companyCreateNestedOneWithoutJobInput
    country?: countryCreateNestedOneWithoutJobInput
    state?: stateCreateNestedOneWithoutJobInput
    job_category_map?: job_category_mapCreateNestedManyWithoutJobInput
    job_salary_map?: job_salary_mapCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapCreateNestedManyWithoutJobInput
  }

  export type jobUncheckedCreateWithoutJob_type_mapInput = {
    job_id?: number
    job_uuid?: string
    job_company: number
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    job_country_id?: number
    job_state_id?: number
    job_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    job_category_map?: job_category_mapUncheckedCreateNestedManyWithoutJobInput
    job_salary_map?: job_salary_mapUncheckedCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapUncheckedCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapUncheckedCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapUncheckedCreateNestedManyWithoutJobInput
  }

  export type jobCreateOrConnectWithoutJob_type_mapInput = {
    where: jobWhereUniqueInput
    create: XOR<jobCreateWithoutJob_type_mapInput, jobUncheckedCreateWithoutJob_type_mapInput>
  }

  export type job_typeCreateWithoutJob_type_mapInput = {
    job_type_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_typeUncheckedCreateWithoutJob_type_mapInput = {
    job_type_id?: number
    job_type_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_typeCreateOrConnectWithoutJob_type_mapInput = {
    where: job_typeWhereUniqueInput
    create: XOR<job_typeCreateWithoutJob_type_mapInput, job_typeUncheckedCreateWithoutJob_type_mapInput>
  }

  export type jobUpsertWithoutJob_type_mapInput = {
    update: XOR<jobUpdateWithoutJob_type_mapInput, jobUncheckedUpdateWithoutJob_type_mapInput>
    create: XOR<jobCreateWithoutJob_type_mapInput, jobUncheckedCreateWithoutJob_type_mapInput>
    where?: jobWhereInput
  }

  export type jobUpdateToOneWithWhereWithoutJob_type_mapInput = {
    where?: jobWhereInput
    data: XOR<jobUpdateWithoutJob_type_mapInput, jobUncheckedUpdateWithoutJob_type_mapInput>
  }

  export type jobUpdateWithoutJob_type_mapInput = {
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: cityUpdateOneRequiredWithoutJobNestedInput
    company?: companyUpdateOneRequiredWithoutJobNestedInput
    country?: countryUpdateOneRequiredWithoutJobNestedInput
    state?: stateUpdateOneRequiredWithoutJobNestedInput
    job_category_map?: job_category_mapUpdateManyWithoutJobNestedInput
    job_salary_map?: job_salary_mapUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUpdateManyWithoutJobNestedInput
  }

  export type jobUncheckedUpdateWithoutJob_type_mapInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_company?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    job_country_id?: IntFieldUpdateOperationsInput | number
    job_state_id?: IntFieldUpdateOperationsInput | number
    job_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_category_map?: job_category_mapUncheckedUpdateManyWithoutJobNestedInput
    job_salary_map?: job_salary_mapUncheckedUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUncheckedUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUncheckedUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUncheckedUpdateManyWithoutJobNestedInput
  }

  export type job_typeUpsertWithoutJob_type_mapInput = {
    update: XOR<job_typeUpdateWithoutJob_type_mapInput, job_typeUncheckedUpdateWithoutJob_type_mapInput>
    create: XOR<job_typeCreateWithoutJob_type_mapInput, job_typeUncheckedCreateWithoutJob_type_mapInput>
    where?: job_typeWhereInput
  }

  export type job_typeUpdateToOneWithWhereWithoutJob_type_mapInput = {
    where?: job_typeWhereInput
    data: XOR<job_typeUpdateWithoutJob_type_mapInput, job_typeUncheckedUpdateWithoutJob_type_mapInput>
  }

  export type job_typeUpdateWithoutJob_type_mapInput = {
    job_type_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_typeUncheckedUpdateWithoutJob_type_mapInput = {
    job_type_id?: IntFieldUpdateOperationsInput | number
    job_type_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyCreateWithoutCityInput = {
    company_uuid?: string
    company_name?: string
    company_description?: string | null
    company_website?: string | null
    establishment_date?: Date | string | null
    company_size?: $Enums.companySizes | null
    is_active?: boolean
    company_email?: string | null
    phone_number?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    country?: countryCreateNestedOneWithoutCompanyInput
    state?: stateCreateNestedOneWithoutCompanyInput
    company_image?: company_imageCreateNestedManyWithoutCompanyInput
    company_industry?: company_industryCreateNestedManyWithoutCompanyInput
    job?: jobCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutCityInput = {
    company_id?: number
    company_uuid?: string
    company_name?: string
    company_description?: string | null
    company_website?: string | null
    establishment_date?: Date | string | null
    company_size?: $Enums.companySizes | null
    is_active?: boolean
    company_email?: string | null
    phone_number?: string | null
    company_country_id?: number
    company_state_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    company_image?: company_imageUncheckedCreateNestedManyWithoutCompanyInput
    company_industry?: company_industryUncheckedCreateNestedManyWithoutCompanyInput
    job?: jobUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutCityInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutCityInput, companyUncheckedCreateWithoutCityInput>
  }

  export type companyCreateManyCityInputEnvelope = {
    data: companyCreateManyCityInput | companyCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type jobCreateWithoutCityInput = {
    job_uuid?: string
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    company: companyCreateNestedOneWithoutJobInput
    country?: countryCreateNestedOneWithoutJobInput
    state?: stateCreateNestedOneWithoutJobInput
    job_category_map?: job_category_mapCreateNestedManyWithoutJobInput
    job_salary_map?: job_salary_mapCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapCreateNestedManyWithoutJobInput
  }

  export type jobUncheckedCreateWithoutCityInput = {
    job_id?: number
    job_uuid?: string
    job_company: number
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    job_country_id?: number
    job_state_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    job_category_map?: job_category_mapUncheckedCreateNestedManyWithoutJobInput
    job_salary_map?: job_salary_mapUncheckedCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapUncheckedCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapUncheckedCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapUncheckedCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapUncheckedCreateNestedManyWithoutJobInput
  }

  export type jobCreateOrConnectWithoutCityInput = {
    where: jobWhereUniqueInput
    create: XOR<jobCreateWithoutCityInput, jobUncheckedCreateWithoutCityInput>
  }

  export type jobCreateManyCityInputEnvelope = {
    data: jobCreateManyCityInput | jobCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type stateCreateWithoutCityInput = {
    state_name: string
    state_code?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyCreateNestedManyWithoutStateInput
    job?: jobCreateNestedManyWithoutStateInput
    country?: countryCreateNestedOneWithoutStateInput
  }

  export type stateUncheckedCreateWithoutCityInput = {
    state_id?: number
    state_name: string
    state_code?: string | null
    country_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyUncheckedCreateNestedManyWithoutStateInput
    job?: jobUncheckedCreateNestedManyWithoutStateInput
  }

  export type stateCreateOrConnectWithoutCityInput = {
    where: stateWhereUniqueInput
    create: XOR<stateCreateWithoutCityInput, stateUncheckedCreateWithoutCityInput>
  }

  export type companyUpsertWithWhereUniqueWithoutCityInput = {
    where: companyWhereUniqueInput
    update: XOR<companyUpdateWithoutCityInput, companyUncheckedUpdateWithoutCityInput>
    create: XOR<companyCreateWithoutCityInput, companyUncheckedCreateWithoutCityInput>
  }

  export type companyUpdateWithWhereUniqueWithoutCityInput = {
    where: companyWhereUniqueInput
    data: XOR<companyUpdateWithoutCityInput, companyUncheckedUpdateWithoutCityInput>
  }

  export type companyUpdateManyWithWhereWithoutCityInput = {
    where: companyScalarWhereInput
    data: XOR<companyUpdateManyMutationInput, companyUncheckedUpdateManyWithoutCityInput>
  }

  export type companyScalarWhereInput = {
    AND?: companyScalarWhereInput | companyScalarWhereInput[]
    OR?: companyScalarWhereInput[]
    NOT?: companyScalarWhereInput | companyScalarWhereInput[]
    company_id?: IntFilter<"company"> | number
    company_uuid?: UuidFilter<"company"> | string
    company_name?: StringFilter<"company"> | string
    company_description?: StringNullableFilter<"company"> | string | null
    company_website?: StringNullableFilter<"company"> | string | null
    establishment_date?: DateTimeNullableFilter<"company"> | Date | string | null
    company_size?: EnumcompanySizesNullableFilter<"company"> | $Enums.companySizes | null
    is_active?: BoolFilter<"company"> | boolean
    company_email?: StringNullableFilter<"company"> | string | null
    phone_number?: StringNullableFilter<"company"> | string | null
    company_country_id?: IntFilter<"company"> | number
    company_state_id?: IntFilter<"company"> | number
    company_city_id?: IntFilter<"company"> | number
    created_at?: DateTimeFilter<"company"> | Date | string
    updated_at?: DateTimeFilter<"company"> | Date | string
    deleted_at?: DateTimeNullableFilter<"company"> | Date | string | null
  }

  export type jobUpsertWithWhereUniqueWithoutCityInput = {
    where: jobWhereUniqueInput
    update: XOR<jobUpdateWithoutCityInput, jobUncheckedUpdateWithoutCityInput>
    create: XOR<jobCreateWithoutCityInput, jobUncheckedCreateWithoutCityInput>
  }

  export type jobUpdateWithWhereUniqueWithoutCityInput = {
    where: jobWhereUniqueInput
    data: XOR<jobUpdateWithoutCityInput, jobUncheckedUpdateWithoutCityInput>
  }

  export type jobUpdateManyWithWhereWithoutCityInput = {
    where: jobScalarWhereInput
    data: XOR<jobUpdateManyMutationInput, jobUncheckedUpdateManyWithoutCityInput>
  }

  export type stateUpsertWithoutCityInput = {
    update: XOR<stateUpdateWithoutCityInput, stateUncheckedUpdateWithoutCityInput>
    create: XOR<stateCreateWithoutCityInput, stateUncheckedCreateWithoutCityInput>
    where?: stateWhereInput
  }

  export type stateUpdateToOneWithWhereWithoutCityInput = {
    where?: stateWhereInput
    data: XOR<stateUpdateWithoutCityInput, stateUncheckedUpdateWithoutCityInput>
  }

  export type stateUpdateWithoutCityInput = {
    state_name?: StringFieldUpdateOperationsInput | string
    state_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUpdateManyWithoutStateNestedInput
    job?: jobUpdateManyWithoutStateNestedInput
    country?: countryUpdateOneRequiredWithoutStateNestedInput
  }

  export type stateUncheckedUpdateWithoutCityInput = {
    state_id?: IntFieldUpdateOperationsInput | number
    state_name?: StringFieldUpdateOperationsInput | string
    state_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUncheckedUpdateManyWithoutStateNestedInput
    job?: jobUncheckedUpdateManyWithoutStateNestedInput
  }

  export type companyCreateWithoutCountryInput = {
    company_uuid?: string
    company_name?: string
    company_description?: string | null
    company_website?: string | null
    establishment_date?: Date | string | null
    company_size?: $Enums.companySizes | null
    is_active?: boolean
    company_email?: string | null
    phone_number?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    city?: cityCreateNestedOneWithoutCompanyInput
    state?: stateCreateNestedOneWithoutCompanyInput
    company_image?: company_imageCreateNestedManyWithoutCompanyInput
    company_industry?: company_industryCreateNestedManyWithoutCompanyInput
    job?: jobCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutCountryInput = {
    company_id?: number
    company_uuid?: string
    company_name?: string
    company_description?: string | null
    company_website?: string | null
    establishment_date?: Date | string | null
    company_size?: $Enums.companySizes | null
    is_active?: boolean
    company_email?: string | null
    phone_number?: string | null
    company_state_id?: number
    company_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    company_image?: company_imageUncheckedCreateNestedManyWithoutCompanyInput
    company_industry?: company_industryUncheckedCreateNestedManyWithoutCompanyInput
    job?: jobUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutCountryInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutCountryInput, companyUncheckedCreateWithoutCountryInput>
  }

  export type companyCreateManyCountryInputEnvelope = {
    data: companyCreateManyCountryInput | companyCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type jobCreateWithoutCountryInput = {
    job_uuid?: string
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    city?: cityCreateNestedOneWithoutJobInput
    company: companyCreateNestedOneWithoutJobInput
    state?: stateCreateNestedOneWithoutJobInput
    job_category_map?: job_category_mapCreateNestedManyWithoutJobInput
    job_salary_map?: job_salary_mapCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapCreateNestedManyWithoutJobInput
  }

  export type jobUncheckedCreateWithoutCountryInput = {
    job_id?: number
    job_uuid?: string
    job_company: number
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    job_state_id?: number
    job_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    job_category_map?: job_category_mapUncheckedCreateNestedManyWithoutJobInput
    job_salary_map?: job_salary_mapUncheckedCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapUncheckedCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapUncheckedCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapUncheckedCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapUncheckedCreateNestedManyWithoutJobInput
  }

  export type jobCreateOrConnectWithoutCountryInput = {
    where: jobWhereUniqueInput
    create: XOR<jobCreateWithoutCountryInput, jobUncheckedCreateWithoutCountryInput>
  }

  export type jobCreateManyCountryInputEnvelope = {
    data: jobCreateManyCountryInput | jobCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type stateCreateWithoutCountryInput = {
    state_name: string
    state_code?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyCreateNestedManyWithoutStateInput
    job?: jobCreateNestedManyWithoutStateInput
    city?: cityCreateNestedManyWithoutStateInput
  }

  export type stateUncheckedCreateWithoutCountryInput = {
    state_id?: number
    state_name: string
    state_code?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyUncheckedCreateNestedManyWithoutStateInput
    job?: jobUncheckedCreateNestedManyWithoutStateInput
    city?: cityUncheckedCreateNestedManyWithoutStateInput
  }

  export type stateCreateOrConnectWithoutCountryInput = {
    where: stateWhereUniqueInput
    create: XOR<stateCreateWithoutCountryInput, stateUncheckedCreateWithoutCountryInput>
  }

  export type stateCreateManyCountryInputEnvelope = {
    data: stateCreateManyCountryInput | stateCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type companyUpsertWithWhereUniqueWithoutCountryInput = {
    where: companyWhereUniqueInput
    update: XOR<companyUpdateWithoutCountryInput, companyUncheckedUpdateWithoutCountryInput>
    create: XOR<companyCreateWithoutCountryInput, companyUncheckedCreateWithoutCountryInput>
  }

  export type companyUpdateWithWhereUniqueWithoutCountryInput = {
    where: companyWhereUniqueInput
    data: XOR<companyUpdateWithoutCountryInput, companyUncheckedUpdateWithoutCountryInput>
  }

  export type companyUpdateManyWithWhereWithoutCountryInput = {
    where: companyScalarWhereInput
    data: XOR<companyUpdateManyMutationInput, companyUncheckedUpdateManyWithoutCountryInput>
  }

  export type jobUpsertWithWhereUniqueWithoutCountryInput = {
    where: jobWhereUniqueInput
    update: XOR<jobUpdateWithoutCountryInput, jobUncheckedUpdateWithoutCountryInput>
    create: XOR<jobCreateWithoutCountryInput, jobUncheckedCreateWithoutCountryInput>
  }

  export type jobUpdateWithWhereUniqueWithoutCountryInput = {
    where: jobWhereUniqueInput
    data: XOR<jobUpdateWithoutCountryInput, jobUncheckedUpdateWithoutCountryInput>
  }

  export type jobUpdateManyWithWhereWithoutCountryInput = {
    where: jobScalarWhereInput
    data: XOR<jobUpdateManyMutationInput, jobUncheckedUpdateManyWithoutCountryInput>
  }

  export type stateUpsertWithWhereUniqueWithoutCountryInput = {
    where: stateWhereUniqueInput
    update: XOR<stateUpdateWithoutCountryInput, stateUncheckedUpdateWithoutCountryInput>
    create: XOR<stateCreateWithoutCountryInput, stateUncheckedCreateWithoutCountryInput>
  }

  export type stateUpdateWithWhereUniqueWithoutCountryInput = {
    where: stateWhereUniqueInput
    data: XOR<stateUpdateWithoutCountryInput, stateUncheckedUpdateWithoutCountryInput>
  }

  export type stateUpdateManyWithWhereWithoutCountryInput = {
    where: stateScalarWhereInput
    data: XOR<stateUpdateManyMutationInput, stateUncheckedUpdateManyWithoutCountryInput>
  }

  export type stateScalarWhereInput = {
    AND?: stateScalarWhereInput | stateScalarWhereInput[]
    OR?: stateScalarWhereInput[]
    NOT?: stateScalarWhereInput | stateScalarWhereInput[]
    state_id?: IntFilter<"state"> | number
    state_name?: StringFilter<"state"> | string
    state_code?: StringNullableFilter<"state"> | string | null
    country_id?: IntFilter<"state"> | number
    created_at?: DateTimeFilter<"state"> | Date | string
    updated_at?: DateTimeFilter<"state"> | Date | string
  }

  export type companyCreateWithoutStateInput = {
    company_uuid?: string
    company_name?: string
    company_description?: string | null
    company_website?: string | null
    establishment_date?: Date | string | null
    company_size?: $Enums.companySizes | null
    is_active?: boolean
    company_email?: string | null
    phone_number?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    city?: cityCreateNestedOneWithoutCompanyInput
    country?: countryCreateNestedOneWithoutCompanyInput
    company_image?: company_imageCreateNestedManyWithoutCompanyInput
    company_industry?: company_industryCreateNestedManyWithoutCompanyInput
    job?: jobCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutStateInput = {
    company_id?: number
    company_uuid?: string
    company_name?: string
    company_description?: string | null
    company_website?: string | null
    establishment_date?: Date | string | null
    company_size?: $Enums.companySizes | null
    is_active?: boolean
    company_email?: string | null
    phone_number?: string | null
    company_country_id?: number
    company_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    company_image?: company_imageUncheckedCreateNestedManyWithoutCompanyInput
    company_industry?: company_industryUncheckedCreateNestedManyWithoutCompanyInput
    job?: jobUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutStateInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutStateInput, companyUncheckedCreateWithoutStateInput>
  }

  export type companyCreateManyStateInputEnvelope = {
    data: companyCreateManyStateInput | companyCreateManyStateInput[]
    skipDuplicates?: boolean
  }

  export type jobCreateWithoutStateInput = {
    job_uuid?: string
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    city?: cityCreateNestedOneWithoutJobInput
    company: companyCreateNestedOneWithoutJobInput
    country?: countryCreateNestedOneWithoutJobInput
    job_category_map?: job_category_mapCreateNestedManyWithoutJobInput
    job_salary_map?: job_salary_mapCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapCreateNestedManyWithoutJobInput
  }

  export type jobUncheckedCreateWithoutStateInput = {
    job_id?: number
    job_uuid?: string
    job_company: number
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    job_country_id?: number
    job_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    job_category_map?: job_category_mapUncheckedCreateNestedManyWithoutJobInput
    job_salary_map?: job_salary_mapUncheckedCreateNestedManyWithoutJobInput
    job_schedule_map?: job_schedule_mapUncheckedCreateNestedManyWithoutJobInput
    job_skill_map?: job_skill_mapUncheckedCreateNestedManyWithoutJobInput
    job_source_map?: job_source_mapUncheckedCreateNestedManyWithoutJobInput
    job_type_map?: job_type_mapUncheckedCreateNestedManyWithoutJobInput
  }

  export type jobCreateOrConnectWithoutStateInput = {
    where: jobWhereUniqueInput
    create: XOR<jobCreateWithoutStateInput, jobUncheckedCreateWithoutStateInput>
  }

  export type jobCreateManyStateInputEnvelope = {
    data: jobCreateManyStateInput | jobCreateManyStateInput[]
    skipDuplicates?: boolean
  }

  export type cityCreateWithoutStateInput = {
    city_name: string
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyCreateNestedManyWithoutCityInput
    job?: jobCreateNestedManyWithoutCityInput
  }

  export type cityUncheckedCreateWithoutStateInput = {
    city_id?: number
    city_name: string
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyUncheckedCreateNestedManyWithoutCityInput
    job?: jobUncheckedCreateNestedManyWithoutCityInput
  }

  export type cityCreateOrConnectWithoutStateInput = {
    where: cityWhereUniqueInput
    create: XOR<cityCreateWithoutStateInput, cityUncheckedCreateWithoutStateInput>
  }

  export type cityCreateManyStateInputEnvelope = {
    data: cityCreateManyStateInput | cityCreateManyStateInput[]
    skipDuplicates?: boolean
  }

  export type countryCreateWithoutStateInput = {
    country_name: string
    country_code?: string
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyCreateNestedManyWithoutCountryInput
    job?: jobCreateNestedManyWithoutCountryInput
  }

  export type countryUncheckedCreateWithoutStateInput = {
    country_id?: number
    country_name: string
    country_code?: string
    created_at?: Date | string
    updated_at?: Date | string
    company?: companyUncheckedCreateNestedManyWithoutCountryInput
    job?: jobUncheckedCreateNestedManyWithoutCountryInput
  }

  export type countryCreateOrConnectWithoutStateInput = {
    where: countryWhereUniqueInput
    create: XOR<countryCreateWithoutStateInput, countryUncheckedCreateWithoutStateInput>
  }

  export type companyUpsertWithWhereUniqueWithoutStateInput = {
    where: companyWhereUniqueInput
    update: XOR<companyUpdateWithoutStateInput, companyUncheckedUpdateWithoutStateInput>
    create: XOR<companyCreateWithoutStateInput, companyUncheckedCreateWithoutStateInput>
  }

  export type companyUpdateWithWhereUniqueWithoutStateInput = {
    where: companyWhereUniqueInput
    data: XOR<companyUpdateWithoutStateInput, companyUncheckedUpdateWithoutStateInput>
  }

  export type companyUpdateManyWithWhereWithoutStateInput = {
    where: companyScalarWhereInput
    data: XOR<companyUpdateManyMutationInput, companyUncheckedUpdateManyWithoutStateInput>
  }

  export type jobUpsertWithWhereUniqueWithoutStateInput = {
    where: jobWhereUniqueInput
    update: XOR<jobUpdateWithoutStateInput, jobUncheckedUpdateWithoutStateInput>
    create: XOR<jobCreateWithoutStateInput, jobUncheckedCreateWithoutStateInput>
  }

  export type jobUpdateWithWhereUniqueWithoutStateInput = {
    where: jobWhereUniqueInput
    data: XOR<jobUpdateWithoutStateInput, jobUncheckedUpdateWithoutStateInput>
  }

  export type jobUpdateManyWithWhereWithoutStateInput = {
    where: jobScalarWhereInput
    data: XOR<jobUpdateManyMutationInput, jobUncheckedUpdateManyWithoutStateInput>
  }

  export type cityUpsertWithWhereUniqueWithoutStateInput = {
    where: cityWhereUniqueInput
    update: XOR<cityUpdateWithoutStateInput, cityUncheckedUpdateWithoutStateInput>
    create: XOR<cityCreateWithoutStateInput, cityUncheckedCreateWithoutStateInput>
  }

  export type cityUpdateWithWhereUniqueWithoutStateInput = {
    where: cityWhereUniqueInput
    data: XOR<cityUpdateWithoutStateInput, cityUncheckedUpdateWithoutStateInput>
  }

  export type cityUpdateManyWithWhereWithoutStateInput = {
    where: cityScalarWhereInput
    data: XOR<cityUpdateManyMutationInput, cityUncheckedUpdateManyWithoutStateInput>
  }

  export type cityScalarWhereInput = {
    AND?: cityScalarWhereInput | cityScalarWhereInput[]
    OR?: cityScalarWhereInput[]
    NOT?: cityScalarWhereInput | cityScalarWhereInput[]
    city_id?: IntFilter<"city"> | number
    city_name?: StringFilter<"city"> | string
    state_id?: IntFilter<"city"> | number
    created_at?: DateTimeFilter<"city"> | Date | string
    updated_at?: DateTimeFilter<"city"> | Date | string
  }

  export type countryUpsertWithoutStateInput = {
    update: XOR<countryUpdateWithoutStateInput, countryUncheckedUpdateWithoutStateInput>
    create: XOR<countryCreateWithoutStateInput, countryUncheckedCreateWithoutStateInput>
    where?: countryWhereInput
  }

  export type countryUpdateToOneWithWhereWithoutStateInput = {
    where?: countryWhereInput
    data: XOR<countryUpdateWithoutStateInput, countryUncheckedUpdateWithoutStateInput>
  }

  export type countryUpdateWithoutStateInput = {
    country_name?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUpdateManyWithoutCountryNestedInput
    job?: jobUpdateManyWithoutCountryNestedInput
  }

  export type countryUncheckedUpdateWithoutStateInput = {
    country_id?: IntFieldUpdateOperationsInput | number
    country_name?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUncheckedUpdateManyWithoutCountryNestedInput
    job?: jobUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type company_imageCreateManyCompanyInput = {
    company_image_id?: number
    company_image?: string | null
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_industryCreateManyCompanyInput = {
    company_industry_id?: number
    company_industry_uuid?: string
    industry_category_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type jobCreateManyCompanyInput = {
    job_id?: number
    job_uuid?: string
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    job_country_id?: number
    job_state_id?: number
    job_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_imageUpdateWithoutCompanyInput = {
    company_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_imageUncheckedUpdateWithoutCompanyInput = {
    company_image_id?: IntFieldUpdateOperationsInput | number
    company_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_imageUncheckedUpdateManyWithoutCompanyInput = {
    company_image_id?: IntFieldUpdateOperationsInput | number
    company_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_industryUpdateWithoutCompanyInput = {
    company_industry_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    industry_category?: industry_categoryUpdateOneRequiredWithoutCompany_industryNestedInput
  }

  export type company_industryUncheckedUpdateWithoutCompanyInput = {
    company_industry_id?: IntFieldUpdateOperationsInput | number
    company_industry_uuid?: StringFieldUpdateOperationsInput | string
    industry_category_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_industryUncheckedUpdateManyWithoutCompanyInput = {
    company_industry_id?: IntFieldUpdateOperationsInput | number
    company_industry_uuid?: StringFieldUpdateOperationsInput | string
    industry_category_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jobUpdateWithoutCompanyInput = {
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: cityUpdateOneRequiredWithoutJobNestedInput
    country?: countryUpdateOneRequiredWithoutJobNestedInput
    state?: stateUpdateOneRequiredWithoutJobNestedInput
    job_category_map?: job_category_mapUpdateManyWithoutJobNestedInput
    job_salary_map?: job_salary_mapUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUpdateManyWithoutJobNestedInput
  }

  export type jobUncheckedUpdateWithoutCompanyInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    job_country_id?: IntFieldUpdateOperationsInput | number
    job_state_id?: IntFieldUpdateOperationsInput | number
    job_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_category_map?: job_category_mapUncheckedUpdateManyWithoutJobNestedInput
    job_salary_map?: job_salary_mapUncheckedUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUncheckedUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUncheckedUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUncheckedUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUncheckedUpdateManyWithoutJobNestedInput
  }

  export type jobUncheckedUpdateManyWithoutCompanyInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    job_country_id?: IntFieldUpdateOperationsInput | number
    job_state_id?: IntFieldUpdateOperationsInput | number
    job_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_industryCreateManyIndustry_categoryInput = {
    company_industry_id?: number
    company_industry_uuid?: string
    company_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type company_industryUpdateWithoutIndustry_categoryInput = {
    company_industry_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUpdateOneRequiredWithoutCompany_industryNestedInput
  }

  export type company_industryUncheckedUpdateWithoutIndustry_categoryInput = {
    company_industry_id?: IntFieldUpdateOperationsInput | number
    company_industry_uuid?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type company_industryUncheckedUpdateManyWithoutIndustry_categoryInput = {
    company_industry_id?: IntFieldUpdateOperationsInput | number
    company_industry_uuid?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_category_mapCreateManyJobInput = {
    job_category_map_id?: number
    job_category_map_uuid?: string
    category_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_salary_mapCreateManyJobInput = {
    job_salary_map_id?: number
    job_salary_map_uuid?: string
    salary_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_schedule_mapCreateManyJobInput = {
    job_schedule_map_id?: number
    job_schedule_map_uuid?: string
    schedule_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_skill_mapCreateManyJobInput = {
    job_skill_map_id?: number
    job_skill_map_uuid?: string
    skill_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_source_mapCreateManyJobInput = {
    job_source_map_id?: number
    job_source_map_uuid?: string
    source_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_type_mapCreateManyJobInput = {
    job_type_map_id?: number
    job_type_map_uuid?: string
    type_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_category_mapUpdateWithoutJobInput = {
    job_category_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_category?: job_categoryUpdateOneRequiredWithoutJob_category_mapNestedInput
  }

  export type job_category_mapUncheckedUpdateWithoutJobInput = {
    job_category_map_id?: IntFieldUpdateOperationsInput | number
    job_category_map_uuid?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_category_mapUncheckedUpdateManyWithoutJobInput = {
    job_category_map_id?: IntFieldUpdateOperationsInput | number
    job_category_map_uuid?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_salary_mapUpdateWithoutJobInput = {
    job_salary_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_salary?: job_salaryUpdateOneRequiredWithoutJob_salary_mapNestedInput
  }

  export type job_salary_mapUncheckedUpdateWithoutJobInput = {
    job_salary_map_id?: IntFieldUpdateOperationsInput | number
    job_salary_map_uuid?: StringFieldUpdateOperationsInput | string
    salary_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_salary_mapUncheckedUpdateManyWithoutJobInput = {
    job_salary_map_id?: IntFieldUpdateOperationsInput | number
    job_salary_map_uuid?: StringFieldUpdateOperationsInput | string
    salary_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_schedule_mapUpdateWithoutJobInput = {
    job_schedule_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_schedule?: job_scheduleUpdateOneRequiredWithoutJob_schedule_mapNestedInput
  }

  export type job_schedule_mapUncheckedUpdateWithoutJobInput = {
    job_schedule_map_id?: IntFieldUpdateOperationsInput | number
    job_schedule_map_uuid?: StringFieldUpdateOperationsInput | string
    schedule_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_schedule_mapUncheckedUpdateManyWithoutJobInput = {
    job_schedule_map_id?: IntFieldUpdateOperationsInput | number
    job_schedule_map_uuid?: StringFieldUpdateOperationsInput | string
    schedule_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_skill_mapUpdateWithoutJobInput = {
    job_skill_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_skill?: job_skillUpdateOneRequiredWithoutJob_skill_mapNestedInput
  }

  export type job_skill_mapUncheckedUpdateWithoutJobInput = {
    job_skill_map_id?: IntFieldUpdateOperationsInput | number
    job_skill_map_uuid?: StringFieldUpdateOperationsInput | string
    skill_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_skill_mapUncheckedUpdateManyWithoutJobInput = {
    job_skill_map_id?: IntFieldUpdateOperationsInput | number
    job_skill_map_uuid?: StringFieldUpdateOperationsInput | string
    skill_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_source_mapUpdateWithoutJobInput = {
    job_source_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_source?: job_sourceUpdateOneRequiredWithoutJob_source_mapNestedInput
  }

  export type job_source_mapUncheckedUpdateWithoutJobInput = {
    job_source_map_id?: IntFieldUpdateOperationsInput | number
    job_source_map_uuid?: StringFieldUpdateOperationsInput | string
    source_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_source_mapUncheckedUpdateManyWithoutJobInput = {
    job_source_map_id?: IntFieldUpdateOperationsInput | number
    job_source_map_uuid?: StringFieldUpdateOperationsInput | string
    source_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_type_mapUpdateWithoutJobInput = {
    job_type_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_type?: job_typeUpdateOneRequiredWithoutJob_type_mapNestedInput
  }

  export type job_type_mapUncheckedUpdateWithoutJobInput = {
    job_type_map_id?: IntFieldUpdateOperationsInput | number
    job_type_map_uuid?: StringFieldUpdateOperationsInput | string
    type_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_type_mapUncheckedUpdateManyWithoutJobInput = {
    job_type_map_id?: IntFieldUpdateOperationsInput | number
    job_type_map_uuid?: StringFieldUpdateOperationsInput | string
    type_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_category_mapCreateManyJob_categoryInput = {
    job_category_map_id?: number
    job_category_map_uuid?: string
    job_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_category_mapUpdateWithoutJob_categoryInput = {
    job_category_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: jobUpdateOneRequiredWithoutJob_category_mapNestedInput
  }

  export type job_category_mapUncheckedUpdateWithoutJob_categoryInput = {
    job_category_map_id?: IntFieldUpdateOperationsInput | number
    job_category_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_category_mapUncheckedUpdateManyWithoutJob_categoryInput = {
    job_category_map_id?: IntFieldUpdateOperationsInput | number
    job_category_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_salary_mapCreateManyJob_salaryInput = {
    job_salary_map_id?: number
    job_salary_map_uuid?: string
    job_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_salary_mapUpdateWithoutJob_salaryInput = {
    job_salary_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: jobUpdateOneRequiredWithoutJob_salary_mapNestedInput
  }

  export type job_salary_mapUncheckedUpdateWithoutJob_salaryInput = {
    job_salary_map_id?: IntFieldUpdateOperationsInput | number
    job_salary_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_salary_mapUncheckedUpdateManyWithoutJob_salaryInput = {
    job_salary_map_id?: IntFieldUpdateOperationsInput | number
    job_salary_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_schedule_mapCreateManyJob_scheduleInput = {
    job_schedule_map_id?: number
    job_schedule_map_uuid?: string
    job_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_schedule_mapUpdateWithoutJob_scheduleInput = {
    job_schedule_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: jobUpdateOneRequiredWithoutJob_schedule_mapNestedInput
  }

  export type job_schedule_mapUncheckedUpdateWithoutJob_scheduleInput = {
    job_schedule_map_id?: IntFieldUpdateOperationsInput | number
    job_schedule_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_schedule_mapUncheckedUpdateManyWithoutJob_scheduleInput = {
    job_schedule_map_id?: IntFieldUpdateOperationsInput | number
    job_schedule_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_skill_mapCreateManyJob_skillInput = {
    job_skill_map_id?: number
    job_skill_map_uuid?: string
    job_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_skill_mapUpdateWithoutJob_skillInput = {
    job_skill_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: jobUpdateOneRequiredWithoutJob_skill_mapNestedInput
  }

  export type job_skill_mapUncheckedUpdateWithoutJob_skillInput = {
    job_skill_map_id?: IntFieldUpdateOperationsInput | number
    job_skill_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_skill_mapUncheckedUpdateManyWithoutJob_skillInput = {
    job_skill_map_id?: IntFieldUpdateOperationsInput | number
    job_skill_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_source_mapCreateManyJob_sourceInput = {
    job_source_map_id?: number
    job_source_map_uuid?: string
    job_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_source_mapUpdateWithoutJob_sourceInput = {
    job_source_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: jobUpdateOneRequiredWithoutJob_source_mapNestedInput
  }

  export type job_source_mapUncheckedUpdateWithoutJob_sourceInput = {
    job_source_map_id?: IntFieldUpdateOperationsInput | number
    job_source_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_source_mapUncheckedUpdateManyWithoutJob_sourceInput = {
    job_source_map_id?: IntFieldUpdateOperationsInput | number
    job_source_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_type_mapCreateManyJob_typeInput = {
    job_type_map_id?: number
    job_type_map_uuid?: string
    job_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type job_type_mapUpdateWithoutJob_typeInput = {
    job_type_map_uuid?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: jobUpdateOneRequiredWithoutJob_type_mapNestedInput
  }

  export type job_type_mapUncheckedUpdateWithoutJob_typeInput = {
    job_type_map_id?: IntFieldUpdateOperationsInput | number
    job_type_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_type_mapUncheckedUpdateManyWithoutJob_typeInput = {
    job_type_map_id?: IntFieldUpdateOperationsInput | number
    job_type_map_uuid?: StringFieldUpdateOperationsInput | string
    job_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyCreateManyCityInput = {
    company_id?: number
    company_uuid?: string
    company_name?: string
    company_description?: string | null
    company_website?: string | null
    establishment_date?: Date | string | null
    company_size?: $Enums.companySizes | null
    is_active?: boolean
    company_email?: string | null
    phone_number?: string | null
    company_country_id?: number
    company_state_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type jobCreateManyCityInput = {
    job_id?: number
    job_uuid?: string
    job_company: number
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    job_country_id?: number
    job_state_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type companyUpdateWithoutCityInput = {
    company_uuid?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    establishment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_size?: NullableEnumcompanySizesFieldUpdateOperationsInput | $Enums.companySizes | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    company_email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: countryUpdateOneRequiredWithoutCompanyNestedInput
    state?: stateUpdateOneRequiredWithoutCompanyNestedInput
    company_image?: company_imageUpdateManyWithoutCompanyNestedInput
    company_industry?: company_industryUpdateManyWithoutCompanyNestedInput
    job?: jobUpdateManyWithoutCompanyNestedInput
  }

  export type companyUncheckedUpdateWithoutCityInput = {
    company_id?: IntFieldUpdateOperationsInput | number
    company_uuid?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    establishment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_size?: NullableEnumcompanySizesFieldUpdateOperationsInput | $Enums.companySizes | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    company_email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    company_country_id?: IntFieldUpdateOperationsInput | number
    company_state_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_image?: company_imageUncheckedUpdateManyWithoutCompanyNestedInput
    company_industry?: company_industryUncheckedUpdateManyWithoutCompanyNestedInput
    job?: jobUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type companyUncheckedUpdateManyWithoutCityInput = {
    company_id?: IntFieldUpdateOperationsInput | number
    company_uuid?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    establishment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_size?: NullableEnumcompanySizesFieldUpdateOperationsInput | $Enums.companySizes | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    company_email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    company_country_id?: IntFieldUpdateOperationsInput | number
    company_state_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type jobUpdateWithoutCityInput = {
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUpdateOneRequiredWithoutJobNestedInput
    country?: countryUpdateOneRequiredWithoutJobNestedInput
    state?: stateUpdateOneRequiredWithoutJobNestedInput
    job_category_map?: job_category_mapUpdateManyWithoutJobNestedInput
    job_salary_map?: job_salary_mapUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUpdateManyWithoutJobNestedInput
  }

  export type jobUncheckedUpdateWithoutCityInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_company?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    job_country_id?: IntFieldUpdateOperationsInput | number
    job_state_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_category_map?: job_category_mapUncheckedUpdateManyWithoutJobNestedInput
    job_salary_map?: job_salary_mapUncheckedUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUncheckedUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUncheckedUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUncheckedUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUncheckedUpdateManyWithoutJobNestedInput
  }

  export type jobUncheckedUpdateManyWithoutCityInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_company?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    job_country_id?: IntFieldUpdateOperationsInput | number
    job_state_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyCreateManyCountryInput = {
    company_id?: number
    company_uuid?: string
    company_name?: string
    company_description?: string | null
    company_website?: string | null
    establishment_date?: Date | string | null
    company_size?: $Enums.companySizes | null
    is_active?: boolean
    company_email?: string | null
    phone_number?: string | null
    company_state_id?: number
    company_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type jobCreateManyCountryInput = {
    job_id?: number
    job_uuid?: string
    job_company: number
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    job_state_id?: number
    job_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type stateCreateManyCountryInput = {
    state_id?: number
    state_name: string
    state_code?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type companyUpdateWithoutCountryInput = {
    company_uuid?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    establishment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_size?: NullableEnumcompanySizesFieldUpdateOperationsInput | $Enums.companySizes | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    company_email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: cityUpdateOneRequiredWithoutCompanyNestedInput
    state?: stateUpdateOneRequiredWithoutCompanyNestedInput
    company_image?: company_imageUpdateManyWithoutCompanyNestedInput
    company_industry?: company_industryUpdateManyWithoutCompanyNestedInput
    job?: jobUpdateManyWithoutCompanyNestedInput
  }

  export type companyUncheckedUpdateWithoutCountryInput = {
    company_id?: IntFieldUpdateOperationsInput | number
    company_uuid?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    establishment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_size?: NullableEnumcompanySizesFieldUpdateOperationsInput | $Enums.companySizes | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    company_email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    company_state_id?: IntFieldUpdateOperationsInput | number
    company_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_image?: company_imageUncheckedUpdateManyWithoutCompanyNestedInput
    company_industry?: company_industryUncheckedUpdateManyWithoutCompanyNestedInput
    job?: jobUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type companyUncheckedUpdateManyWithoutCountryInput = {
    company_id?: IntFieldUpdateOperationsInput | number
    company_uuid?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    establishment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_size?: NullableEnumcompanySizesFieldUpdateOperationsInput | $Enums.companySizes | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    company_email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    company_state_id?: IntFieldUpdateOperationsInput | number
    company_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type jobUpdateWithoutCountryInput = {
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: cityUpdateOneRequiredWithoutJobNestedInput
    company?: companyUpdateOneRequiredWithoutJobNestedInput
    state?: stateUpdateOneRequiredWithoutJobNestedInput
    job_category_map?: job_category_mapUpdateManyWithoutJobNestedInput
    job_salary_map?: job_salary_mapUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUpdateManyWithoutJobNestedInput
  }

  export type jobUncheckedUpdateWithoutCountryInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_company?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    job_state_id?: IntFieldUpdateOperationsInput | number
    job_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_category_map?: job_category_mapUncheckedUpdateManyWithoutJobNestedInput
    job_salary_map?: job_salary_mapUncheckedUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUncheckedUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUncheckedUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUncheckedUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUncheckedUpdateManyWithoutJobNestedInput
  }

  export type jobUncheckedUpdateManyWithoutCountryInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_company?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    job_state_id?: IntFieldUpdateOperationsInput | number
    job_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type stateUpdateWithoutCountryInput = {
    state_name?: StringFieldUpdateOperationsInput | string
    state_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUpdateManyWithoutStateNestedInput
    job?: jobUpdateManyWithoutStateNestedInput
    city?: cityUpdateManyWithoutStateNestedInput
  }

  export type stateUncheckedUpdateWithoutCountryInput = {
    state_id?: IntFieldUpdateOperationsInput | number
    state_name?: StringFieldUpdateOperationsInput | string
    state_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUncheckedUpdateManyWithoutStateNestedInput
    job?: jobUncheckedUpdateManyWithoutStateNestedInput
    city?: cityUncheckedUpdateManyWithoutStateNestedInput
  }

  export type stateUncheckedUpdateManyWithoutCountryInput = {
    state_id?: IntFieldUpdateOperationsInput | number
    state_name?: StringFieldUpdateOperationsInput | string
    state_code?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyCreateManyStateInput = {
    company_id?: number
    company_uuid?: string
    company_name?: string
    company_description?: string | null
    company_website?: string | null
    establishment_date?: Date | string | null
    company_size?: $Enums.companySizes | null
    is_active?: boolean
    company_email?: string | null
    phone_number?: string | null
    company_country_id?: number
    company_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type jobCreateManyStateInput = {
    job_id?: number
    job_uuid?: string
    job_company: number
    job_description?: string | null
    job_name: string
    job_posted_date: Date | string
    apply_link: string
    salary_min?: Decimal | DecimalJsLike | number | string | null
    salary_max?: Decimal | DecimalJsLike | number | string | null
    salary_currency?: string | null
    salary_frequency?: $Enums.salaryFrequency | null
    job_status?: boolean
    is_remote?: boolean
    job_country_id?: number
    job_city_id?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type cityCreateManyStateInput = {
    city_id?: number
    city_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type companyUpdateWithoutStateInput = {
    company_uuid?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    establishment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_size?: NullableEnumcompanySizesFieldUpdateOperationsInput | $Enums.companySizes | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    company_email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: cityUpdateOneRequiredWithoutCompanyNestedInput
    country?: countryUpdateOneRequiredWithoutCompanyNestedInput
    company_image?: company_imageUpdateManyWithoutCompanyNestedInput
    company_industry?: company_industryUpdateManyWithoutCompanyNestedInput
    job?: jobUpdateManyWithoutCompanyNestedInput
  }

  export type companyUncheckedUpdateWithoutStateInput = {
    company_id?: IntFieldUpdateOperationsInput | number
    company_uuid?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    establishment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_size?: NullableEnumcompanySizesFieldUpdateOperationsInput | $Enums.companySizes | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    company_email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    company_country_id?: IntFieldUpdateOperationsInput | number
    company_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_image?: company_imageUncheckedUpdateManyWithoutCompanyNestedInput
    company_industry?: company_industryUncheckedUpdateManyWithoutCompanyNestedInput
    job?: jobUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type companyUncheckedUpdateManyWithoutStateInput = {
    company_id?: IntFieldUpdateOperationsInput | number
    company_uuid?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_description?: NullableStringFieldUpdateOperationsInput | string | null
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    establishment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_size?: NullableEnumcompanySizesFieldUpdateOperationsInput | $Enums.companySizes | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    company_email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    company_country_id?: IntFieldUpdateOperationsInput | number
    company_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type jobUpdateWithoutStateInput = {
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: cityUpdateOneRequiredWithoutJobNestedInput
    company?: companyUpdateOneRequiredWithoutJobNestedInput
    country?: countryUpdateOneRequiredWithoutJobNestedInput
    job_category_map?: job_category_mapUpdateManyWithoutJobNestedInput
    job_salary_map?: job_salary_mapUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUpdateManyWithoutJobNestedInput
  }

  export type jobUncheckedUpdateWithoutStateInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_company?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    job_country_id?: IntFieldUpdateOperationsInput | number
    job_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_category_map?: job_category_mapUncheckedUpdateManyWithoutJobNestedInput
    job_salary_map?: job_salary_mapUncheckedUpdateManyWithoutJobNestedInput
    job_schedule_map?: job_schedule_mapUncheckedUpdateManyWithoutJobNestedInput
    job_skill_map?: job_skill_mapUncheckedUpdateManyWithoutJobNestedInput
    job_source_map?: job_source_mapUncheckedUpdateManyWithoutJobNestedInput
    job_type_map?: job_type_mapUncheckedUpdateManyWithoutJobNestedInput
  }

  export type jobUncheckedUpdateManyWithoutStateInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    job_uuid?: StringFieldUpdateOperationsInput | string
    job_company?: IntFieldUpdateOperationsInput | number
    job_description?: NullableStringFieldUpdateOperationsInput | string | null
    job_name?: StringFieldUpdateOperationsInput | string
    job_posted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    apply_link?: StringFieldUpdateOperationsInput | string
    salary_min?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_max?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary_currency?: NullableStringFieldUpdateOperationsInput | string | null
    salary_frequency?: NullableEnumsalaryFrequencyFieldUpdateOperationsInput | $Enums.salaryFrequency | null
    job_status?: BoolFieldUpdateOperationsInput | boolean
    is_remote?: BoolFieldUpdateOperationsInput | boolean
    job_country_id?: IntFieldUpdateOperationsInput | number
    job_city_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cityUpdateWithoutStateInput = {
    city_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUpdateManyWithoutCityNestedInput
    job?: jobUpdateManyWithoutCityNestedInput
  }

  export type cityUncheckedUpdateWithoutStateInput = {
    city_id?: IntFieldUpdateOperationsInput | number
    city_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUncheckedUpdateManyWithoutCityNestedInput
    job?: jobUncheckedUpdateManyWithoutCityNestedInput
  }

  export type cityUncheckedUpdateManyWithoutStateInput = {
    city_id?: IntFieldUpdateOperationsInput | number
    city_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}